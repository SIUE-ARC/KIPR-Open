 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area data(ram, con, rel)
 0000                   .dbfile ./main.c
 0000           _count1::
 0000 00000000          .word 0,0
 0004                   .dbfile C:\Users\borabut\DOCUME~1\GitHub\KIPR-O~1\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0004                   .dbsym e count1 _count1 L
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\borabut\DOCUME~1\GitHub\KIPR-O~1\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\borabut\DOCUME~1\GitHub\KIPR-O~1\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _count2::
 0000 00000000          .word 0,0
 0004                   .dbsym e count2 _count2 L
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\borabut\DOCUME~1\GitHub\KIPR-O~1\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
                        .area text(rom, con, rel)
 0000                   .dbfile C:\Users\borabut\DOCUME~1\GitHub\KIPR-O~1\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 25
 0000           ; //----------------------------------------------------------------------------
 0000           ; // C main line
 0000           ; //----------------------------------------------------------------------------
 0000           ; 
 0000           ; #include <m8c.h>        // part specific constants and macros
 0000           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0000           ; 
 0000           ; #pragma interrupt_handler encoder1_ISR
 0000           ; #pragma interrupt_handler encoder2_ISR
 0000           ; 
 0000           ; #define stateA1 0x20
 0000           ; #define stateB1 0x08
 0000           ; #define stateA2 0x10
 0000           ; #define stateB2 0x04
 0000           ; 
 0000           ; BYTE curPrt1;
 0000           ; BYTE prevPrt1;
 0000           ; BYTE curPrt2;
 0000           ; BYTE prevPrt2;
 0000           ; 
 0000           ; signed long int count1 = 0;
 0000           ; signed long int count2 = 0;
 0000           ; 
 0000           ; void main(void)
 0000           ; {
 0000                   .dbline 26
 0000           ;       M8C_EnableGInt ;
 0000 7101                      or  F, 01h
 0002           
 0002                   .dbline 27
 0002           ;       M8C_EnableIntMask(INT_MSK0, INT_MSK0_GPIO);
 0002 43E020            or REG[0xe0],32
 0005                   .dbline 28
 0005           ;       M8C_EnableIntMask(INT_MSK1, INT_MSK1_DBB00);
 0005 43E101            or REG[0xe1],1
 0008                   .dbline 29
 0008           ;       M8C_EnableIntMask(INT_MSK1, INT_MSK1_DBB11);
 0008 43E120            or REG[0xe1],32
 000B                   .dbline 31
 000B           ;       
 000B           ;       ENC1A_BUF_EnableInt();
 000B 10                push X
 000C 7C0000            xcall _ENC1A_BUF_EnableInt
 000F                   .dbline 32
 000F           ;       ENC1B_BUF_EnableInt();
 000F 7C0000            xcall _ENC1B_BUF_EnableInt
 0012                   .dbline 33
 0012           ;       ENC1A_BUF_Start();
 0012 7C0000            xcall _ENC1A_BUF_Start
 0015                   .dbline 34
 0015           ;       ENC1B_BUF_Start();
 0015 7C0000            xcall _ENC1B_BUF_Start
 0018 20                pop X
 0019 8013              xjmp L3
 001B           L2:
 001B                   .dbline 37
 001B           ;       
 001B           ;       while(1)
 001B           ;       {
 001B                   .dbline 38
 001B           ;               prevPrt1 = (ENC1A_Data_ADDR & (ENC1A_MASK | ENC1B_MASK));
 001B 5D08              mov A,REG[0x8]
 001D 2150              and A,80
 001F 62D000            mov REG[0xd0],>_prevPrt1
 0022 5300              mov [_prevPrt1],A
 0024                   .dbline 39
 0024           ;               prevPrt2 = (ENC2A_Data_ADDR & (ENC2A_MASK | ENC2B_MASK));
 0024 5D08              mov A,REG[0x8]
 0026 2128              and A,40
 0028 62D000            mov REG[0xd0],>_prevPrt2
 002B 5300              mov [_prevPrt2],A
 002D                   .dbline 40
 002D           ;       }
 002D           L3:
 002D                   .dbline 36
 002D 8FED              xjmp L2
 002F           X0:
 002F                   .dbline -2
 002F           L1:
 002F                   .dbline 0 ; func end
 002F 8FFF              jmp .
 0031                   .dbend
 0031                   .dbfunc e encoder1_ISR _encoder1_ISR fV
 0031           _encoder1_ISR::
 0031                   .dbline -1
 0031 71C0              or F,-64
 0033 08                push A
 0034 5DD0              mov A,REG[0xd0]
 0036 08                push A
 0037                   .dbline 44
 0037           ; }
 0037           ; 
 0037           ; void encoder1_ISR(void)
 0037           ; {
 0037                   .dbline 45
 0037           ;       curPrt1 = (ENC1A_Data_ADDR & (ENC1A_MASK | ENC1B_MASK));
 0037 5D08              mov A,REG[0x8]
 0039 2150              and A,80
 003B 62D000            mov REG[0xd0],>_curPrt1
 003E 5300              mov [_curPrt1],A
 0040                   .dbline 47
 0040           ;               
 0040           ;       if ((prevPrt1 == 0x00) && (curPrt1 == stateA1))
 0040 62D000            mov REG[0xd0],>_prevPrt1
 0043 3C0000            cmp [_prevPrt1],0
 0046 B01A              jnz L6
 0048 62D000            mov REG[0xd0],>_curPrt1
 004B 3C0020            cmp [_curPrt1],32
 004E B012              jnz L6
 0050                   .dbline 49
 0050           ;       {
 0050           ;               count1++;
 0050                   .dbline 49
 0050 62D000            mov REG[0xd0],>_count1
 0053 060301            add [_count1+3],1
 0056 0E0200            adc [_count1+2],0
 0059 0E0100            adc [_count1+1],0
 005C 0E0000            adc [_count1],0
 005F                   .dbline 50
 005F           ;       }
 005F 8020              xjmp L7
 0061           L6:
 0061                   .dbline 51
 0061           ;       else if ((prevPrt1 == 0x00) && (curPrt1 == stateB1))
 0061 62D000            mov REG[0xd0],>_prevPrt1
 0064 3C0000            cmp [_prevPrt1],0
 0067 B018              jnz L8
 0069 62D000            mov REG[0xd0],>_curPrt1
 006C 3C0008            cmp [_curPrt1],8
 006F B010              jnz L8
 0071                   .dbline 53
 0071           ;       {
 0071           ;               count1--;
 0071                   .dbline 53
 0071 62D000            mov REG[0xd0],>_count1
 0074 160301            sub [_count1+3],1
 0077 1E0200            sbb [_count1+2],0
 007A 1E0100            sbb [_count1+1],0
 007D 1E0000            sbb [_count1],0
 0080                   .dbline 54
 0080           ;       }
 0080           L8:
 0080           L7:
 0080                   .dbline -2
 0080           L5:
 0080 18                pop A
 0081 60D0              mov REG[208],A
 0083 18                pop A
 0084                   .dbline 0 ; func end
 0084 7E                reti
 0085                   .dbend
 0085                   .dbfunc e encoder2_ISR _encoder2_ISR fV
 0085           _encoder2_ISR::
 0085                   .dbline -1
 0085 71C0              or F,-64
 0087 08                push A
 0088 5DD0              mov A,REG[0xd0]
 008A 08                push A
 008B                   .dbline 59
 008B           ; }
 008B           ; 
 008B           ; 
 008B           ; void encoder2_ISR(void)
 008B           ; {
 008B                   .dbline 60
 008B           ;       curPrt2 = (ENC2A_Data_ADDR & (ENC2A_MASK | ENC2B_MASK));        
 008B 5D08              mov A,REG[0x8]
 008D 2128              and A,40
 008F 62D000            mov REG[0xd0],>_curPrt2
 0092 5300              mov [_curPrt2],A
 0094                   .dbline 62
 0094           ;               
 0094           ;       if ((prevPrt2 == 0x00) && (curPrt2 == stateA2)) 
 0094 62D000            mov REG[0xd0],>_prevPrt2
 0097 3C0000            cmp [_prevPrt2],0
 009A B01A              jnz L11
 009C 62D000            mov REG[0xd0],>_curPrt2
 009F 3C0010            cmp [_curPrt2],16
 00A2 B012              jnz L11
 00A4                   .dbline 64
 00A4           ;       {
 00A4           ;               count2++;
 00A4                   .dbline 64
 00A4 62D000            mov REG[0xd0],>_count2
 00A7 060301            add [_count2+3],1
 00AA 0E0200            adc [_count2+2],0
 00AD 0E0100            adc [_count2+1],0
 00B0 0E0000            adc [_count2],0
 00B3                   .dbline 65
 00B3           ;       }
 00B3 8020              xjmp L12
 00B5           L11:
 00B5                   .dbline 66
 00B5           ;       else if ((prevPrt2 == 0x00) && (curPrt2 == stateB2))
 00B5 62D000            mov REG[0xd0],>_prevPrt2
 00B8 3C0000            cmp [_prevPrt2],0
 00BB B018              jnz L13
 00BD 62D000            mov REG[0xd0],>_curPrt2
 00C0 3C0004            cmp [_curPrt2],4
 00C3 B010              jnz L13
 00C5                   .dbline 68
 00C5           ;       {
 00C5           ;               count2--;
 00C5                   .dbline 68
 00C5 62D000            mov REG[0xd0],>_count2
 00C8 160301            sub [_count2+3],1
 00CB 1E0200            sbb [_count2+2],0
 00CE 1E0100            sbb [_count2+1],0
 00D1 1E0000            sbb [_count2],0
 00D4                   .dbline 69
 00D4           ;       }
 00D4           L13:
 00D4           L12:
 00D4                   .dbline -2
 00D4           L10:
 00D4 18                pop A
 00D5 60D0              mov REG[208],A
 00D7 18                pop A
 00D8                   .dbline 0 ; func end
 00D8 7E                reti
 00D9                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\borabut\DOCUME~1\GitHub\KIPR-O~1\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _prevPrt2::
 0000 00                .byte 0
 0001                   .dbsym e prevPrt2 _prevPrt2 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\borabut\DOCUME~1\GitHub\KIPR-O~1\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _curPrt2::
 0000 00                .byte 0
 0001                   .dbsym e curPrt2 _curPrt2 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\borabut\DOCUME~1\GitHub\KIPR-O~1\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _prevPrt1::
 0000 00                .byte 0
 0001                   .dbsym e prevPrt1 _prevPrt1 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\borabut\DOCUME~1\GitHub\KIPR-O~1\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _curPrt1::
 0000 00                .byte 0
 0001                   .dbsym e curPrt1 _curPrt1 c
