//----------------------------------------------------------------------------
// C main line
//----------------------------------------------------------------------------

#include <m8c.h>        // part specific constants and macros
#include "PSoCAPI.h"    // PSoC API definitions for all User Modules
#include <stdlib.h>

#pragma interrupt_handler encoder1_ISR
#pragma interrupt_handler encoder2_ISR

#define 	stateA1 	0x20
#define 	stateB1 	0x08
#define 	stateA2 	0x10
#define 	stateB2 	0x04

const char 	MAV 	 	=	'a'; //Move at velocity
const char 	MOV 	 	=	'b'; //move at duty cycle
const char 	GETV 	 	=	'c'; //get velocity
const char  SRV0_POS 	= 	'd'; //set servo positions for servo 0
const char 	SRV1_POS 	= 	'e'; // ' ' ' ' ' ' ' ' ' ' ' ' ' '  1
const char  SRV2_POS 	=	'f'; // ' ' ' ' ' ' ' ' ' ' ' ' ' '  2
const char	SRV3_POS 	=	'g'; // ' ' ' ' ' ' ' ' ' ' ' ' ' '  3
const char 	GETC1	 	=	'h'; //get encoder1 count
const char  GETC2	 	=	'i'; //get encoder2 count
const char 	RSTC1	 	=	'j'; //reset encoder1 count
const char	RSTC2	 	=	'k'; //reset encoder2 count
const char  STOP		=	'l'; //stop motors

const char 	TERM		=	7; //terminator character ASCII 'Bell'

int i = 0; //loop var

BYTE curPrt1;
BYTE prevPrt1;
BYTE curPrt2;
BYTE prevPrt2;

signed long int count1 = 0;
signed long int count2 = 0;

void parseCommand(char* command, BOOL debug);
int getVelocity(void);

void main(void)
{
	char* command;
	M8C_EnableGInt ;
	M8C_EnableIntMask(INT_MSK0, INT_MSK0_GPIO);
	M8C_EnableIntMask(INT_MSK1, INT_MSK1_DBB00);
	M8C_EnableIntMask(INT_MSK1, INT_MSK1_DBB11);
	
	//enable the positive edge and falling edge buffers
	ENC1A_PEDGE_Start();
	ENC1B_PEDGE_Start();
	ENC1A_FEDGE_Start();
	ENC1B_FEDGE_Start();
	
	//enable the falling edge and positive edge interrupts for Encoder 1
	ENC1A_PEDGE_EnableInt();
	ENC1B_PEDGE_EnableInt();
	ENC1A_FEDGE_EnableInt();
	ENC1B_FEDGE_EnableInt();
	
	//Start motor speed PWMs
	PWMA_Start();
	PWMB_Start();
	
	//Start servos
	ServoA_Start();
	
	
	UART_Start(UART_PARITY_NONE);
	
	
	while(1)
	{
		prevPrt1 = (ENC1A_Data_ADDR & (ENC1A_MASK | ENC1B_MASK));
		prevPrt2 = (ENC2A_Data_ADDR & (ENC2A_MASK | ENC2B_MASK));
		
		*command = UART_cReadChar();
		if(*command)
			parseCommand(command, 1);
	}
}

int getVelocity(void)
{
	return 0;	
}

void parseCommand(char* command, BOOL debug)
{	
	char curr = '';
	char* buff;
	if (debug)
		UART_Write(command,1);
	
	
	while (curr != TERM)
	{
		curr = UART_cReadChar();
		UART_PutChar(curr);
		buff[i] = curr;
		i++;
	}
	
	i = 0;
	
	switch (*command)
	{
		MAV:
			if (debug)
			{
				UART_CPutString("Setting velocity to: ");
				UART_PutSHexInt(atoi(buff));
			}
			
			break;
		MOV:
			if (debug)
			{
				UART_CPutString("Setting PWM duty cycle to: ");
				UART_PutSHexInt(atoi(buff));
			}
			break;
		GETV:
			*buff = 0;
			UART_PutString(itoa(buff, getVelocity(), 10));
			break;
		SRV0_POS:
			if (debug)
			{
				UART_CPutString("Setting servo 0 pulse width to: ");
				UART_PutSHexInt(atoi(buff));
			}
			
			ServoA_WritePulseWidth(atoi(buff));
			
			break;
		SRV1_POS:
			if (debug)
			{
				UART_CPutString("Setting servo 1 pulse width to: ");
				UART_PutSHexInt(atoi(buff));
			}
			
			break;
		SRV2_POS:
			if (debug)
			{
				UART_CPutString("Setting servo 2 pulse width to: ");
				UART_PutSHexInt(atoi(buff));
			}
			
			break;
		SRV3_POS:
			if (debug)
			{
				UART_CPutString("Setting servo 3 pulse width to: ");
				UART_PutSHexInt(atoi(buff));
			}
			
			break;
		GETC1:
			UART_PutSHexInt(count1);
			break;
		GETC2:
			UART_PutSHexInt(count2);
			break;
		RSTC1:
			if(debug)
			{
				UART_CPutString("Resetting count1");
				count1 = 0;
			}
			
			count1 = 0;
			break;
		RSTC2:
			if(debug)
			{
				UART_CPutString("Resetting count2");
				count2 = 0;
			}
			
			count2 = 0;
			break;
		STOP:
			if(debug)
			{
				UART_CPutString("Stopping motors");
				PWMA_WritePulseWidth(0);
				PWMB_WritePulseWidth(0);
			}
			
			PWMA_WritePulseWidth(0);
			PWMB_WritePulseWidth(0);
			break;
		default :
			UART_CPutString("fu1337"); //error code
			break;
	}
}

//Encoder 1 interrupts are generated by the falling edge and positive edge buffers.
void encoder1_ISR(void)
{
	curPrt1 = (ENC1A_Data_ADDR & (ENC1A_MASK | ENC1B_MASK));
		
	if ((prevPrt1 == 0x00) && (curPrt1 == stateA1))
	{
		count1++;
	}
	else if ((prevPrt1 == 0x00) && (curPrt1 == stateB1))
	{
		count1--;
	}
}

//Encoder 2 interrupts are generated directly by the GPIO interrupt.
void encoder2_ISR(void)
{
	curPrt2 = (ENC2A_Data_ADDR & (ENC2A_MASK | ENC2B_MASK));	
		
	if ((prevPrt2 == 0x00) && (curPrt2 == stateA2))	
	{
		count2++;
	}
	else if ((prevPrt2 == 0x00) && (curPrt2 == stateB2))
	{
		count2--;
	}
}