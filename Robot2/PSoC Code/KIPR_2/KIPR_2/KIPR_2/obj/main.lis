 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area lit(rom, con, rel, lit)
 0000           _debug_mask::
 0000 0C                .byte 12
 0001                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0001                   .dbsym e debug_mask _debug_mask kc
 0001           _TERM::
 0001 07                .byte 7
 0002                   .dbsym e TERM _TERM kc
 0002           _tick_time::
 0002 32B2F4FC          .word 0x32b2,0xf4fc
 0006                   .dbsym e tick_time _tick_time kD
 0006           _encoder_res::
 0006 3D124925          .word 0x3d12,0x4925
 000A                   .dbsym e encoder_res _encoder_res kD
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _command_flag::
 0000 00                .byte 0
 0001                   .dbsym e command_flag _command_flag c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _debug::
 0000 00                .byte 0
 0001                   .dbsym e debug _debug c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _i::
 0000 0000              .word 0
 0002                   .dbsym e i _i I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _count1::
 0000 00000000          .word 0,0
 0004                   .dbsym e count1 _count1 L
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _count2::
 0000 00000000          .word 0,0
 0004                   .dbsym e count2 _count2 L
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
                        .area text(rom, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000                   .dbfunc e main _main fV
 0000           ;          param -> X+2
 0000           ;        command -> X+1
 0000           ;           data -> X+0
 0000           _main::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3804              add SP,4
 0004                   .dbline 136
 0004           ; /**
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Table of commands^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; 
 0004           ; MAV                   'a' //Move at velocity
 0004           ; MOV                   'b' //move at duty cycle
 0004           ; GETV                  'c' //get velocity
 0004           ; SRV0_POS              'd' //set servo positions for servo 0 (starts PWM)
 0004           ; SRV1_POS              'e' //set servo positions for servo 1 (starts PWM)
 0004           ; SRV0_STP              'f' //Turns a servo 0 off (stops PWM)
 0004           ; SRV1_STP              'g' //Turns a servo 1 off (stops PWM)
 0004           ; GETC1                 'h' //get encoder1 count
 0004           ; GETC2                 'i' //get encoder2 count
 0004           ; RSTC1                 'j' //reset encoder1 count
 0004           ; RSTC2                 'k' //reset encoder2 count
 0004           ; STOP                  'l' //stop motors
 0004           ; FORWARD                       'm' //sets drive mode to forward
 0004           ; BACKWARD              'n' //sets drive mode to backward
 0004           ; TURNL                 'o' //sets drive mode to left turn
 0004           ; TURNR                 'p' //sets drive mode to right turn
 0004           ; 
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Serial Limitations^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; 
 0004           ; Baude rate                    115200
 0004           ; RX Buffer size                16 bytes
 0004           ; 
 0004           ; UART RX                       P2[7]
 0004           ; UART TX                               P0[1]
 0004           ; 
 0004           ; * Theoretically 115200 bytes can be sent in one second, at minimum, and 115216 at maximum before buffer overflow.
 0004           ; 
 0004           ; * All UART commands have either one or zero parameters. All commands must be terminated with an ACII BEL (0x07).
 0004           ;   Command parameters may be space delimited from the command or can be sent as just a single string. 
 0004           ; 
 0004           ; Examples:
 0004           ; 
 0004           ; "a25" - move at velcoity 25 RPM.
 0004           ; "a 25" - move at velocity 25 RPM
 0004           ; 
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Servo Information^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; 
 0004           ; Servo0                P0[3] (MISC0)
 0004           ; Servo1                P0[7] (MISC2)
 0004           ; 
 0004           ; 16 bit resoltion for each. Every tick = 1 us.
 0004           ; 
 0004           ; Servo accepts PWM range from ~700 us to ~2200 us for a 180* servo.
 0004           ; 
 0004           ; RPi will convert servo angle to pulse width and send to PSoC. Then the servo angle will be set by writing the
 0004           ; Pulse width to the PWM register.
 0004           ; 
 0004           ; **NOTE**
 0004           ; Higer resolution can be achieved by using a faster clock and allowing for more ticks but 1 Mhz clock 1 us tick
 0004           ; makes calculations a little easier.
 0004           ; 
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Drive Modes^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; 
 0004           ; The motor driver must be configured for each of our drive modes. The drive modes are defined as follows:
 0004           ; 
 0004           ; INPUT         1A              1B              2A              2B
 0004           ; =======================================
 0004           ; Forward               1               0               1               0
 0004           ; Backward      0               1               0               1
 0004           ; Left          1               0               0               1
 0004           ; Right         0               1               1               0
 0004           ; 
 0004           ; In general for one motor
 0004           ; 
 0004           ; INPUT         A               B
 0004           ; ======================
 0004           ; Drift         1               1       (causes robot to coast)
 0004           ; CCW                   0               1
 0004           ; CW                    1               0
 0004           ; Stop          0               0
 0004           ; 
 0004           ; If STDBY is asserted (ie. pulled LOW) then all modes are treated as STOP.
 0004           ; 
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Debug Mode^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; 
 0004           ; A debug mode is provided for getting serial print statements to indicate useful data when passing commands
 0004           ; to the PSoC. To enable this mode assert MISC7 and MISC8 as high at power on. (ie, connect MISC7 and MISC8
 0004           ; to VCC before powering on).
 0004           ; 
 0004           ; After the init() function is called their states will be read and a flag will be set according to those states.
 0004           ; If debug mode is not desired merely leave those pins floating.
 0004           ; 
 0004           ; MISC7         P1[2]
 0004           ; MISC8         P1[3]
 0004           ; 
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Light Sensor^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; MISC1         P0[5]
 0004           ; 
 0004           ; */
 0004           ; 
 0004           ; #include <stdlib.h>
 0004           ; #include <m8c.h>        // part specific constants and macros
 0004           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0004           ; 
 0004           ; #pragma interrupt_handler encoder1_ISR
 0004           ; #pragma interrupt_handler encoder2_ISR
 0004           ; 
 0004           ; #define       stateA1                 0x20
 0004           ; #define       stateB1                 0x08
 0004           ; #define       stateA2                 0x10
 0004           ; #define       stateB2                 0x04
 0004           ; 
 0004           ; const BYTE    debug_mask      =       MISC7_MASK | MISC8_MASK;
 0004           ; const char    TERM            =       0x07;
 0004           ; 
 0004           ; const double tick_time = 0.0000000208333333;
 0004           ; const double encoder_res = 0.0357142857142857;
 0004           ; 
 0004           ; BOOL command_flag             =       FALSE;
 0004           ; BOOL debug                            =       FALSE;
 0004           ; 
 0004           ; int i = 0; //loop var
 0004           ; 
 0004           ; BYTE curPrt1;
 0004           ; BYTE prevPrt1;
 0004           ; BYTE curPrt2;
 0004           ; BYTE prevPrt2;
 0004           ; 
 0004           ; signed long int count1 = 0;
 0004           ; signed long int count2 = 0;
 0004           ; 
 0004           ; void init(void);
 0004           ; void action(char command, char* param);
 0004           ; double getVelocity(void);
 0004           ; 
 0004           ; void main(void)
 0004           ; {
 0004                   .dbline 141
 0004           ;       char command;
 0004           ;       char* param;
 0004           ;       char data;
 0004           ;       
 0004           ;       init();
 0004 90D7              xcall _init
 0006 80CF              xjmp L3
 0008           L2:
 0008                   .dbline 144
 0008           ;       
 0008           ;       while(1)
 0008           ;       {
 0008                   .dbline 146
 0008           ;               //read the state of encoders. this will be needed if we interrupt.
 0008           ;               prevPrt1 = (ENC1A_Data_ADDR & (ENC1A_MASK | ENC1B_MASK));
 0008 5D08              mov A,REG[0x8]
 000A 2150              and A,80
 000C 62D000            mov REG[0xd0],>_prevPrt1
 000F 5300              mov [_prevPrt1],A
 0011                   .dbline 147
 0011           ;               prevPrt2 = (ENC2A_Data_ADDR & (ENC2A_MASK | ENC2B_MASK));
 0011 5D08              mov A,REG[0x8]
 0013 2128              and A,40
 0015 62D000            mov REG[0xd0],>_prevPrt2
 0018 5300              mov [_prevPrt2],A
 001A                   .dbline 149
 001A           ;               
 001A           ;               data = UART_cReadChar(); //check for data
 001A 10                push X
 001B 7C0000            xcall _UART_cReadChar
 001E 20                pop X
 001F 5400              mov [X+0],A
 0021                   .dbline 151
 0021           ;               
 0021           ;               if (!command_flag && data) //no command has been read and data is valid (not null)
 0021 62D000            mov REG[0xd0],>_command_flag
 0024 3C0000            cmp [_command_flag],0
 0027 B022              jnz L5
 0029 3D0000            cmp [X+0],0
 002C A01D              jz L5
 002E                   .dbline 153
 002E           ;               {
 002E           ;                       if (debug)
 002E                   .dbline 153
 002E 62D000            mov REG[0xd0],>_debug
 0031 3C0000            cmp [_debug],0
 0034 A008              jz L7
 0036                   .dbline 154
 0036           ;                               UART_PutChar(data);
 0036 10                push X
 0037 5200              mov A,[X+0]
 0039 7C0000            xcall _UART_PutChar
 003C 20                pop X
 003D           L7:
 003D                   .dbline 156
 003D           ;                       
 003D           ;                       command_flag = TRUE;
 003D 62D000            mov REG[0xd0],>_command_flag
 0040 550001            mov [_command_flag],1
 0043                   .dbline 157
 0043           ;                       command = data;
 0043 5200              mov A,[X+0]
 0045 5401              mov [X+1],A
 0047                   .dbline 158
 0047           ;                       data = '\0';
 0047 560000            mov [X+0],0
 004A                   .dbline 159
 004A           ;               }
 004A           L5:
 004A                   .dbline 160
 004A           ;               if (data && command_flag)//command byte read and data is valid (not null)
 004A 3D0000            cmp [X+0],0
 004D A088              jz L9
 004F 62D000            mov REG[0xd0],>_command_flag
 0052 3C0000            cmp [_command_flag],0
 0055 A080              jz L9
 0057                   .dbline 162
 0057           ;               {
 0057           ;                       if (data == TERM) //command terminator read
 0057                   .dbline 162
 0057 62D000            mov REG[0xd0],>__r0
 005A 5001              mov A,>_TERM
 005C 10                push X
 005D 5701              mov X,<_TERM
 005F 28                romx
 0060 20                pop X
 0061 5300              mov [__r0],A
 0063 5200              mov A,[X+0]
 0065 3A00              cmp A,[__r0]
 0067 B03B              jnz L11
 0069                   .dbline 164
 0069           ;                       {
 0069           ;                               command_flag = FALSE;
 0069                   .dbline 164
 0069 62D000            mov REG[0xd0],>_command_flag
 006C 550000            mov [_command_flag],0
 006F                   .dbline 165
 006F           ;                               param[i] = '\0'; //null terminate parameter string
 006F 62D000            mov REG[0xd0],>_i
 0072 5101              mov A,[_i+1]
 0074 0303              add A,[X+3]
 0076 62D000            mov REG[0xd0],>__r0
 0079 5300              mov [__r1],A
 007B 62D000            mov REG[0xd0],>_i
 007E 5100              mov A,[_i]
 0080 0B02              adc A,[X+2]
 0082 62D000            mov REG[0xd0],>__r0
 0085 60D5              mov REG[0xd5],A
 0087 5000              mov A,0
 0089 3F00              mvi [__r1],A
 008B                   .dbline 166
 008B           ;                               action(command, param);
 008B 5202              mov A,[X+2]
 008D 08                push A
 008E 5203              mov A,[X+3]
 0090 08                push A
 0091 5201              mov A,[X+1]
 0093 08                push A
 0094 9478              xcall _action
 0096 38FD              add SP,-3
 0098                   .dbline 167
 0098           ;                               i = 0; //reset counter
 0098 62D000            mov REG[0xd0],>_i
 009B 550100            mov [_i+1],0
 009E 550000            mov [_i],0
 00A1                   .dbline 168
 00A1           ;                       }
 00A1 8034              xjmp L12
 00A3           L11:
 00A3                   .dbline 170
 00A3           ;                       else //read parameter byte 
 00A3           ;                       {
 00A3                   .dbline 171
 00A3           ;                               if (debug)
 00A3 62D000            mov REG[0xd0],>_debug
 00A6 3C0000            cmp [_debug],0
 00A9 A008              jz L13
 00AB                   .dbline 172
 00AB           ;                                       UART_PutChar(data);
 00AB 10                push X
 00AC 5200              mov A,[X+0]
 00AE 7C0000            xcall _UART_PutChar
 00B1 20                pop X
 00B2           L13:
 00B2                   .dbline 174
 00B2           ;                               
 00B2           ;                               param[i] = data;
 00B2 62D000            mov REG[0xd0],>_i
 00B5 5101              mov A,[_i+1]
 00B7 0303              add A,[X+3]
 00B9 62D000            mov REG[0xd0],>__r0
 00BC 5300              mov [__r1],A
 00BE 62D000            mov REG[0xd0],>_i
 00C1 5100              mov A,[_i]
 00C3 0B02              adc A,[X+2]
 00C5 62D000            mov REG[0xd0],>__r0
 00C8 60D5              mov REG[0xd5],A
 00CA 5200              mov A,[X+0]
 00CC 3F00              mvi [__r1],A
 00CE                   .dbline 175
 00CE           ;                               i++;
 00CE 62D000            mov REG[0xd0],>_i
 00D1 7601              inc [_i+1]
 00D3 0E0000            adc [_i],0
 00D6                   .dbline 176
 00D6           ;                       }
 00D6           L12:
 00D6                   .dbline 177
 00D6           ;               }
 00D6           L9:
 00D6                   .dbline 178
 00D6           ;       }
 00D6           L3:
 00D6                   .dbline 143
 00D6 8F31              xjmp L2
 00D8           X0:
 00D8                   .dbline -2
 00D8           L1:
 00D8 38FC              add SP,-4
 00DA 20                pop X
 00DB                   .dbline 0 ; func end
 00DB 8FFF              jmp .
 00DD                   .dbsym l param 2 pc
 00DD                   .dbsym l command 1 c
 00DD                   .dbsym l data 0 c
 00DD                   .dbend
 00DD                   .dbfunc e init _init fV
 00DD           ;     debug_conf -> X+6
 00DD           ;    misc7_start -> X+3
 00DD           ;    misc8_start -> X+0
 00DD           _init::
 00DD                   .dbline -1
 00DD 10                push X
 00DE 4F                mov X,SP
 00DF 3807              add SP,7
 00E1                   .dbline 182
 00E1           ; }
 00E1           ; 
 00E1           ; void init(void)
 00E1           ; {
 00E1                   .dbline 187
 00E1           ;       BYTE debug_conf;
 00E1           ;       BYTE misc8_start[3], misc7_start[3];
 00E1           ;       
 00E1           ;       //enable the positive edge and falling edge paramers
 00E1           ;       ENC1A_PEDGE_Start();
 00E1 10                push X
 00E2 7C0000            xcall _ENC1A_PEDGE_Start
 00E5                   .dbline 188
 00E5           ;       ENC1B_PEDGE_Start();
 00E5 7C0000            xcall _ENC1B_PEDGE_Start
 00E8                   .dbline 189
 00E8           ;       ENC1A_NEDGE_Start();
 00E8 7C0000            xcall _ENC1A_NEDGE_Start
 00EB                   .dbline 190
 00EB           ;       ENC1B_NEDGE_Start();
 00EB 7C0000            xcall _ENC1B_NEDGE_Start
 00EE                   .dbline 193
 00EE           ;       
 00EE           ;       //enable the falling edge and positive edge interrupts for Encoder 1
 00EE           ;       ENC1A_PEDGE_EnableInt();
 00EE 7C0000            xcall _ENC1A_PEDGE_EnableInt
 00F1                   .dbline 194
 00F1           ;       ENC1B_PEDGE_EnableInt();
 00F1 7C0000            xcall _ENC1B_PEDGE_EnableInt
 00F4                   .dbline 195
 00F4           ;       ENC1A_NEDGE_EnableInt();
 00F4 7C0000            xcall _ENC1A_NEDGE_EnableInt
 00F7                   .dbline 196
 00F7           ;       ENC1B_NEDGE_EnableInt();
 00F7 7C0000            xcall _ENC1B_NEDGE_EnableInt
 00FA                   .dbline 199
 00FA           ;       
 00FA           ;       //Start motor speed PWMs
 00FA           ;       PWMA_Start();
 00FA 7C0000            xcall _PWMA_Start
 00FD                   .dbline 200
 00FD           ;       PWMB_Start();
 00FD 7C0000            xcall _PWMB_Start
 0100                   .dbline 203
 0100           ;       
 0100           ;       //Start servos
 0100           ;       Servo0_Start();
 0100 7C0000            xcall _Servo0_Start
 0103                   .dbline 204
 0103           ;       Servo1_Start();
 0103 7C0000            xcall _Servo1_Start
 0106                   .dbline 207
 0106           ;       
 0106           ;       //start the UART
 0106           ;       UART_Start(UART_PARITY_NONE);
 0106 5000              mov A,0
 0108 7C0000            xcall _UART_Start
 010B                   .dbline 210
 010B           ;       
 010B           ;       //start the Velocity Timer
 010B           ;       VelTimer_Start();
 010B 7C0000            xcall _VelTimer_Start
 010E 20                pop X
 010F                   .dbline 213
 010F           ;       
 010F           ;       //enable appropriate interrupts
 010F           ;       M8C_EnableIntMask(INT_MSK0, INT_MSK0_GPIO);
 010F 43E020            or REG[0xe0],32
 0112                   .dbline 214
 0112           ;       M8C_EnableIntMask(INT_MSK1, INT_MSK1_DBB00);
 0112 43E101            or REG[0xe1],1
 0115                   .dbline 215
 0115           ;       M8C_EnableIntMask(INT_MSK1, INT_MSK1_DBB11);
 0115 43E120            or REG[0xe1],32
 0118                   .dbline 216
 0118           ;       M8C_EnableGInt;
 0118 7101                      or  F, 01h
 011A           
 011A                   .dbline 218
 011A           ;       
 011A           ;       UART_PutCRLF();
 011A 10                push X
 011B 7C0000            xcall _UART_PutCRLF
 011E                   .dbline 219
 011E           ;       UART_CPutString("KIPR bots roll out!");
 011E 5099              mov A,>L16
 0120 08                push A
 0121 5099              mov A,<L16
 0123 5C                mov X,A
 0124 18                pop A
 0125 7C0000            xcall _UART_CPutString
 0128                   .dbline 220
 0128           ;       UART_PutCRLF(); 
 0128 7C0000            xcall _UART_PutCRLF
 012B 20                pop X
 012C                   .dbline 223
 012C           ;               
 012C           ;       //clear drive mode settings for MISC7
 012C           ;       MISC7_DriveMode_0_ADDR &= ~MISC7_MASK;
 012C 7110              or F,0x10  ; iopage = 1
 012E 4104FB            and REG[0x4],-5
 0131                   .dbline 224
 0131           ;       MISC7_DriveMode_1_ADDR &= ~MISC7_MASK;
 0131 4105FB            and REG[0x5],-5
 0134                   .dbline 225
 0134           ;       MISC7_DriveMode_2_ADDR &= ~MISC7_MASK;
 0134 70CF              and F,0xCF      ; iopage = 0
 0136 4107FB            and REG[0x7],-5
 0139                   .dbline 228
 0139           ;       
 0139           ;       //clear drive mode settings for MISC8
 0139           ;       MISC8_DriveMode_0_ADDR &= ~MISC8_MASK;
 0139 7110              or F,0x10  ; iopage = 1
 013B 4104F7            and REG[0x4],-9
 013E                   .dbline 229
 013E           ;       MISC8_DriveMode_1_ADDR &= ~MISC8_MASK;
 013E 4105F7            and REG[0x5],-9
 0141                   .dbline 230
 0141           ;       MISC8_DriveMode_2_ADDR &= ~MISC8_MASK;
 0141 70CF              and F,0xCF      ; iopage = 0
 0143 4107F7            and REG[0x7],-9
 0146                   .dbline 234
 0146           ;       
 0146           ;       //now that their settings are cleared set their mode to
 0146           ;       //HIGH-Z to use them as debug point inputs.
 0146           ;       MISC7_DriveMode_1_ADDR |= MISC7_MASK;
 0146 7110              or F,0x10  ; iopage = 1
 0148 430504            or REG[0x5],4
 014B                   .dbline 236
 014B           ;       
 014B           ;       MISC8_DriveMode_1_ADDR |= MISC8_MASK;
 014B 430508            or REG[0x5],8
 014E                   .dbline 239
 014E           ;       
 014E           ;       //wait for drive modes to change.
 014E           ;       for(i = 0; i < 1000; i++);
 014E 70CF              and F,0xCF      ; iopage = 0
 0150 62D000            mov REG[0xd0],>_i
 0153 550100            mov [_i+1],0
 0156 550000            mov [_i],0
 0159           L17:
 0159                   .dbline 239
 0159           L18:
 0159                   .dbline 239
 0159 62D000            mov REG[0xd0],>_i
 015C 7601              inc [_i+1]
 015E 0E0000            adc [_i],0
 0161                   .dbline 239
 0161 5101              mov A,[_i+1]
 0163 11E8              sub A,-24
 0165 5100              mov A,[_i]
 0167 3180              xor A,-128
 0169 1983              sbb A,(3 ^ 0x80)
 016B CFED              jc L17
 016D           X1:
 016D                   .dbline 243
 016D           ;       
 016D           ;       //read the debug inputs, if they are high then they are
 016D           ;       //being purposefully asserted to enter debug mode.
 016D           ;       debug_conf &= ((MISC7_Data_ADDR & MISC7_MASK) | (MISC8_Data_ADDR & MISC8_MASK));
 016D 5D04              mov A,REG[0x4]
 016F 62D000            mov REG[0xd0],>__r0
 0172 5300              mov [__r0],A
 0174 260008            and [__r0],8
 0177 5D04              mov A,REG[0x4]
 0179 5300              mov [__r2],A
 017B 260004            and [__r2],4
 017E 5100              mov A,[__r2]
 0180 2A00              or A,[__r0]
 0182 2506              and [X+6],A
 0184                   .dbline 245
 0184           ;       
 0184           ;       if (debug_conf == debug_mask)
 0184 5000              mov A,>_debug_mask
 0186 10                push X
 0187 5700              mov X,<_debug_mask
 0189 28                romx
 018A 20                pop X
 018B 5300              mov [__r0],A
 018D 5206              mov A,[X+6]
 018F 3A00              cmp A,[__r0]
 0191 B007              jnz L21
 0193                   .dbline 246
 0193           ;               debug = TRUE;
 0193 62D000            mov REG[0xd0],>_debug
 0196 550001            mov [_debug],1
 0199           L21:
 0199                   .dbline 249
 0199           ;       
 0199           ;       //afterwards reset MISC pins to their intended state
 0199           ;       misc7_start[0] = MISC7_DriveMode_0_ADDR;
 0199 7110              or F,0x10  ; iopage = 1
 019B 5D04              mov A,REG[0x4]
 019D 5403              mov [X+3],A
 019F                   .dbline 250
 019F           ;       misc7_start[1] = MISC7_DriveMode_1_ADDR;
 019F 5D05              mov A,REG[0x5]
 01A1 5404              mov [X+4],A
 01A3                   .dbline 251
 01A3           ;       misc7_start[2] = MISC7_DriveMode_2_ADDR;
 01A3 70CF              and F,0xCF      ; iopage = 0
 01A5 5D07              mov A,REG[0x7]
 01A7 5405              mov [X+5],A
 01A9                   .dbline 253
 01A9           ;       
 01A9           ;       MISC7_DriveMode_0_ADDR &= ~MISC7_MASK;
 01A9 7110              or F,0x10  ; iopage = 1
 01AB 4104FB            and REG[0x4],-5
 01AE                   .dbline 254
 01AE           ;       MISC7_DriveMode_1_ADDR &= ~MISC7_MASK;
 01AE 4105FB            and REG[0x5],-5
 01B1                   .dbline 255
 01B1           ;       MISC7_DriveMode_2_ADDR &= ~MISC7_MASK;
 01B1 70CF              and F,0xCF      ; iopage = 0
 01B3 4107FB            and REG[0x7],-5
 01B6                   .dbline 257
 01B6           ;       
 01B6           ;       misc8_start[0] = MISC8_DriveMode_0_ADDR;
 01B6 7110              or F,0x10  ; iopage = 1
 01B8 5D04              mov A,REG[0x4]
 01BA 5400              mov [X+0],A
 01BC                   .dbline 258
 01BC           ;       misc8_start[1] = MISC8_DriveMode_1_ADDR;
 01BC 5D05              mov A,REG[0x5]
 01BE 5401              mov [X+1],A
 01C0                   .dbline 259
 01C0           ;       misc8_start[2] = MISC8_DriveMode_2_ADDR;
 01C0 70CF              and F,0xCF      ; iopage = 0
 01C2 5D07              mov A,REG[0x7]
 01C4 5402              mov [X+2],A
 01C6                   .dbline 261
 01C6           ;       
 01C6           ;       MISC8_DriveMode_0_ADDR &= ~MISC8_MASK;
 01C6 7110              or F,0x10  ; iopage = 1
 01C8 4104F7            and REG[0x4],-9
 01CB                   .dbline 262
 01CB           ;       MISC8_DriveMode_1_ADDR &= ~MISC8_MASK;
 01CB 4105F7            and REG[0x5],-9
 01CE                   .dbline 263
 01CE           ;       MISC8_DriveMode_2_ADDR &= ~MISC8_MASK;
 01CE 70CF              and F,0xCF      ; iopage = 0
 01D0 4107F7            and REG[0x7],-9
 01D3                   .dbline 266
 01D3           ;       
 01D3           ;       //set MISC7 and MISC8 to original pin mux state
 01D3           ;       MISC7_DriveMode_2_ADDR |= misc7_start[2];
 01D3 5D07              mov A,REG[0x7]
 01D5 62D000            mov REG[0xd0],>__r0
 01D8 5300              mov [__r0],A
 01DA 5205              mov A,[X+5]
 01DC 2C00              or [__r0],A
 01DE 5100              mov A,[__r0]
 01E0 6007              mov REG[0x7],A
 01E2                   .dbline 267
 01E2           ;       MISC7_DriveMode_1_ADDR |= misc7_start[1];
 01E2 7110              or F,0x10  ; iopage = 1
 01E4 5D05              mov A,REG[0x5]
 01E6 5300              mov [__r0],A
 01E8 5204              mov A,[X+4]
 01EA 2C00              or [__r0],A
 01EC 5100              mov A,[__r0]
 01EE 6005              mov REG[0x5],A
 01F0                   .dbline 268
 01F0           ;       MISC7_DriveMode_0_ADDR |= misc7_start[0];
 01F0 5D04              mov A,REG[0x4]
 01F2 5300              mov [__r0],A
 01F4 5203              mov A,[X+3]
 01F6 2C00              or [__r0],A
 01F8 5100              mov A,[__r0]
 01FA 6004              mov REG[0x4],A
 01FC                   .dbline 270
 01FC           ;       
 01FC           ;       MISC8_DriveMode_2_ADDR |= misc8_start[2];
 01FC 70CF              and F,0xCF      ; iopage = 0
 01FE 5D07              mov A,REG[0x7]
 0200 5300              mov [__r0],A
 0202 5202              mov A,[X+2]
 0204 2C00              or [__r0],A
 0206 5100              mov A,[__r0]
 0208 6007              mov REG[0x7],A
 020A                   .dbline 271
 020A           ;       MISC8_DriveMode_1_ADDR |= misc8_start[1];
 020A 7110              or F,0x10  ; iopage = 1
 020C 5D05              mov A,REG[0x5]
 020E 5300              mov [__r0],A
 0210 5201              mov A,[X+1]
 0212 2C00              or [__r0],A
 0214 5100              mov A,[__r0]
 0216 6005              mov REG[0x5],A
 0218                   .dbline 272
 0218           ;       MISC8_DriveMode_0_ADDR |= misc8_start[0];
 0218 5D04              mov A,REG[0x4]
 021A 5300              mov [__r0],A
 021C 5200              mov A,[X+0]
 021E 2C00              or [__r0],A
 0220 5100              mov A,[__r0]
 0222 6004              mov REG[0x4],A
 0224                   .dbline -2
 0224 70CF              and F,0xCF      ; iopage = 0
 0226           L15:
 0226 38F9              add SP,-7
 0228 20                pop X
 0229                   .dbline 0 ; func end
 0229 7F                ret
 022A                   .dbsym l debug_conf 6 c
 022A                   .dbsym l misc7_start 3 A[3:3]c
 022A                   .dbsym l misc8_start 0 A[3:3]c
 022A                   .dbend
 022A                   .dbfunc e getVelocity _getVelocity fD
 022A           ;      initTicks -> X+18
 022A           ;       endTicks -> X+16
 022A           ;            vel -> X+12
 022A           ;      ticksDone -> X+8
 022A           ;      initCount -> X+4
 022A           ;           diff -> X+0
 022A           _getVelocity::
 022A                   .dbline -1
 022A 10                push X
 022B 4F                mov X,SP
 022C 3816              add SP,22
 022E                   .dbline 277
 022E           ; }
 022E           ; 
 022E           ; /* Calculates the velocity in RPMs and returns the value */
 022E           ; double getVelocity(void)
 022E           ; {
 022E                   .dbline 278
 022E           ;       double vel = 0;
 022E 560C00            mov [X+12],0
 0231 560D00            mov [X+13],0
 0234 560E00            mov [X+14],0
 0237 560F00            mov [X+15],0
 023A                   .dbline 281
 023A           ;       DWORD* endTicks; //ending value of counter
 023A           ;       DWORD* initTicks; //initial counter reg value
 023A           ;       DWORD ticksDone = 14; //number of ticks til done looping
 023A 560800            mov [X+8],0
 023D 560900            mov [X+9],0
 0240 560A00            mov [X+10],0
 0243 560B0E            mov [X+11],14
 0246                   .dbline 282
 0246           ;       DWORD diff = 0; //difference between current count reg and 
 0246 560000            mov [X+0],0
 0249 560100            mov [X+1],0
 024C 560200            mov [X+2],0
 024F 560300            mov [X+3],0
 0252                   .dbline 283
 0252           ;       signed long initCount = 0;
 0252 560400            mov [X+4],0
 0255 560500            mov [X+5],0
 0258 560600            mov [X+6],0
 025B 560700            mov [X+7],0
 025E                   .dbline 285
 025E           ;       
 025E           ;       VelTimer_ReadTimer(initTicks); //read the counter
 025E 10                push X
 025F 5212              mov A,[X+18]
 0261 08                push A
 0262 5213              mov A,[X+19]
 0264 5C                mov X,A
 0265 18                pop A
 0266 7C0000            xcall _VelTimer_ReadTimer
 0269 20                pop X
 026A                   .dbline 286
 026A           ;       initCount = count1;
 026A 62D000            mov REG[0xd0],>_count1
 026D 5100              mov A,[_count1]
 026F 5404              mov [X+4],A
 0271 5101              mov A,[_count1+1]
 0273 5405              mov [X+5],A
 0275 5102              mov A,[_count1+2]
 0277 5406              mov [X+6],A
 0279 5103              mov A,[_count1+3]
 027B 5407              mov [X+7],A
 027D           L32:
 027D                   .dbline 290
 027D           ;       
 027D           ;       //keep reading the value until the difference between first and current is large enough
 027D           ;       do 
 027D           ;       {
 027D                   .dbline 291
 027D           ;               diff = abs(abs(count1) - abs(initCount));
 027D 62D000            mov REG[0xd0],>_count1
 0280 5103              mov A,[_count1+3]
 0282 62D000            mov REG[0xd0],>__r0
 0285 5300              mov [__r1],A
 0287 62D000            mov REG[0xd0],>_count1
 028A 5102              mov A,[_count1+2]
 028C 62D000            mov REG[0xd0],>__r0
 028F 08                push A
 0290 5100              mov A,[__r1]
 0292 08                push A
 0293 7C0000            xcall _abs
 0296 38FE              add SP,-2
 0298 62D000            mov REG[0xd0],>__r0
 029B 5100              mov A,[__r1]
 029D 5415              mov [X+21],A
 029F 5100              mov A,[__r0]
 02A1 5414              mov [X+20],A
 02A3 5207              mov A,[X+7]
 02A5 5300              mov [__r3],A
 02A7 5206              mov A,[X+6]
 02A9 08                push A
 02AA 5100              mov A,[__r3]
 02AC 08                push A
 02AD 7C0000            xcall _abs
 02B0 62D000            mov REG[0xd0],>__r0
 02B3 5215              mov A,[X+21]
 02B5 1200              sub A,[__r1]
 02B7 5300              mov [__r1],A
 02B9 5214              mov A,[X+20]
 02BB 1A00              sbb A,[__r0]
 02BD 08                push A
 02BE 5100              mov A,[__r1]
 02C0 08                push A
 02C1 7C0000            xcall _abs
 02C4 38FC              add SP,-4
 02C6 62D000            mov REG[0xd0],>__r0
 02C9 5100              mov A,[__r1]
 02CB 5403              mov [X+3],A
 02CD 5100              mov A,[__r0]
 02CF 5402              mov [X+2],A
 02D1 480280            tst [X+2],-128
 02D4 A009              jz X2
 02D6 5601FF            mov [X+1],-1
 02D9 5600FF            mov [X+0],-1
 02DC 8007              jmp X3
 02DE           X2:
 02DE 560100            mov [X+1],0
 02E1 560000            mov [X+0],0
 02E4           X3:
 02E4                   .dbline 292
 02E4           ;       }
 02E4           L33:
 02E4                   .dbline 293
 02E4           ;       while(diff > ticksDone);
 02E4 520B              mov A,[X+11]
 02E6 1303              sub A,[X+3]
 02E8 520A              mov A,[X+10]
 02EA 1B02              sbb A,[X+2]
 02EC 5209              mov A,[X+9]
 02EE 1B01              sbb A,[X+1]
 02F0 5208              mov A,[X+8]
 02F2 1B00              sbb A,[X+0]
 02F4 CF88              jc L32
 02F6           X4:
 02F6                   .dbline 295
 02F6           ;       
 02F6           ;       VelTimer_ReadTimer(endTicks);
 02F6 10                push X
 02F7 5210              mov A,[X+16]
 02F9 08                push A
 02FA 5211              mov A,[X+17]
 02FC 5C                mov X,A
 02FD 18                pop A
 02FE 7C0000            xcall _VelTimer_ReadTimer
 0301 20                pop X
 0302                   .dbline 297
 0302           ;       
 0302           ;       vel = encoder_res*diff/(abs(*initTicks - *endTicks)*tick_time);
 0302 62D000            mov REG[0xd0],>__r0
 0305 5211              mov A,[X+17]
 0307 5300              mov [__r1],A
 0309 5210              mov A,[X+16]
 030B 60D4              mov REG[0xd4],A
 030D 3E00              mvi A,[__r1]
 030F 3E00              mvi A,[__r1]
 0311 3E00              mvi A,[__r1]
 0313 5300              mov [__r6],A
 0315 3E00              mvi A,[__r1]
 0317 5300              mov [__r7],A
 0319 5213              mov A,[X+19]
 031B 5300              mov [__r1],A
 031D 5212              mov A,[X+18]
 031F 60D4              mov REG[0xd4],A
 0321 3E00              mvi A,[__r1]
 0323 3E00              mvi A,[__r1]
 0325 3E00              mvi A,[__r1]
 0327 5300              mov [__r10],A
 0329 3E00              mvi A,[__r1]
 032B 1200              sub A,[__r7]
 032D 5300              mov [__r3],A
 032F 5100              mov A,[__r10]
 0331 1A00              sbb A,[__r6]
 0333 5300              mov [__r2],A
 0335 5100              mov A,[__r3]
 0337 5300              mov [__r1],A
 0339 5100              mov A,[__r2]
 033B 08                push A
 033C 5100              mov A,[__r1]
 033E 08                push A
 033F 7C0000            xcall _abs
 0342 38FE              add SP,-2
 0344 62D000            mov REG[0xd0],>__r0
 0347 550002            mov [__r3],<_tick_time
 034A 550002            mov [__r2],>_tick_time
 034D 5100              mov A,[__r2]
 034F 10                push X
 0350 5800              mov X,[__r3]
 0352 08                push A
 0353 28                romx
 0354 5300              mov [__r4],A
 0356 18                pop A
 0357 75                inc X
 0358 0900              adc A,0
 035A 08                push A
 035B 28                romx
 035C 5300              mov [__r5],A
 035E 18                pop A
 035F 75                inc X
 0360 0900              adc A,0
 0362 08                push A
 0363 28                romx
 0364 5300              mov [__r6],A
 0366 18                pop A
 0367 75                inc X
 0368 0900              adc A,0
 036A 28                romx
 036B 5300              mov [__r7],A
 036D 20                pop X
 036E 5100              mov A,[__r1]
 0370 5300              mov [__r3],A
 0372 5100              mov A,[__r0]
 0374 5300              mov [__r2],A
 0376 470080            tst [__r2],-128
 0379 A009              jz X5
 037B 5500FF            mov [__r1],-1
 037E 5500FF            mov [__r0],-1
 0381 800A              jmp X6
 0383           X5:
 0383 62D000            mov REG[0xd0],>__r0
 0386 550000            mov [__r1],0
 0389 550000            mov [__r0],0
 038C           X6:
 038C 62D000            mov REG[0xd0],>__r0
 038F 5100              mov A,[__r0]
 0391 08                push A
 0392 5100              mov A,[__r1]
 0394 08                push A
 0395 5100              mov A,[__r2]
 0397 08                push A
 0398 5100              mov A,[__r3]
 039A 08                push A
 039B 7C0000            xcall __long2fp
 039E 18                pop A
 039F 5300              mov [__r3],A
 03A1 18                pop A
 03A2 5300              mov [__r2],A
 03A4 18                pop A
 03A5 5300              mov [__r1],A
 03A7 18                pop A
 03A8 5300              mov [__r0],A
 03AA 5100              mov A,[__r4]
 03AC 08                push A
 03AD 5100              mov A,[__r5]
 03AF 08                push A
 03B0 5100              mov A,[__r6]
 03B2 08                push A
 03B3 5100              mov A,[__r7]
 03B5 08                push A
 03B6 5100              mov A,[__r0]
 03B8 08                push A
 03B9 5100              mov A,[__r1]
 03BB 08                push A
 03BC 5100              mov A,[__r2]
 03BE 08                push A
 03BF 5100              mov A,[__r3]
 03C1 08                push A
 03C2 7C0000            xcall __fpmul
 03C5 18                pop A
 03C6 5300              mov [__r3],A
 03C8 18                pop A
 03C9 5300              mov [__r2],A
 03CB 18                pop A
 03CC 5300              mov [__r1],A
 03CE 18                pop A
 03CF 5300              mov [__r0],A
 03D1 38FC              add SP,-4
 03D3 5203              mov A,[X+3]
 03D5 2101              and A,1
 03D7 5300              mov [__r7],A
 03D9 5202              mov A,[X+2]
 03DB 2100              and A,0
 03DD 5300              mov [__r6],A
 03DF 5201              mov A,[X+1]
 03E1 2100              and A,0
 03E3 5300              mov [__r5],A
 03E5 5200              mov A,[X+0]
 03E7 2100              and A,0
 03E9 08                push A
 03EA 5100              mov A,[__r5]
 03EC 08                push A
 03ED 5100              mov A,[__r6]
 03EF 08                push A
 03F0 5100              mov A,[__r7]
 03F2 08                push A
 03F3 7C0000            xcall __long2fp
 03F6 18                pop A
 03F7 5300              mov [__r7],A
 03F9 18                pop A
 03FA 5300              mov [__r6],A
 03FC 18                pop A
 03FD 5300              mov [__r5],A
 03FF 18                pop A
 0400 5300              mov [__r4],A
 0402 5200              mov A,[X+0]
 0404 5300              mov [__r8],A
 0406 5201              mov A,[X+1]
 0408 5300              mov [__r9],A
 040A 5202              mov A,[X+2]
 040C 5300              mov [__r10],A
 040E 5203              mov A,[X+3]
 0410 5300              mov [__r11],A
 0412 70FB              and F,-5
 0414 6E00              rrc [__r8]
 0416 6E00              rrc [__r9]
 0418 6E00              rrc [__r10]
 041A 6E00              rrc [__r11]
 041C 5100              mov A,[__r8]
 041E 08                push A
 041F 5100              mov A,[__r9]
 0421 08                push A
 0422 5100              mov A,[__r10]
 0424 08                push A
 0425 5100              mov A,[__r11]
 0427 08                push A
 0428 7C0000            xcall __long2fp
 042B 18                pop A
 042C 5300              mov [__r11],A
 042E 18                pop A
 042F 5300              mov [__r10],A
 0431 18                pop A
 0432 5300              mov [__r9],A
 0434 18                pop A
 0435 08                push A
 0436 5100              mov A,[__r9]
 0438 08                push A
 0439 5100              mov A,[__r10]
 043B 08                push A
 043C 5100              mov A,[__r11]
 043E 08                push A
 043F 5040              mov A,64
 0441 08                push A
 0442 5000              mov A,0
 0444 08                push A
 0445 08                push A
 0446 08                push A
 0447 7C0000            xcall __fpmul
 044A 18                pop A
 044B 5300              mov [__r11],A
 044D 18                pop A
 044E 5300              mov [__r10],A
 0450 18                pop A
 0451 5300              mov [__r9],A
 0453 18                pop A
 0454 5300              mov [__r8],A
 0456 38FC              add SP,-4
 0458 5100              mov A,[__r4]
 045A 08                push A
 045B 5100              mov A,[__r5]
 045D 08                push A
 045E 5100              mov A,[__r6]
 0460 08                push A
 0461 5100              mov A,[__r7]
 0463 08                push A
 0464 5100              mov A,[__r8]
 0466 08                push A
 0467 5100              mov A,[__r9]
 0469 08                push A
 046A 5100              mov A,[__r10]
 046C 08                push A
 046D 5100              mov A,[__r11]
 046F 08                push A
 0470 7C0000            xcall __fpadd
 0473 18                pop A
 0474 5300              mov [__r7],A
 0476 18                pop A
 0477 5300              mov [__r6],A
 0479 18                pop A
 047A 5300              mov [__r5],A
 047C 18                pop A
 047D 5300              mov [__r4],A
 047F 38FC              add SP,-4
 0481 550006            mov [__r9],<_encoder_res
 0484 550006            mov [__r8],>_encoder_res
 0487 5100              mov A,[__r8]
 0489 10                push X
 048A 5800              mov X,[__r9]
 048C 08                push A
 048D 28                romx
 048E 5300              mov [__r8],A
 0490 18                pop A
 0491 75                inc X
 0492 0900              adc A,0
 0494 08                push A
 0495 28                romx
 0496 5300              mov [__r9],A
 0498 18                pop A
 0499 75                inc X
 049A 0900              adc A,0
 049C 08                push A
 049D 28                romx
 049E 5300              mov [__r10],A
 04A0 18                pop A
 04A1 75                inc X
 04A2 0900              adc A,0
 04A4 28                romx
 04A5 5300              mov [__r11],A
 04A7 20                pop X
 04A8 5100              mov A,[__r4]
 04AA 08                push A
 04AB 5100              mov A,[__r5]
 04AD 08                push A
 04AE 5100              mov A,[__r6]
 04B0 08                push A
 04B1 5100              mov A,[__r7]
 04B3 08                push A
 04B4 5100              mov A,[__r8]
 04B6 08                push A
 04B7 5100              mov A,[__r9]
 04B9 08                push A
 04BA 5100              mov A,[__r10]
 04BC 08                push A
 04BD 5100              mov A,[__r11]
 04BF 08                push A
 04C0 7C0000            xcall __fpmul
 04C3 18                pop A
 04C4 5300              mov [__r7],A
 04C6 18                pop A
 04C7 5300              mov [__r6],A
 04C9 18                pop A
 04CA 5300              mov [__r5],A
 04CC 18                pop A
 04CD 5300              mov [__r4],A
 04CF 38FC              add SP,-4
 04D1 5100              mov A,[__r0]
 04D3 08                push A
 04D4 5100              mov A,[__r1]
 04D6 08                push A
 04D7 5100              mov A,[__r2]
 04D9 08                push A
 04DA 5100              mov A,[__r3]
 04DC 08                push A
 04DD 5100              mov A,[__r4]
 04DF 08                push A
 04E0 5100              mov A,[__r5]
 04E2 08                push A
 04E3 5100              mov A,[__r6]
 04E5 08                push A
 04E6 5100              mov A,[__r7]
 04E8 08                push A
 04E9 7C0000            xcall __fpdiv
 04EC 18                pop A
 04ED 540F              mov [X+15],A
 04EF 18                pop A
 04F0 540E              mov [X+14],A
 04F2 18                pop A
 04F3 540D              mov [X+13],A
 04F5 18                pop A
 04F6 540C              mov [X+12],A
 04F8 38FC              add SP,-4
 04FA                   .dbline 299
 04FA           ;       
 04FA           ;       return vel;     
 04FA 520C              mov A,[X+12]
 04FC 5300              mov [__r0],A
 04FE 520D              mov A,[X+13]
 0500 5300              mov [__r1],A
 0502 520E              mov A,[X+14]
 0504 5300              mov [__r2],A
 0506 520F              mov A,[X+15]
 0508 5300              mov [__r3],A
 050A                   .dbline -2
 050A           L31:
 050A 38EA              add SP,-22
 050C 20                pop X
 050D                   .dbline 0 ; func end
 050D 7F                ret
 050E                   .dbsym l initTicks 18 pl
 050E                   .dbsym l endTicks 16 pl
 050E                   .dbsym l vel 12 D
 050E                   .dbsym l ticksDone 8 l
 050E                   .dbsym l initCount 4 L
 050E                   .dbsym l diff 0 l
 050E                   .dbend
 050E                   .dbfunc e action _action fV
                        .area func_lit(rom, con, rel, proclab)
 0000           L119:
 0000 05A3              .word L43
 0002 05D8              .word L47
 0004 0637              .word L51
 0006 06D6              .word L54
 0008 0735              .word L60
 000A 0794              .word L66
 000C 07B5              .word L70
 000E 07D6              .word L74
 0010 0817              .word L80
 0012 0858              .word L86
 0014 0883              .word L90
 0016 08AE              .word L94
 0018 08DC              .word L98
 001A 0904              .word L102
 001C 092C              .word L106
 001E 0954              .word L110
                        .area text(rom, con, rel)
                ;          param -> X-6
                ;        command -> X-4
 050E           _action::
 050E                   .dbline -1
 050E 10                push X
 050F 4F                mov X,SP
 0510 3802              add SP,2
 0512                   .dbline 307
 0512           ; }
 0512           ; 
 0512           ; /* Action lookup. Takes the appropriate action for the given command and param.
 0512           ;  * command: the command read from the UART.
 0512           ;  * param: the data (if any) associated with the command.
 0512           ;  */
 0512           ; void action(char command, char* param)
 0512           ; {     
 0512                   .dbline 308
 0512           ;       if(debug)
 0512 62D000            mov REG[0xd0],>_debug
 0515 3C0000            cmp [_debug],0
 0518 A033              jz L36
 051A                   .dbline 310
 051A           ;       {
 051A           ;               UART_PutCRLF();
 051A                   .dbline 310
 051A 10                push X
 051B 7C0000            xcall _UART_PutCRLF
 051E                   .dbline 311
 051E           ;               UART_CPutString("Command: ");
 051E 508F              mov A,>L38
 0520 08                push A
 0521 508F              mov A,<L38
 0523 5C                mov X,A
 0524 18                pop A
 0525 7C0000            xcall _UART_CPutString
 0528 20                pop X
 0529                   .dbline 312
 0529           ;               UART_PutChar(command);
 0529 10                push X
 052A 52FC              mov A,[X-4]
 052C 7C0000            xcall _UART_PutChar
 052F                   .dbline 313
 052F           ;               UART_PutCRLF();
 052F 7C0000            xcall _UART_PutCRLF
 0532                   .dbline 314
 0532           ;               UART_CPutString("Param: ");
 0532 5087              mov A,>L39
 0534 08                push A
 0535 5087              mov A,<L39
 0537 5C                mov X,A
 0538 18                pop A
 0539 7C0000            xcall _UART_CPutString
 053C 20                pop X
 053D                   .dbline 315
 053D           ;               UART_PutString(param);
 053D 10                push X
 053E 52FA              mov A,[X-6]
 0540 08                push A
 0541 52FB              mov A,[X-5]
 0543 5C                mov X,A
 0544 18                pop A
 0545 7C0000            xcall _UART_PutString
 0548                   .dbline 316
 0548           ;               UART_PutCRLF();
 0548 7C0000            xcall _UART_PutCRLF
 054B 20                pop X
 054C                   .dbline 317
 054C           ;       }
 054C           L36:
 054C                   .dbline 319
 054C           ;       
 054C           ;       switch (command)
 054C 52FC              mov A,[X-4]
 054E 5401              mov [X+1],A
 0550 560000            mov [X+0],0
 0553 5201              mov A,[X+1]
 0555 1161              sub A,97
 0557 5200              mov A,[X+0]
 0559 3180              xor A,-128
 055B 1980              sbb A,(0 ^ 0x80)
 055D C41E              jc L40
 055F           X8:
 055F 5070              mov A,112
 0561 1301              sub A,[X+1]
 0563 5200              mov A,[X+0]
 0565 3180              xor A,-128
 0567 62D000            mov REG[0xd0],>__r0
 056A 5300              mov [__rX],A
 056C 5080              mov A,(0 ^ 0x80)
 056E 1A00              sbb A,[__rX]
 0570 C40B              jc L40
 0572           X9:
 0572 62D000            mov REG[0xd0],>__r0
 0575 5201              mov A,[X+1]
 0577 1161              sub A,97
 0579 5300              mov [__r1],A
 057B 5200              mov A,[X+0]
 057D 1900              sbb A,0
 057F 5300              mov [__r0],A
 0581 6500              asl [__r1]
 0583 6B00              rlc [__r0]
 0585 060000            add [__r1],<L119
 0588 0E0000            adc [__r0],>L119
 058B 5100              mov A,[__r0]
 058D 10                push X
 058E 5800              mov X,[__r1]
 0590 08                push A
 0591 28                romx
 0592 5300              mov [__r0],A
 0594 18                pop A
 0595 75                inc X
 0596 0900              adc A,0
 0598 28                romx
 0599 5300              mov [__r1],A
 059B 20                pop X
 059C 5100              mov A,[__r0]
 059E 08                push A
 059F 5100              mov A,[__r1]
 05A1 08                push A
 05A2 7F                ret
 05A3           X7:
 05A3                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 05A3                   .dbline 320
 05A3           ;       {
 05A3           L43:
 05A3                   .dbline 322
 05A3           ;               case 'a': //MAV
 05A3           ;                       if (debug)
 05A3 62D000            mov REG[0xd0],>_debug
 05A6 3C0000            cmp [_debug],0
 05A9 A3F8              jz L41
 05AB                   .dbline 324
 05AB           ;                       {
 05AB           ;                               UART_PutCRLF();
 05AB                   .dbline 324
 05AB 10                push X
 05AC 7C0000            xcall _UART_PutCRLF
 05AF                   .dbline 325
 05AF           ;                               UART_CPutString("Setting velocity to: ");
 05AF 5071              mov A,>L46
 05B1 08                push A
 05B2 5071              mov A,<L46
 05B4 5C                mov X,A
 05B5 18                pop A
 05B6 7C0000            xcall _UART_CPutString
 05B9 20                pop X
 05BA                   .dbline 326
 05BA           ;                               UART_PutSHexInt(atoi(param));
 05BA 52FA              mov A,[X-6]
 05BC 08                push A
 05BD 52FB              mov A,[X-5]
 05BF 08                push A
 05C0 7C0000            xcall _atoi
 05C3 38FE              add SP,-2
 05C5 10                push X
 05C6 62D000            mov REG[0xd0],>__r0
 05C9 5100              mov A,[__r0]
 05CB 08                push A
 05CC 5100              mov A,[__r1]
 05CE 20                pop X
 05CF 7C0000            xcall _UART_PutSHexInt
 05D2                   .dbline 327
 05D2           ;                               UART_PutCRLF();
 05D2 7C0000            xcall _UART_PutCRLF
 05D5 20                pop X
 05D6                   .dbline 328
 05D6           ;                       }
 05D6                   .dbline 330
 05D6           ;                       
 05D6           ;                       break;
 05D6 83CB              xjmp L41
 05D8           L47:
 05D8                   .dbline 332
 05D8           ;               case 'b': //MOV
 05D8           ;                       if (debug)
 05D8 62D000            mov REG[0xd0],>_debug
 05DB 3C0000            cmp [_debug],0
 05DE A02C              jz L48
 05E0                   .dbline 334
 05E0           ;                       {
 05E0           ;                               UART_PutCRLF();
 05E0                   .dbline 334
 05E0 10                push X
 05E1 7C0000            xcall _UART_PutCRLF
 05E4                   .dbline 335
 05E4           ;                               UART_CPutString("Setting PWM duty cycle to: ");
 05E4 5055              mov A,>L50
 05E6 08                push A
 05E7 5055              mov A,<L50
 05E9 5C                mov X,A
 05EA 18                pop A
 05EB 7C0000            xcall _UART_CPutString
 05EE 20                pop X
 05EF                   .dbline 336
 05EF           ;                               UART_PutSHexInt(atoi(param));
 05EF 52FA              mov A,[X-6]
 05F1 08                push A
 05F2 52FB              mov A,[X-5]
 05F4 08                push A
 05F5 7C0000            xcall _atoi
 05F8 38FE              add SP,-2
 05FA 10                push X
 05FB 62D000            mov REG[0xd0],>__r0
 05FE 5100              mov A,[__r0]
 0600 08                push A
 0601 5100              mov A,[__r1]
 0603 20                pop X
 0604 7C0000            xcall _UART_PutSHexInt
 0607                   .dbline 337
 0607           ;                               UART_PutCRLF();
 0607 7C0000            xcall _UART_PutCRLF
 060A 20                pop X
 060B                   .dbline 338
 060B           ;                       }
 060B           L48:
 060B                   .dbline 340
 060B           ;                       
 060B           ;                       PWMA_WritePulseWidth(atoi(param));
 060B 52FA              mov A,[X-6]
 060D 08                push A
 060E 52FB              mov A,[X-5]
 0610 08                push A
 0611 7C0000            xcall _atoi
 0614 38FE              add SP,-2
 0616 62D000            mov REG[0xd0],>__r0
 0619 5100              mov A,[__r1]
 061B 10                push X
 061C 7C0000            xcall _PWMA_WritePulseWidth
 061F 20                pop X
 0620                   .dbline 341
 0620           ;                       PWMB_WritePulseWidth(atoi(param));
 0620 52FA              mov A,[X-6]
 0622 08                push A
 0623 52FB              mov A,[X-5]
 0625 08                push A
 0626 7C0000            xcall _atoi
 0629 38FE              add SP,-2
 062B 62D000            mov REG[0xd0],>__r0
 062E 5100              mov A,[__r1]
 0630 10                push X
 0631 7C0000            xcall _PWMB_WritePulseWidth
 0634 20                pop X
 0635                   .dbline 342
 0635           ;                       break;
 0635 836C              xjmp L41
 0637           L51:
 0637                   .dbline 344
 0637           ;               case 'c': //GETV
 0637           ;                       *param = 0;
 0637 62D000            mov REG[0xd0],>__r0
 063A 52FB              mov A,[X-5]
 063C 5300              mov [__r1],A
 063E 52FA              mov A,[X-6]
 0640 60D5              mov REG[0xd5],A
 0642 5000              mov A,0
 0644 3F00              mvi [__r1],A
 0646                   .dbline 345
 0646           ;                       if (debug)
 0646 62D000            mov REG[0xd0],>_debug
 0649 3C0000            cmp [_debug],0
 064C A049              jz L52
 064E                   .dbline 347
 064E           ;                       {
 064E           ;                               UART_PutCRLF();
 064E                   .dbline 347
 064E 10                push X
 064F 7C0000            xcall _UART_PutCRLF
 0652 20                pop X
 0653                   .dbline 348
 0653           ;                               UART_PutString(itoa(param, getVelocity(), 10));
 0653 9BD5              xcall _getVelocity
 0655 5000              mov A,0
 0657 08                push A
 0658 500A              mov A,10
 065A 08                push A
 065B 62D000            mov REG[0xd0],>__r0
 065E 5100              mov A,[__r0]
 0660 08                push A
 0661 5100              mov A,[__r1]
 0663 08                push A
 0664 5100              mov A,[__r2]
 0666 08                push A
 0667 5100              mov A,[__r3]
 0669 08                push A
 066A 7C0000            xcall __fp2long
 066D 18                pop A
 066E 5300              mov [__r1],A
 0670 18                pop A
 0671 38FE              add SP,-2
 0673 08                push A
 0674 5100              mov A,[__r1]
 0676 08                push A
 0677 52FA              mov A,[X-6]
 0679 08                push A
 067A 52FB              mov A,[X-5]
 067C 08                push A
 067D 7C0000            xcall _itoa
 0680 38FA              add SP,-6
 0682 10                push X
 0683 62D000            mov REG[0xd0],>__r0
 0686 5100              mov A,[__r0]
 0688 08                push A
 0689 5100              mov A,[__r1]
 068B 5C                mov X,A
 068C 18                pop A
 068D 7C0000            xcall _UART_PutString
 0690                   .dbline 349
 0690           ;                               UART_PutCRLF();
 0690 7C0000            xcall _UART_PutCRLF
 0693 20                pop X
 0694                   .dbline 350
 0694           ;                       }
 0694 830D              xjmp L41
 0696           L52:
 0696                   .dbline 352
 0696           ;                       else 
 0696           ;                       {
 0696                   .dbline 353
 0696           ;                               UART_PutString(itoa(param, getVelocity(), 10));
 0696 9B92              xcall _getVelocity
 0698 5000              mov A,0
 069A 08                push A
 069B 500A              mov A,10
 069D 08                push A
 069E 62D000            mov REG[0xd0],>__r0
 06A1 5100              mov A,[__r0]
 06A3 08                push A
 06A4 5100              mov A,[__r1]
 06A6 08                push A
 06A7 5100              mov A,[__r2]
 06A9 08                push A
 06AA 5100              mov A,[__r3]
 06AC 08                push A
 06AD 7C0000            xcall __fp2long
 06B0 18                pop A
 06B1 5300              mov [__r1],A
 06B3 18                pop A
 06B4 38FE              add SP,-2
 06B6 08                push A
 06B7 5100              mov A,[__r1]
 06B9 08                push A
 06BA 52FA              mov A,[X-6]
 06BC 08                push A
 06BD 52FB              mov A,[X-5]
 06BF 08                push A
 06C0 7C0000            xcall _itoa
 06C3 38FA              add SP,-6
 06C5 10                push X
 06C6 62D000            mov REG[0xd0],>__r0
 06C9 5100              mov A,[__r0]
 06CB 08                push A
 06CC 5100              mov A,[__r1]
 06CE 5C                mov X,A
 06CF 18                pop A
 06D0 7C0000            xcall _UART_PutString
 06D3 20                pop X
 06D4                   .dbline 354
 06D4           ;                       }
 06D4                   .dbline 355
 06D4           ;                       break;
 06D4 82CD              xjmp L41
 06D6           L54:
 06D6                   .dbline 357
 06D6           ;               case 'd': //SRV0_POS
 06D6           ;                       if (debug)
 06D6 62D000            mov REG[0xd0],>_debug
 06D9 3C0000            cmp [_debug],0
 06DC A02C              jz L55
 06DE                   .dbline 359
 06DE           ;                       {
 06DE           ;                               UART_PutCRLF();
 06DE                   .dbline 359
 06DE 10                push X
 06DF 7C0000            xcall _UART_PutCRLF
 06E2                   .dbline 360
 06E2           ;                               UART_CPutString("Setting servo 0 pulse width to: ");
 06E2 5034              mov A,>L57
 06E4 08                push A
 06E5 5034              mov A,<L57
 06E7 5C                mov X,A
 06E8 18                pop A
 06E9 7C0000            xcall _UART_CPutString
 06EC 20                pop X
 06ED                   .dbline 361
 06ED           ;                               UART_PutSHexInt(atoi(param));
 06ED 52FA              mov A,[X-6]
 06EF 08                push A
 06F0 52FB              mov A,[X-5]
 06F2 08                push A
 06F3 7C0000            xcall _atoi
 06F6 38FE              add SP,-2
 06F8 10                push X
 06F9 62D000            mov REG[0xd0],>__r0
 06FC 5100              mov A,[__r0]
 06FE 08                push A
 06FF 5100              mov A,[__r1]
 0701 20                pop X
 0702 7C0000            xcall _UART_PutSHexInt
 0705                   .dbline 362
 0705           ;                               UART_PutCRLF();
 0705 7C0000            xcall _UART_PutCRLF
 0708 20                pop X
 0709                   .dbline 363
 0709           ;                       }
 0709           L55:
 0709                   .dbline 365
 0709           ;                       
 0709           ;                       if ((Servo0_CONTROL_LSB_REG & Servo0_CONTROL_REG_START_BIT) == 0x00) //servo has not been started
 0709 5D27              mov A,REG[0x27]
 070B 62D000            mov REG[0xd0],>__r0
 070E 5300              mov [__r0],A
 0710 470001            tst [__r0],1
 0713 B006              jnz L58
 0715                   .dbline 366
 0715           ;                               Servo0_Start();
 0715 10                push X
 0716 7C0000            xcall _Servo0_Start
 0719 20                pop X
 071A           L58:
 071A                   .dbline 368
 071A           ;                       
 071A           ;                       Servo0_WritePulseWidth(atoi(param));
 071A 52FA              mov A,[X-6]
 071C 08                push A
 071D 52FB              mov A,[X-5]
 071F 08                push A
 0720 7C0000            xcall _atoi
 0723 38FE              add SP,-2
 0725 10                push X
 0726 62D000            mov REG[0xd0],>__r0
 0729 5100              mov A,[__r0]
 072B 08                push A
 072C 5100              mov A,[__r1]
 072E 20                pop X
 072F 7C0000            xcall _Servo0_WritePulseWidth
 0732 20                pop X
 0733                   .dbline 369
 0733           ;                       break;
 0733 826E              xjmp L41
 0735           L60:
 0735                   .dbline 371
 0735           ;               case 'e': //SRV1_POS
 0735           ;                       if (debug)
 0735 62D000            mov REG[0xd0],>_debug
 0738 3C0000            cmp [_debug],0
 073B A02C              jz L61
 073D                   .dbline 373
 073D           ;                       {
 073D           ;                               UART_PutCRLF();
 073D                   .dbline 373
 073D 10                push X
 073E 7C0000            xcall _UART_PutCRLF
 0741                   .dbline 374
 0741           ;                               UART_CPutString("Setting servo 1 pulse width to: ");
 0741 5013              mov A,>L63
 0743 08                push A
 0744 5013              mov A,<L63
 0746 5C                mov X,A
 0747 18                pop A
 0748 7C0000            xcall _UART_CPutString
 074B 20                pop X
 074C                   .dbline 375
 074C           ;                               UART_PutSHexInt(atoi(param));
 074C 52FA              mov A,[X-6]
 074E 08                push A
 074F 52FB              mov A,[X-5]
 0751 08                push A
 0752 7C0000            xcall _atoi
 0755 38FE              add SP,-2
 0757 10                push X
 0758 62D000            mov REG[0xd0],>__r0
 075B 5100              mov A,[__r0]
 075D 08                push A
 075E 5100              mov A,[__r1]
 0760 20                pop X
 0761 7C0000            xcall _UART_PutSHexInt
 0764                   .dbline 376
 0764           ;                               UART_PutCRLF();
 0764 7C0000            xcall _UART_PutCRLF
 0767 20                pop X
 0768                   .dbline 377
 0768           ;                       }
 0768           L61:
 0768                   .dbline 379
 0768           ;                       
 0768           ;                       if ((Servo1_CONTROL_LSB_REG & Servo1_CONTROL_REG_START_BIT) == 0x00) //servo has not been started
 0768 5D4B              mov A,REG[0x4b]
 076A 62D000            mov REG[0xd0],>__r0
 076D 5300              mov [__r0],A
 076F 470001            tst [__r0],1
 0772 B006              jnz L64
 0774                   .dbline 380
 0774           ;                               Servo1_Start();
 0774 10                push X
 0775 7C0000            xcall _Servo1_Start
 0778 20                pop X
 0779           L64:
 0779                   .dbline 382
 0779           ;                       
 0779           ;                       Servo1_WritePulseWidth(atoi(param));
 0779 52FA              mov A,[X-6]
 077B 08                push A
 077C 52FB              mov A,[X-5]
 077E 08                push A
 077F 7C0000            xcall _atoi
 0782 38FE              add SP,-2
 0784 10                push X
 0785 62D000            mov REG[0xd0],>__r0
 0788 5100              mov A,[__r0]
 078A 08                push A
 078B 5100              mov A,[__r1]
 078D 20                pop X
 078E 7C0000            xcall _Servo1_WritePulseWidth
 0791 20                pop X
 0792                   .dbline 383
 0792           ;                       break;
 0792 820F              xjmp L41
 0794           L66:
 0794                   .dbline 385
 0794           ;               case 'f': //SRV0_STP
 0794           ;                       if (debug)
 0794 62D000            mov REG[0xd0],>_debug
 0797 3C0000            cmp [_debug],0
 079A A013              jz L67
 079C                   .dbline 387
 079C           ;                       {
 079C           ;                               UART_PutCRLF();
 079C                   .dbline 387
 079C 10                push X
 079D 7C0000            xcall _UART_PutCRLF
 07A0                   .dbline 388
 07A0           ;                               UART_CPutString("Stopping PWM for servo 0.");
 07A0 50F9              mov A,>L69
 07A2 08                push A
 07A3 50F9              mov A,<L69
 07A5 5C                mov X,A
 07A6 18                pop A
 07A7 7C0000            xcall _UART_CPutString
 07AA                   .dbline 389
 07AA           ;                               UART_PutCRLF();
 07AA 7C0000            xcall _UART_PutCRLF
 07AD 20                pop X
 07AE                   .dbline 390
 07AE           ;                       }
 07AE           L67:
 07AE                   .dbline 392
 07AE           ;                       
 07AE           ;                       Servo0_Stop();;
 07AE 10                push X
 07AF 7C0000            xcall _Servo0_Stop
 07B2 20                pop X
 07B3                   .dbline 392
 07B3                   .dbline 393
 07B3           ;                       break;
 07B3 81EE              xjmp L41
 07B5           L70:
 07B5                   .dbline 395
 07B5           ;               case 'g': //SRV1_STP
 07B5           ;                       if (debug)
 07B5 62D000            mov REG[0xd0],>_debug
 07B8 3C0000            cmp [_debug],0
 07BB A013              jz L71
 07BD                   .dbline 397
 07BD           ;                       {
 07BD           ;                               UART_PutCRLF();
 07BD                   .dbline 397
 07BD 10                push X
 07BE 7C0000            xcall _UART_PutCRLF
 07C1                   .dbline 398
 07C1           ;                               UART_CPutString("Stopping PWM for servo 1.");
 07C1 50DF              mov A,>L73
 07C3 08                push A
 07C4 50DF              mov A,<L73
 07C6 5C                mov X,A
 07C7 18                pop A
 07C8 7C0000            xcall _UART_CPutString
 07CB                   .dbline 399
 07CB           ;                               UART_PutCRLF();
 07CB 7C0000            xcall _UART_PutCRLF
 07CE 20                pop X
 07CF                   .dbline 400
 07CF           ;                       }
 07CF           L71:
 07CF                   .dbline 402
 07CF           ;                       
 07CF           ;                       Servo1_Stop();
 07CF 10                push X
 07D0 7C0000            xcall _Servo1_Stop
 07D3 20                pop X
 07D4                   .dbline 403
 07D4           ;                       break;
 07D4 81CD              xjmp L41
 07D6           L74:
 07D6                   .dbline 405
 07D6           ;               case 'h': //GETC1
 07D6           ;                       if (debug)
 07D6 62D000            mov REG[0xd0],>_debug
 07D9 3C0000            cmp [_debug],0
 07DC A010              jz L75
 07DE                   .dbline 407
 07DE           ;                       {
 07DE           ;                               UART_PutCRLF();
 07DE                   .dbline 407
 07DE 10                push X
 07DF 7C0000            xcall _UART_PutCRLF
 07E2                   .dbline 408
 07E2           ;                               UART_CPutString("Encoder 1 count: ");
 07E2 50CD              mov A,>L77
 07E4 08                push A
 07E5 50CD              mov A,<L77
 07E7 5C                mov X,A
 07E8 18                pop A
 07E9 7C0000            xcall _UART_CPutString
 07EC 20                pop X
 07ED                   .dbline 409
 07ED           ;                       }
 07ED           L75:
 07ED                   .dbline 411
 07ED           ;                       
 07ED           ;                       UART_PutSHexInt(count1);
 07ED 62D000            mov REG[0xd0],>_count1
 07F0 5103              mov A,[_count1+3]
 07F2 62D000            mov REG[0xd0],>__r0
 07F5 5300              mov [__r1],A
 07F7 62D000            mov REG[0xd0],>_count1
 07FA 5102              mov A,[_count1+2]
 07FC 62D000            mov REG[0xd0],>__r0
 07FF 10                push X
 0800 08                push A
 0801 5100              mov A,[__r1]
 0803 20                pop X
 0804 7C0000            xcall _UART_PutSHexInt
 0807 20                pop X
 0808                   .dbline 413
 0808           ;                       
 0808           ;                       if (debug)
 0808 62D000            mov REG[0xd0],>_debug
 080B 3C0000            cmp [_debug],0
 080E A193              jz L41
 0810                   .dbline 414
 0810           ;                               UART_PutCRLF();
 0810 10                push X
 0811 7C0000            xcall _UART_PutCRLF
 0814 20                pop X
 0815                   .dbline 415
 0815           ;                       break;
 0815 818C              xjmp L41
 0817           L80:
 0817                   .dbline 417
 0817           ;               case 'i': //GETC2
 0817           ;                       if (debug)
 0817 62D000            mov REG[0xd0],>_debug
 081A 3C0000            cmp [_debug],0
 081D A010              jz L81
 081F                   .dbline 419
 081F           ;                       {
 081F           ;                               UART_PutCRLF();
 081F                   .dbline 419
 081F 10                push X
 0820 7C0000            xcall _UART_PutCRLF
 0823                   .dbline 420
 0823           ;                               UART_CPutString("Encoder 2 count: ");
 0823 50BB              mov A,>L83
 0825 08                push A
 0826 50BB              mov A,<L83
 0828 5C                mov X,A
 0829 18                pop A
 082A 7C0000            xcall _UART_CPutString
 082D 20                pop X
 082E                   .dbline 421
 082E           ;                       }
 082E           L81:
 082E                   .dbline 422
 082E           ;                       UART_PutSHexInt(count2);
 082E 62D000            mov REG[0xd0],>_count2
 0831 5103              mov A,[_count2+3]
 0833 62D000            mov REG[0xd0],>__r0
 0836 5300              mov [__r1],A
 0838 62D000            mov REG[0xd0],>_count2
 083B 5102              mov A,[_count2+2]
 083D 62D000            mov REG[0xd0],>__r0
 0840 10                push X
 0841 08                push A
 0842 5100              mov A,[__r1]
 0844 20                pop X
 0845 7C0000            xcall _UART_PutSHexInt
 0848 20                pop X
 0849                   .dbline 424
 0849           ;                       
 0849           ;                       if(debug)
 0849 62D000            mov REG[0xd0],>_debug
 084C 3C0000            cmp [_debug],0
 084F A152              jz L41
 0851                   .dbline 425
 0851           ;                               UART_PutCRLF();
 0851 10                push X
 0852 7C0000            xcall _UART_PutCRLF
 0855 20                pop X
 0856                   .dbline 426
 0856           ;                       break;
 0856 814B              xjmp L41
 0858           L86:
 0858                   .dbline 428
 0858           ;               case 'j': //RSTC1
 0858           ;                       if(debug)
 0858 62D000            mov REG[0xd0],>_debug
 085B 3C0000            cmp [_debug],0
 085E A013              jz L87
 0860                   .dbline 430
 0860           ;                       {
 0860           ;                               UART_PutCRLF();
 0860                   .dbline 430
 0860 10                push X
 0861 7C0000            xcall _UART_PutCRLF
 0864                   .dbline 431
 0864           ;                               UART_CPutString("Resetting count1");
 0864 50AA              mov A,>L89
 0866 08                push A
 0867 50AA              mov A,<L89
 0869 5C                mov X,A
 086A 18                pop A
 086B 7C0000            xcall _UART_CPutString
 086E                   .dbline 432
 086E           ;                               UART_PutCRLF();
 086E 7C0000            xcall _UART_PutCRLF
 0871 20                pop X
 0872                   .dbline 433
 0872           ;                       }
 0872           L87:
 0872                   .dbline 435
 0872           ;                       
 0872           ;                       count1 = 0;
 0872 62D000            mov REG[0xd0],>_count1
 0875 550000            mov [_count1],0
 0878 550100            mov [_count1+1],0
 087B 550200            mov [_count1+2],0
 087E 550300            mov [_count1+3],0
 0881                   .dbline 436
 0881           ;                       break;
 0881 8120              xjmp L41
 0883           L90:
 0883                   .dbline 438
 0883           ;               case 'k': //RSTC2
 0883           ;                       if(debug)
 0883 62D000            mov REG[0xd0],>_debug
 0886 3C0000            cmp [_debug],0
 0889 A013              jz L91
 088B                   .dbline 440
 088B           ;                       {
 088B           ;                               UART_PutCRLF();
 088B                   .dbline 440
 088B 10                push X
 088C 7C0000            xcall _UART_PutCRLF
 088F                   .dbline 441
 088F           ;                               UART_CPutString("Resetting count2");
 088F 5099              mov A,>L93
 0891 08                push A
 0892 5099              mov A,<L93
 0894 5C                mov X,A
 0895 18                pop A
 0896 7C0000            xcall _UART_CPutString
 0899                   .dbline 442
 0899           ;                               UART_PutCRLF();
 0899 7C0000            xcall _UART_PutCRLF
 089C 20                pop X
 089D                   .dbline 443
 089D           ;                       }
 089D           L91:
 089D                   .dbline 445
 089D           ;                       
 089D           ;                       count2 = 0;
 089D 62D000            mov REG[0xd0],>_count2
 08A0 550000            mov [_count2],0
 08A3 550100            mov [_count2+1],0
 08A6 550200            mov [_count2+2],0
 08A9 550300            mov [_count2+3],0
 08AC                   .dbline 446
 08AC           ;                       break;
 08AC 80F5              xjmp L41
 08AE           L94:
 08AE                   .dbline 448
 08AE           ;               case 'l': //STOP
 08AE           ;                       if(debug)
 08AE 62D000            mov REG[0xd0],>_debug
 08B1 3C0000            cmp [_debug],0
 08B4 A013              jz L95
 08B6                   .dbline 450
 08B6           ;                       {
 08B6           ;                               UART_PutCRLF();
 08B6                   .dbline 450
 08B6 10                push X
 08B7 7C0000            xcall _UART_PutCRLF
 08BA                   .dbline 451
 08BA           ;                               UART_CPutString("Stopping motors");
 08BA 5089              mov A,>L97
 08BC 08                push A
 08BD 5089              mov A,<L97
 08BF 5C                mov X,A
 08C0 18                pop A
 08C1 7C0000            xcall _UART_CPutString
 08C4                   .dbline 452
 08C4           ;                               UART_PutCRLF();
 08C4 7C0000            xcall _UART_PutCRLF
 08C7 20                pop X
 08C8                   .dbline 453
 08C8           ;                       }
 08C8           L95:
 08C8                   .dbline 455
 08C8           ;                       
 08C8           ;                       PWMA_WritePulseWidth(0);
 08C8 10                push X
 08C9 5000              mov A,0
 08CB 7C0000            xcall _PWMA_WritePulseWidth
 08CE                   .dbline 456
 08CE           ;                       PWMB_WritePulseWidth(0);
 08CE 5000              mov A,0
 08D0 7C0000            xcall _PWMB_WritePulseWidth
 08D3                   .dbline 457
 08D3           ;                       PWMA_Stop();
 08D3 7C0000            xcall _PWMA_Stop
 08D6                   .dbline 458
 08D6           ;                       PWMB_Stop();
 08D6 7C0000            xcall _PWMB_Stop
 08D9 20                pop X
 08DA                   .dbline 459
 08DA           ;                       break;
 08DA 80C7              xjmp L41
 08DC           L98:
 08DC                   .dbline 461
 08DC           ;               case 'm': //FORWARD
 08DC           ;                       if (debug)
 08DC 62D000            mov REG[0xd0],>_debug
 08DF 3C0000            cmp [_debug],0
 08E2 A013              jz L99
 08E4                   .dbline 463
 08E4           ;                       {
 08E4           ;                               UART_PutCRLF();
 08E4                   .dbline 463
 08E4 10                push X
 08E5 7C0000            xcall _UART_PutCRLF
 08E8                   .dbline 464
 08E8           ;                               UART_CPutString("Setting drive mode to forward.");
 08E8 506A              mov A,>L101
 08EA 08                push A
 08EB 506A              mov A,<L101
 08ED 5C                mov X,A
 08EE 18                pop A
 08EF 7C0000            xcall _UART_CPutString
 08F2                   .dbline 465
 08F2           ;                               UART_PutCRLF();
 08F2 7C0000            xcall _UART_PutCRLF
 08F5 20                pop X
 08F6                   .dbline 466
 08F6           ;                       }
 08F6           L99:
 08F6                   .dbline 468
 08F6           ;                       
 08F6           ;                       AIN1_Data_ADDR |= AIN1_MASK;
 08F6 430410            or REG[0x4],16
 08F9                   .dbline 469
 08F9           ;                       AIN2_Data_ADDR |= AIN2_MASK;
 08F9 430440            or REG[0x4],64
 08FC                   .dbline 470
 08FC           ;                       BIN1_Data_ADDR &= ~BIN1_MASK;
 08FC 4108FD            and REG[0x8],-3
 08FF                   .dbline 471
 08FF           ;                       BIN2_Data_ADDR &= ~BIN2_MASK;
 08FF 41047F            and REG[0x4],127
 0902                   .dbline 472
 0902           ;                       break;
 0902 809F              xjmp L41
 0904           L102:
 0904                   .dbline 474
 0904           ;               case 'n': //BACKWARD
 0904           ;                       if (debug)
 0904 62D000            mov REG[0xd0],>_debug
 0907 3C0000            cmp [_debug],0
 090A A013              jz L103
 090C                   .dbline 476
 090C           ;                       {
 090C           ;                               UART_PutCRLF();
 090C                   .dbline 476
 090C 10                push X
 090D 7C0000            xcall _UART_PutCRLF
 0910                   .dbline 477
 0910           ;                               UART_CPutString("Setting drive mode to backward.");
 0910 504A              mov A,>L105
 0912 08                push A
 0913 504A              mov A,<L105
 0915 5C                mov X,A
 0916 18                pop A
 0917 7C0000            xcall _UART_CPutString
 091A                   .dbline 478
 091A           ;                               UART_PutCRLF();
 091A 7C0000            xcall _UART_PutCRLF
 091D 20                pop X
 091E                   .dbline 479
 091E           ;                       }
 091E           L103:
 091E                   .dbline 481
 091E           ;                       
 091E           ;                       AIN1_Data_ADDR &= ~AIN1_MASK;
 091E 4104EF            and REG[0x4],-17
 0921                   .dbline 482
 0921           ;                       AIN2_Data_ADDR &= ~AIN2_MASK;
 0921 4104BF            and REG[0x4],-65
 0924                   .dbline 483
 0924           ;                       BIN1_Data_ADDR |= BIN1_MASK;
 0924 430802            or REG[0x8],2
 0927                   .dbline 484
 0927           ;                       BIN2_Data_ADDR |= BIN2_MASK;
 0927 430480            or REG[0x4],-128
 092A                   .dbline 485
 092A           ;                       break;
 092A 8077              xjmp L41
 092C           L106:
 092C                   .dbline 487
 092C           ;               case 'o': //TURNL
 092C           ;                       if (debug)
 092C 62D000            mov REG[0xd0],>_debug
 092F 3C0000            cmp [_debug],0
 0932 A013              jz L107
 0934                   .dbline 489
 0934           ;                       {
 0934           ;                               UART_PutCRLF();
 0934                   .dbline 489
 0934 10                push X
 0935 7C0000            xcall _UART_PutCRLF
 0938                   .dbline 490
 0938           ;                               UART_CPutString("Setting drive mode to left.");
 0938 502E              mov A,>L109
 093A 08                push A
 093B 502E              mov A,<L109
 093D 5C                mov X,A
 093E 18                pop A
 093F 7C0000            xcall _UART_CPutString
 0942                   .dbline 491
 0942           ;                               UART_PutCRLF();
 0942 7C0000            xcall _UART_PutCRLF
 0945 20                pop X
 0946                   .dbline 492
 0946           ;                       }
 0946           L107:
 0946                   .dbline 494
 0946           ;                       
 0946           ;                       AIN1_Data_ADDR |= AIN1_MASK;
 0946 430410            or REG[0x4],16
 0949                   .dbline 495
 0949           ;                       AIN2_Data_ADDR &= ~AIN2_MASK;
 0949 4104BF            and REG[0x4],-65
 094C                   .dbline 496
 094C           ;                       BIN1_Data_ADDR &= ~BIN1_MASK;
 094C 4108FD            and REG[0x8],-3
 094F                   .dbline 497
 094F           ;                       BIN2_Data_ADDR |= BIN2_MASK;
 094F 430480            or REG[0x4],-128
 0952                   .dbline 498
 0952           ;                       break;
 0952 804F              xjmp L41
 0954           L110:
 0954                   .dbline 500
 0954           ;               case 'p': //TURNR
 0954           ;                       if (debug)
 0954 62D000            mov REG[0xd0],>_debug
 0957 3C0000            cmp [_debug],0
 095A A013              jz L111
 095C                   .dbline 502
 095C           ;                       {
 095C           ;                               UART_PutCRLF();
 095C                   .dbline 502
 095C 10                push X
 095D 7C0000            xcall _UART_PutCRLF
 0960                   .dbline 503
 0960           ;                               UART_CPutString("Setting drive mode to right.");
 0960 5011              mov A,>L113
 0962 08                push A
 0963 5011              mov A,<L113
 0965 5C                mov X,A
 0966 18                pop A
 0967 7C0000            xcall _UART_CPutString
 096A                   .dbline 504
 096A           ;                               UART_PutCRLF();
 096A 7C0000            xcall _UART_PutCRLF
 096D 20                pop X
 096E                   .dbline 505
 096E           ;                       }
 096E           L111:
 096E                   .dbline 507
 096E           ;                       
 096E           ;                       AIN1_Data_ADDR &= ~AIN1_MASK;
 096E 4104EF            and REG[0x4],-17
 0971                   .dbline 508
 0971           ;                       AIN2_Data_ADDR |= AIN2_MASK;
 0971 430440            or REG[0x4],64
 0974                   .dbline 509
 0974           ;                       BIN1_Data_ADDR |= BIN1_MASK;
 0974 430802            or REG[0x8],2
 0977                   .dbline 510
 0977           ;                       BIN2_Data_ADDR &= ~BIN2_MASK;
 0977 41047F            and REG[0x4],127
 097A                   .dbline 511
 097A           ;                       break;
 097A 8027              xjmp L41
 097C           L40:
 097C                   .dbline 513
 097C           ;               default : //ERROR
 097C           ;                       if (debug)
 097C 62D000            mov REG[0xd0],>_debug
 097F 3C0000            cmp [_debug],0
 0982 A006              jz L114
 0984                   .dbline 514
 0984           ;                               UART_PutCRLF();
 0984 10                push X
 0985 7C0000            xcall _UART_PutCRLF
 0988 20                pop X
 0989           L114:
 0989                   .dbline 516
 0989           ;                       
 0989           ;                       UART_CPutString("fu1337"); //error code
 0989 10                push X
 098A 500A              mov A,>L116
 098C 08                push A
 098D 500A              mov A,<L116
 098F 5C                mov X,A
 0990 18                pop A
 0991 7C0000            xcall _UART_CPutString
 0994 20                pop X
 0995                   .dbline 518
 0995           ;                       
 0995           ;                       if (debug)
 0995 62D000            mov REG[0xd0],>_debug
 0998 3C0000            cmp [_debug],0
 099B A006              jz L41
 099D                   .dbline 519
 099D           ;                               UART_PutCRLF();
 099D 10                push X
 099E 7C0000            xcall _UART_PutCRLF
 09A1 20                pop X
 09A2                   .dbline 520
 09A2           ;                       break;
 09A2           L41:
 09A2                   .dbline -2
 09A2           L35:
 09A2 38FE              add SP,-2
 09A4 20                pop X
 09A5                   .dbline 0 ; func end
 09A5 7F                ret
 09A6                   .dbsym l param -6 pc
 09A6                   .dbsym l command -4 c
 09A6                   .dbend
 09A6                   .dbfunc e encoder1_ISR _encoder1_ISR fV
 09A6           _encoder1_ISR::
 09A6                   .dbline -1
 09A6 71C0              or F,-64
 09A8 08                push A
 09A9 5DD0              mov A,REG[0xd0]
 09AB 08                push A
 09AC                   .dbline 526
 09AC           ;       }
 09AC           ; }
 09AC           ; 
 09AC           ; //Encoder 1 interrupts are generated by the falling edge and positive edge paramers.
 09AC           ; void encoder1_ISR(void)
 09AC           ; {
 09AC                   .dbline 528
 09AC           ;       //grab the new state of the encoder register.
 09AC           ;       curPrt1 = (ENC1A_Data_ADDR & (ENC1A_MASK | ENC1B_MASK));
 09AC 5D08              mov A,REG[0x8]
 09AE 2150              and A,80
 09B0 62D000            mov REG[0xd0],>_curPrt1
 09B3 5300              mov [_curPrt1],A
 09B5                   .dbline 531
 09B5           ;               
 09B5           ;       //check which state transitioned.
 09B5           ;       if ((prevPrt1 == 0x00) && (curPrt1 == stateA1)) //A low to high
 09B5 62D000            mov REG[0xd0],>_prevPrt1
 09B8 3C0000            cmp [_prevPrt1],0
 09BB B01A              jnz L121
 09BD 62D000            mov REG[0xd0],>_curPrt1
 09C0 3C0020            cmp [_curPrt1],32
 09C3 B012              jnz L121
 09C5                   .dbline 533
 09C5           ;       {
 09C5           ;               count1++;
 09C5                   .dbline 533
 09C5 62D000            mov REG[0xd0],>_count1
 09C8 060301            add [_count1+3],1
 09CB 0E0200            adc [_count1+2],0
 09CE 0E0100            adc [_count1+1],0
 09D1 0E0000            adc [_count1],0
 09D4                   .dbline 534
 09D4           ;       }
 09D4 8020              xjmp L122
 09D6           L121:
 09D6                   .dbline 535
 09D6           ;       else if ((prevPrt1 == 0x00) && (curPrt1 == stateB1)) //B low to high
 09D6 62D000            mov REG[0xd0],>_prevPrt1
 09D9 3C0000            cmp [_prevPrt1],0
 09DC B018              jnz L123
 09DE 62D000            mov REG[0xd0],>_curPrt1
 09E1 3C0008            cmp [_curPrt1],8
 09E4 B010              jnz L123
 09E6                   .dbline 537
 09E6           ;       {
 09E6           ;               count1--;
 09E6                   .dbline 537
 09E6 62D000            mov REG[0xd0],>_count1
 09E9 160301            sub [_count1+3],1
 09EC 1E0200            sbb [_count1+2],0
 09EF 1E0100            sbb [_count1+1],0
 09F2 1E0000            sbb [_count1],0
 09F5                   .dbline 538
 09F5           ;       }
 09F5           L123:
 09F5           L122:
 09F5                   .dbline -2
 09F5           L120:
 09F5 18                pop A
 09F6 60D0              mov REG[208],A
 09F8 18                pop A
 09F9                   .dbline 0 ; func end
 09F9 7E                reti
 09FA                   .dbend
 09FA                   .dbfunc e encoder2_ISR _encoder2_ISR fV
 09FA           _encoder2_ISR::
 09FA                   .dbline -1
 09FA 71C0              or F,-64
 09FC 08                push A
 09FD 5DD0              mov A,REG[0xd0]
 09FF 08                push A
 0A00                   .dbline 544
 0A00           ; }
 0A00           ; 
 0A00           ; //Encoder 2 interrupts are generated directly by the GPIO interrupt. Logically equivalent
 0A00           ; //to the encoder1_ISR
 0A00           ; void encoder2_ISR(void)
 0A00           ; {
 0A00                   .dbline 545
 0A00           ;       curPrt2 = (ENC2A_Data_ADDR & (ENC2A_MASK | ENC2B_MASK));        
 0A00 5D08              mov A,REG[0x8]
 0A02 2128              and A,40
 0A04 62D000            mov REG[0xd0],>_curPrt2
 0A07 5300              mov [_curPrt2],A
 0A09                   .dbline 547
 0A09           ;               
 0A09           ;       if ((prevPrt2 == 0x00) && (curPrt2 == stateA2)) 
 0A09 62D000            mov REG[0xd0],>_prevPrt2
 0A0C 3C0000            cmp [_prevPrt2],0
 0A0F B01A              jnz L126
 0A11 62D000            mov REG[0xd0],>_curPrt2
 0A14 3C0010            cmp [_curPrt2],16
 0A17 B012              jnz L126
 0A19                   .dbline 549
 0A19           ;       {
 0A19           ;               count2++;
 0A19                   .dbline 549
 0A19 62D000            mov REG[0xd0],>_count2
 0A1C 060301            add [_count2+3],1
 0A1F 0E0200            adc [_count2+2],0
 0A22 0E0100            adc [_count2+1],0
 0A25 0E0000            adc [_count2],0
 0A28                   .dbline 550
 0A28           ;       }
 0A28 8020              xjmp L127
 0A2A           L126:
 0A2A                   .dbline 551
 0A2A           ;       else if ((prevPrt2 == 0x00) && (curPrt2 == stateB2))
 0A2A 62D000            mov REG[0xd0],>_prevPrt2
 0A2D 3C0000            cmp [_prevPrt2],0
 0A30 B018              jnz L128
 0A32 62D000            mov REG[0xd0],>_curPrt2
 0A35 3C0004            cmp [_curPrt2],4
 0A38 B010              jnz L128
 0A3A                   .dbline 553
 0A3A           ;       {
 0A3A           ;               count2--;
 0A3A                   .dbline 553
 0A3A 62D000            mov REG[0xd0],>_count2
 0A3D 160301            sub [_count2+3],1
 0A40 1E0200            sbb [_count2+2],0
 0A43 1E0100            sbb [_count2+1],0
 0A46 1E0000            sbb [_count2],0
 0A49                   .dbline 554
 0A49           ;       }
 0A49           L128:
 0A49           L127:
 0A49                   .dbline -2
 0A49           L125:
 0A49 18                pop A
 0A4A 60D0              mov REG[208],A
 0A4C 18                pop A
 0A4D                   .dbline 0 ; func end
 0A4D 7E                reti
 0A4E                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _prevPrt2::
 0000 00                .byte 0
 0001                   .dbsym e prevPrt2 _prevPrt2 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _curPrt2::
 0000 00                .byte 0
 0001                   .dbsym e curPrt2 _curPrt2 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _prevPrt1::
 0000 00                .byte 0
 0001                   .dbsym e prevPrt1 _prevPrt1 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _curPrt1::
 0000 00                .byte 0
 0001                   .dbsym e curPrt1 _curPrt1 c
                        .area lit(rom, con, rel, lit)
 000A           L116:
 000A 66753133333700    .byte 'f,'u,49,51,51,55,0
 0011           L113:
 0011 53657474696E67206472697665206D6F  .byte 'S,'e,'t,'t,'i,'n,'g,32,'d,'r,'i,'v,'e,32,'m,'o
 0021 646520746F2072696768742E00        .byte 'd,'e,32,'t,'o,32,'r,'i,'g,'h,'t,46,0
 002E           L109:
 002E 53657474696E67206472697665206D6F  .byte 'S,'e,'t,'t,'i,'n,'g,32,'d,'r,'i,'v,'e,32,'m,'o
 003E 646520746F206C6566742E00  .byte 'd,'e,32,'t,'o,32,'l,'e,'f,'t,46,0
 004A           L105:
 004A 53657474696E67206472697665206D6F  .byte 'S,'e,'t,'t,'i,'n,'g,32,'d,'r,'i,'v,'e,32,'m,'o
 005A 646520746F206261636B776172642E00  .byte 'd,'e,32,'t,'o,32,'b,'a,'c,'k,'w,'a,'r,'d,46,0
 006A           L101:
 006A 53657474696E67206472697665206D6F  .byte 'S,'e,'t,'t,'i,'n,'g,32,'d,'r,'i,'v,'e,32,'m,'o
 007A 646520746F20666F72776172642E00    .byte 'd,'e,32,'t,'o,32,'f,'o,'r,'w,'a,'r,'d,46,0
 0089           L97:
 0089 53746F7070696E67206D6F746F727300  .byte 'S,'t,'o,'p,'p,'i,'n,'g,32,'m,'o,'t,'o,'r,'s,0
 0099           L93:
 0099 526573657474696E6720636F756E7432  .byte 'R,'e,'s,'e,'t,'t,'i,'n,'g,32,'c,'o,'u,'n,'t,50
 00A9 00                .byte 0
 00AA           L89:
 00AA 526573657474696E6720636F756E7431  .byte 'R,'e,'s,'e,'t,'t,'i,'n,'g,32,'c,'o,'u,'n,'t,49
 00BA 00                .byte 0
 00BB           L83:
 00BB 456E636F646572203220636F756E743A  .byte 'E,'n,'c,'o,'d,'e,'r,32,50,32,'c,'o,'u,'n,'t,58
 00CB 2000              .byte 32,0
 00CD           L77:
 00CD 456E636F646572203120636F756E743A  .byte 'E,'n,'c,'o,'d,'e,'r,32,49,32,'c,'o,'u,'n,'t,58
 00DD 2000              .byte 32,0
 00DF           L73:
 00DF 53746F7070696E672050574D20666F72  .byte 'S,'t,'o,'p,'p,'i,'n,'g,32,'P,'W,'M,32,'f,'o,'r
 00EF 20736572766F20312E00      .byte 32,'s,'e,'r,'v,'o,32,49,46,0
 00F9           L69:
 00F9 53746F7070696E672050574D20666F72  .byte 'S,'t,'o,'p,'p,'i,'n,'g,32,'P,'W,'M,32,'f,'o,'r
 0109 20736572766F20302E00      .byte 32,'s,'e,'r,'v,'o,32,48,46,0
 0113           L63:
 0113 53657474696E6720736572766F203120  .byte 'S,'e,'t,'t,'i,'n,'g,32,'s,'e,'r,'v,'o,32,49,32
 0123 70756C736520776964746820746F3A20  .byte 'p,'u,'l,'s,'e,32,'w,'i,'d,'t,'h,32,'t,'o,58,32
 0133 00                .byte 0
 0134           L57:
 0134 53657474696E6720736572766F203020  .byte 'S,'e,'t,'t,'i,'n,'g,32,'s,'e,'r,'v,'o,32,48,32
 0144 70756C736520776964746820746F3A20  .byte 'p,'u,'l,'s,'e,32,'w,'i,'d,'t,'h,32,'t,'o,58,32
 0154 00                .byte 0
 0155           L50:
 0155 53657474696E672050574D2064757479  .byte 'S,'e,'t,'t,'i,'n,'g,32,'P,'W,'M,32,'d,'u,'t,'y
 0165 206379636C6520746F3A2000  .byte 32,'c,'y,'c,'l,'e,32,'t,'o,58,32,0
 0171           L46:
 0171 53657474696E672076656C6F63697479  .byte 'S,'e,'t,'t,'i,'n,'g,32,'v,'e,'l,'o,'c,'i,'t,'y
 0181 20746F3A2000      .byte 32,'t,'o,58,32,0
 0187           L39:
 0187 506172616D3A2000  .byte 'P,'a,'r,'a,'m,58,32,0
 018F           L38:
 018F 436F6D6D616E643A2000      .byte 'C,'o,'m,'m,'a,'n,'d,58,32,0
 0199           L16:
 0199 4B49505220626F747320726F6C6C206F  .byte 'K,'I,'P,'R,32,'b,'o,'t,'s,32,'r,'o,'l,'l,32,'o
 01A9 75742100          .byte 'u,'t,33,0
