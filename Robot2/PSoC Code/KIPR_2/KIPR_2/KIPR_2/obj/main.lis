 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area lit(rom, con, rel, lit)
 0000           _debug_mask::
 0000 0C                .byte 12
 0001                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0001                   .dbsym e debug_mask _debug_mask kc
 0001           _TERM::
 0001 07                .byte 7
 0002                   .dbsym e TERM _TERM kc
 0002           _tick_time::
 0002 32B2F4FC          .word 0x32b2,0xf4fc
 0006                   .dbsym e tick_time _tick_time kD
 0006           _encoder_res::
 0006 3D124925          .word 0x3d12,0x4925
 000A                   .dbsym e encoder_res _encoder_res kD
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _command_flag::
 0000 00                .byte 0
 0001                   .dbsym e command_flag _command_flag c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _debug::
 0000 00                .byte 0
 0001                   .dbsym e debug _debug c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _i::
 0000 0000              .word 0
 0002                   .dbsym e i _i I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _count1::
 0000 00000000          .word 0,0
 0004                   .dbsym e count1 _count1 L
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _count2::
 0000 00000000          .word 0,0
 0004                   .dbsym e count2 _count2 L
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
                        .area text(rom, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000                   .dbfunc e main _main fV
 0000           ;          param -> X+2
 0000           ;        command -> X+1
 0000           ;           data -> X+0
 0000           _main::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3804              add SP,4
 0004                   .dbline 129
 0004           ; /**
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Table of commands^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; 
 0004           ; MAV                   'a' //Move at velocity
 0004           ; MOV                   'b' //move at duty cycle
 0004           ; GETV                  'c' //get velocity
 0004           ; SRV0_POS              'd' //set servo positions for servo 0 (starts PWM)
 0004           ; SRV1_POS              'e' //set servo positions for servo 1 (starts PWM)
 0004           ; SRV0_STP              'f' //Turns a servo 0 off (stops PWM)
 0004           ; SRV1_STP              'g' //Turns a servo 1 off (stops PWM)
 0004           ; GETC1                 'h' //get encoder1 count
 0004           ; GETC2                 'i' //get encoder2 count
 0004           ; RSTC1                 'j' //reset encoder1 count
 0004           ; RSTC2                 'k' //reset encoder2 count
 0004           ; STOP                  'l' //stop motors
 0004           ; FORWARD                       'm' //sets drive mode to forward
 0004           ; BACKWARD              'n' //sets drive mode to backward
 0004           ; TURNL                 'o' //sets drive mode to left turn
 0004           ; TURNR                 'p' //sets drive mode to right turn
 0004           ; 
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Serial Limitations^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; 
 0004           ; Baude rate                    115200
 0004           ; RX Buffer size                16 bytes
 0004           ; 
 0004           ; UART RX                       P2[7]
 0004           ; UART TX                               P0[1]
 0004           ; 
 0004           ; * Theoretically 115200 bytes can be sent in one second, at minimum, and 115216 at maximum before buffer overflow.
 0004           ; 
 0004           ; * All UART commands have either one or zero parameters. All commands must be terminated with an ACII BEL (0x07).
 0004           ;   Command parameters may be space delimited from the command or can be sent as just a single string. 
 0004           ; 
 0004           ; Examples:
 0004           ; 
 0004           ; "a25" - move at velcoity 25 RPM.
 0004           ; "a 25" - move at velocity 25 RPM
 0004           ; 
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Servo Information^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; 
 0004           ; Servo0                P0[3] (MISC0)
 0004           ; Servo1                P0[7] (MISC2)
 0004           ; 
 0004           ; 16 bit resoltion for each. Every tick = 1 us.
 0004           ; 
 0004           ; Servo accepts PWM range from ~700 us to ~2200 us for a 180* servo.
 0004           ; 
 0004           ; RPi will convert servo angle to pulse width and send to PSoC. Then the servo angle will be set by writing the
 0004           ; Pulse width to the PWM register.
 0004           ; 
 0004           ; **NOTE**
 0004           ; Higer resolution can be achieved by using a faster clock and allowing for more ticks but 1 Mhz clock 1 us tick
 0004           ; makes calculations a little easier.
 0004           ; 
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Drive Modes^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; 
 0004           ; The motor driver must be configured for each of our drive modes. The drive modes are defined as follows:
 0004           ; 
 0004           ; INPUT         1A              1B              2A              2B
 0004           ; =======================================
 0004           ; Forward               1               0               1               0
 0004           ; Backward      0               1               0               1
 0004           ; Left          1               0               0               1
 0004           ; Right         0               1               1               0
 0004           ; 
 0004           ; In general for one motor
 0004           ; 
 0004           ; INPUT         A               B
 0004           ; ======================
 0004           ; Drift         1               1       (causes robot to coast)
 0004           ; CCW                   0               1
 0004           ; CW                    1               0
 0004           ; Stop          0               0
 0004           ; 
 0004           ; If STDBY is asserted (ie. pulled LOW) then all modes are treated as STOP.
 0004           ; 
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Debug Mode^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 0004           ; 
 0004           ; A debug mode is provided for getting serial print statements to indicate useful data when passing commands
 0004           ; to the PSoC. To enable this mode assert MISC7 and MISC8 as high at power on. (ie, connect MISC7 and MISC8
 0004           ; to VCC before powering on).
 0004           ; 
 0004           ; After the init() function is called their states will be read and a flag will be set according to those states.
 0004           ; If debug mode is not desired merely leave those pins floating.
 0004           ; 
 0004           ; MISC7         P1[2]
 0004           ; MISC8         P1[3]
 0004           ; 
 0004           ; */
 0004           ; 
 0004           ; #include <stdlib.h>
 0004           ; #include <m8c.h>        // part specific constants and macros
 0004           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0004           ; 
 0004           ; #pragma interrupt_handler encoder1_ISR
 0004           ; #pragma interrupt_handler encoder2_ISR
 0004           ; 
 0004           ; #define       stateA1                 0x20
 0004           ; #define       stateB1                 0x08
 0004           ; #define       stateA2                 0x10
 0004           ; #define       stateB2                 0x04
 0004           ; 
 0004           ; const BYTE    debug_mask      =       MISC7_MASK | MISC8_MASK;
 0004           ; const char    TERM            =       0x07;
 0004           ; 
 0004           ; BOOL command_flag             =       FALSE;
 0004           ; BOOL debug                            =       FALSE;
 0004           ; 
 0004           ; int i = 0; //loop var
 0004           ; 
 0004           ; BYTE curPrt1;
 0004           ; BYTE prevPrt1;
 0004           ; BYTE curPrt2;
 0004           ; BYTE prevPrt2;
 0004           ; 
 0004           ; signed long int count1 = 0;
 0004           ; signed long int count2 = 0;
 0004           ; 
 0004           ; void init(void);
 0004           ; void action(char command, char* param);
 0004           ; int getVelocity(void);
 0004           ; 
 0004           ; void main(void)
 0004           ; {
 0004                   .dbline 134
 0004           ;       char command;
 0004           ;       char* param;
 0004           ;       char data;
 0004           ;       
 0004           ;       init();
 0004 90D7              xcall _init
 0006 80CF              xjmp L3
 0008           L2:
 0008                   .dbline 137
 0008           ;       
 0008           ;       while(1)
 0008           ;       {
 0008                   .dbline 139
 0008           ;               //read the state of encoders. this will be needed if we interrupt.
 0008           ;               prevPrt1 = (ENC1A_Data_ADDR & (ENC1A_MASK | ENC1B_MASK));
 0008 5D08              mov A,REG[0x8]
 000A 2150              and A,80
 000C 62D000            mov REG[0xd0],>_prevPrt1
 000F 5300              mov [_prevPrt1],A
 0011                   .dbline 140
 0011           ;               prevPrt2 = (ENC2A_Data_ADDR & (ENC2A_MASK | ENC2B_MASK));
 0011 5D08              mov A,REG[0x8]
 0013 2128              and A,40
 0015 62D000            mov REG[0xd0],>_prevPrt2
 0018 5300              mov [_prevPrt2],A
 001A                   .dbline 142
 001A           ;               
 001A           ;               data = UART_cReadChar(); //check for data
 001A 10                push X
 001B 7C0000            xcall _UART_cReadChar
 001E 20                pop X
 001F 5400              mov [X+0],A
 0021                   .dbline 144
 0021           ;               
 0021           ;               if (!command_flag && data) //no command has been read and data is valid (not null)
 0021 62D000            mov REG[0xd0],>_command_flag
 0024 3C0000            cmp [_command_flag],0
 0027 B022              jnz L5
 0029 3D0000            cmp [X+0],0
 002C A01D              jz L5
 002E                   .dbline 146
 002E           ;               {
 002E           ;                       if (debug)
 002E                   .dbline 146
 002E 62D000            mov REG[0xd0],>_debug
 0031 3C0000            cmp [_debug],0
 0034 A008              jz L7
 0036                   .dbline 147
 0036           ;                               UART_PutChar(data);
 0036 10                push X
 0037 5200              mov A,[X+0]
 0039 7C0000            xcall _UART_PutChar
 003C 20                pop X
 003D           L7:
 003D                   .dbline 149
 003D           ;                       
 003D           ;                       command_flag = TRUE;
 003D 62D000            mov REG[0xd0],>_command_flag
 0040 550001            mov [_command_flag],1
 0043                   .dbline 150
 0043           ;                       command = data;
 0043 5200              mov A,[X+0]
 0045 5401              mov [X+1],A
 0047                   .dbline 151
 0047           ;                       data = '\0';
 0047 560000            mov [X+0],0
 004A                   .dbline 152
 004A           ;               }
 004A           L5:
 004A                   .dbline 153
 004A           ;               if (data && command_flag)//command byte read and data is valid (not null)
 004A 3D0000            cmp [X+0],0
 004D A088              jz L9
 004F 62D000            mov REG[0xd0],>_command_flag
 0052 3C0000            cmp [_command_flag],0
 0055 A080              jz L9
 0057                   .dbline 155
 0057           ;               {
 0057           ;                       if (data == TERM) //command terminator read
 0057                   .dbline 155
 0057 62D000            mov REG[0xd0],>__r0
 005A 5001              mov A,>_TERM
 005C 10                push X
 005D 5701              mov X,<_TERM
 005F 28                romx
 0060 20                pop X
 0061 5300              mov [__r0],A
 0063 5200              mov A,[X+0]
 0065 3A00              cmp A,[__r0]
 0067 B03B              jnz L11
 0069                   .dbline 157
 0069           ;                       {
 0069           ;                               command_flag = FALSE;
 0069                   .dbline 157
 0069 62D000            mov REG[0xd0],>_command_flag
 006C 550000            mov [_command_flag],0
 006F                   .dbline 158
 006F           ;                               param[i] = '\0'; //null terminate parameter string
 006F 62D000            mov REG[0xd0],>_i
 0072 5101              mov A,[_i+1]
 0074 0303              add A,[X+3]
 0076 62D000            mov REG[0xd0],>__r0
 0079 5300              mov [__r1],A
 007B 62D000            mov REG[0xd0],>_i
 007E 5100              mov A,[_i]
 0080 0B02              adc A,[X+2]
 0082 62D000            mov REG[0xd0],>__r0
 0085 60D5              mov REG[0xd5],A
 0087 5000              mov A,0
 0089 3F00              mvi [__r1],A
 008B                   .dbline 159
 008B           ;                               action(command, param);
 008B 5202              mov A,[X+2]
 008D 08                push A
 008E 5203              mov A,[X+3]
 0090 08                push A
 0091 5201              mov A,[X+1]
 0093 08                push A
 0094 912E              xcall _action
 0096 38FD              add SP,-3
 0098                   .dbline 160
 0098           ;                               i = 0; //reset counter
 0098 62D000            mov REG[0xd0],>_i
 009B 550100            mov [_i+1],0
 009E 550000            mov [_i],0
 00A1                   .dbline 161
 00A1           ;                       }
 00A1 8034              xjmp L12
 00A3           L11:
 00A3                   .dbline 163
 00A3           ;                       else //read parameter byte 
 00A3           ;                       {
 00A3                   .dbline 164
 00A3           ;                               if (debug)
 00A3 62D000            mov REG[0xd0],>_debug
 00A6 3C0000            cmp [_debug],0
 00A9 A008              jz L13
 00AB                   .dbline 165
 00AB           ;                                       UART_PutChar(data);
 00AB 10                push X
 00AC 5200              mov A,[X+0]
 00AE 7C0000            xcall _UART_PutChar
 00B1 20                pop X
 00B2           L13:
 00B2                   .dbline 167
 00B2           ;                               
 00B2           ;                               param[i] = data;
 00B2 62D000            mov REG[0xd0],>_i
 00B5 5101              mov A,[_i+1]
 00B7 0303              add A,[X+3]
 00B9 62D000            mov REG[0xd0],>__r0
 00BC 5300              mov [__r1],A
 00BE 62D000            mov REG[0xd0],>_i
 00C1 5100              mov A,[_i]
 00C3 0B02              adc A,[X+2]
 00C5 62D000            mov REG[0xd0],>__r0
 00C8 60D5              mov REG[0xd5],A
 00CA 5200              mov A,[X+0]
 00CC 3F00              mvi [__r1],A
 00CE                   .dbline 168
 00CE           ;                               i++;
 00CE 62D000            mov REG[0xd0],>_i
 00D1 7601              inc [_i+1]
 00D3 0E0000            adc [_i],0
 00D6                   .dbline 169
 00D6           ;                       }
 00D6           L12:
 00D6                   .dbline 170
 00D6           ;               }
 00D6           L9:
 00D6                   .dbline 171
 00D6           ;       }
 00D6           L3:
 00D6                   .dbline 136
 00D6 8F31              xjmp L2
 00D8           X0:
 00D8                   .dbline -2
 00D8           L1:
 00D8 38FC              add SP,-4
 00DA 20                pop X
 00DB                   .dbline 0 ; func end
 00DB 8FFF              jmp .
 00DD                   .dbsym l param 2 pc
 00DD                   .dbsym l command 1 c
 00DD                   .dbsym l data 0 c
 00DD                   .dbend
 00DD                   .dbfunc e init _init fV
 00DD           ;     debug_conf -> X+0
 00DD           _init::
 00DD                   .dbline -1
 00DD 10                push X
 00DE 4F                mov X,SP
 00DF 3801              add SP,1
 00E1                   .dbline 175
 00E1           ; }
 00E1           ; 
 00E1           ; void init(void)
 00E1           ; {
 00E1                   .dbline 179
 00E1           ;       BYTE debug_conf;
 00E1           ;       
 00E1           ;       //enable the positive edge and falling edge paramers
 00E1           ;       ENC1A_PEDGE_Start();
 00E1 10                push X
 00E2 7C0000            xcall _ENC1A_PEDGE_Start
 00E5                   .dbline 180
 00E5           ;       ENC1B_PEDGE_Start();
 00E5 7C0000            xcall _ENC1B_PEDGE_Start
 00E8                   .dbline 181
 00E8           ;       ENC1A_NEDGE_Start();
 00E8 7C0000            xcall _ENC1A_NEDGE_Start
 00EB                   .dbline 182
 00EB           ;       ENC1B_NEDGE_Start();
 00EB 7C0000            xcall _ENC1B_NEDGE_Start
 00EE                   .dbline 185
 00EE           ;       
 00EE           ;       //enable the falling edge and positive edge interrupts for Encoder 1
 00EE           ;       ENC1A_PEDGE_EnableInt();
 00EE 7C0000            xcall _ENC1A_PEDGE_EnableInt
 00F1                   .dbline 186
 00F1           ;       ENC1B_PEDGE_EnableInt();
 00F1 7C0000            xcall _ENC1B_PEDGE_EnableInt
 00F4                   .dbline 187
 00F4           ;       ENC1A_NEDGE_EnableInt();
 00F4 7C0000            xcall _ENC1A_NEDGE_EnableInt
 00F7                   .dbline 188
 00F7           ;       ENC1B_NEDGE_EnableInt();
 00F7 7C0000            xcall _ENC1B_NEDGE_EnableInt
 00FA                   .dbline 191
 00FA           ;       
 00FA           ;       //Start motor speed PWMs
 00FA           ;       PWMA_Start();
 00FA 7C0000            xcall _PWMA_Start
 00FD                   .dbline 192
 00FD           ;       PWMB_Start();
 00FD 7C0000            xcall _PWMB_Start
 0100                   .dbline 195
 0100           ;       
 0100           ;       //Start servos
 0100           ;       Servo0_Start();
 0100 7C0000            xcall _Servo0_Start
 0103                   .dbline 196
 0103           ;       Servo1_Start();
 0103 7C0000            xcall _Servo1_Start
 0106                   .dbline 199
 0106           ;       
 0106           ;       //start the UART
 0106           ;       UART_Start(UART_PARITY_NONE);
 0106 5000              mov A,0
 0108 7C0000            xcall _UART_Start
 010B 20                pop X
 010C                   .dbline 202
 010C           ;       
 010C           ;       //enable appropriate interrupts
 010C           ;       M8C_EnableIntMask(INT_MSK0, INT_MSK0_GPIO);
 010C 43E020            or REG[0xe0],32
 010F                   .dbline 203
 010F           ;       M8C_EnableIntMask(INT_MSK1, INT_MSK1_DBB00);
 010F 43E101            or REG[0xe1],1
 0112                   .dbline 204
 0112           ;       M8C_EnableIntMask(INT_MSK1, INT_MSK1_DBB11);
 0112 43E120            or REG[0xe1],32
 0115                   .dbline 205
 0115           ;       M8C_EnableGInt;
 0115 7101                      or  F, 01h
 0117           
 0117                   .dbline 207
 0117           ;       
 0117           ;       UART_PutCRLF();
 0117 10                push X
 0118 7C0000            xcall _UART_PutCRLF
 011B                   .dbline 208
 011B           ;       UART_CPutString("KIPR bots roll out!");
 011B 5091              mov A,>L16
 011D 08                push A
 011E 5091              mov A,<L16
 0120 5C                mov X,A
 0121 18                pop A
 0122 7C0000            xcall _UART_CPutString
 0125                   .dbline 209
 0125           ;       UART_PutCRLF(); 
 0125 7C0000            xcall _UART_PutCRLF
 0128 20                pop X
 0129                   .dbline 212
 0129           ;               
 0129           ;       //clear drive mode settings for MISC7
 0129           ;       MISC7_DriveMode_0_ADDR &= ~MISC7_MASK;
 0129 7110              or F,0x10  ; iopage = 1
 012B 4104FB            and REG[0x4],-5
 012E                   .dbline 213
 012E           ;       MISC7_DriveMode_1_ADDR &= ~MISC7_MASK;
 012E 4105FB            and REG[0x5],-5
 0131                   .dbline 214
 0131           ;       MISC7_DriveMode_2_ADDR &= ~MISC7_MASK;
 0131 70CF              and F,0xCF      ; iopage = 0
 0133 4107FB            and REG[0x7],-5
 0136                   .dbline 217
 0136           ;       
 0136           ;       //clear drive mode settings for MISC8
 0136           ;       MISC8_DriveMode_0_ADDR &= ~MISC8_MASK;
 0136 7110              or F,0x10  ; iopage = 1
 0138 4104F7            and REG[0x4],-9
 013B                   .dbline 218
 013B           ;       MISC8_DriveMode_1_ADDR &= ~MISC8_MASK;
 013B 4105F7            and REG[0x5],-9
 013E                   .dbline 219
 013E           ;       MISC8_DriveMode_2_ADDR &= ~MISC8_MASK;
 013E 70CF              and F,0xCF      ; iopage = 0
 0140 4107F7            and REG[0x7],-9
 0143                   .dbline 223
 0143           ;       
 0143           ;       //now that their settings are cleared set their mode to
 0143           ;       //HIGH-Z to use them as debug point inputs.
 0143           ;       MISC7_DriveMode_1_ADDR |= MISC7_MASK;
 0143 7110              or F,0x10  ; iopage = 1
 0145 430504            or REG[0x5],4
 0148                   .dbline 225
 0148           ;       
 0148           ;       MISC8_DriveMode_1_ADDR |= MISC8_MASK;
 0148 430508            or REG[0x5],8
 014B                   .dbline 229
 014B           ;       
 014B           ;       //read the debug inputs, if they are high then they are
 014B           ;       //being purposefully asserted to enter debug mode.
 014B           ;       debug_conf = (MISC7_Data_ADDR & MISC7_MASK) | (MISC8_Data_ADDR & MISC8_MASK);
 014B 70CF              and F,0xCF      ; iopage = 0
 014D 5D04              mov A,REG[0x4]
 014F 62D000            mov REG[0xd0],>__r0
 0152 5300              mov [__r0],A
 0154 260008            and [__r0],8
 0157 5D04              mov A,REG[0x4]
 0159 5300              mov [__r2],A
 015B 260004            and [__r2],4
 015E 5100              mov A,[__r2]
 0160 2A00              or A,[__r0]
 0162 5400              mov [X+0],A
 0164                   .dbline 231
 0164           ;       
 0164           ;       if (debug_conf == debug_mask)
 0164 5000              mov A,>_debug_mask
 0166 10                push X
 0167 5700              mov X,<_debug_mask
 0169 28                romx
 016A 20                pop X
 016B 5300              mov [__r0],A
 016D 5200              mov A,[X+0]
 016F 3A00              cmp A,[__r0]
 0171 B007              jnz L17
 0173                   .dbline 232
 0173           ;               debug = TRUE;
 0173 62D000            mov REG[0xd0],>_debug
 0176 550001            mov [_debug],1
 0179           L17:
 0179                   .dbline 235
 0179           ;       
 0179           ;       //afterwards reset MISC pins to their intended state
 0179           ;       MISC7_DriveMode_0_ADDR &= ~MISC7_MASK;
 0179 7110              or F,0x10  ; iopage = 1
 017B 4104FB            and REG[0x4],-5
 017E                   .dbline 236
 017E           ;       MISC7_DriveMode_1_ADDR &= ~MISC7_MASK;
 017E 4105FB            and REG[0x5],-5
 0181                   .dbline 237
 0181           ;       MISC7_DriveMode_2_ADDR &= ~MISC7_MASK;
 0181 70CF              and F,0xCF      ; iopage = 0
 0183 4107FB            and REG[0x7],-5
 0186                   .dbline 239
 0186           ;       
 0186           ;       MISC8_DriveMode_0_ADDR &= ~MISC8_MASK;
 0186 7110              or F,0x10  ; iopage = 1
 0188 4104F7            and REG[0x4],-9
 018B                   .dbline 240
 018B           ;       MISC8_DriveMode_1_ADDR &= ~MISC8_MASK;
 018B 4105F7            and REG[0x5],-9
 018E                   .dbline 241
 018E           ;       MISC8_DriveMode_2_ADDR &= ~MISC8_MASK;
 018E 70CF              and F,0xCF      ; iopage = 0
 0190 4107F7            and REG[0x7],-9
 0193                   .dbline 244
 0193           ;       
 0193           ;       //set MISC7 and MISC8 to HIGH-Z Analog
 0193           ;       MISC7_DriveMode_2_ADDR |= MISC7_MASK;
 0193 430704            or REG[0x7],4
 0196                   .dbline 245
 0196           ;       MISC7_DriveMode_1_ADDR |= MISC7_MASK;
 0196 7110              or F,0x10  ; iopage = 1
 0198 430504            or REG[0x5],4
 019B                   .dbline 247
 019B           ;       
 019B           ;       MISC8_DriveMode_2_ADDR |= MISC8_MASK;
 019B 70CF              and F,0xCF      ; iopage = 0
 019D 430708            or REG[0x7],8
 01A0                   .dbline 248
 01A0           ;       MISC8_DriveMode_1_ADDR |= MISC8_MASK;
 01A0 7110              or F,0x10  ; iopage = 1
 01A2 430508            or REG[0x5],8
 01A5                   .dbline -2
 01A5 70CF              and F,0xCF      ; iopage = 0
 01A7           L15:
 01A7 38FF              add SP,-1
 01A9 20                pop X
 01AA                   .dbline 0 ; func end
 01AA 7F                ret
 01AB                   .dbsym l debug_conf 0 c
 01AB                   .dbend
 01AB                   .dbfunc e getVelocity _getVelocity fI
 01AB           ;            vel -> X+0
 01AB           _getVelocity::
 01AB                   .dbline -1
 01AB 10                push X
 01AC 4F                mov X,SP
 01AD 3802              add SP,2
 01AF                   .dbline 253
 01AF           ; }
 01AF           ; 
 01AF           ; /* Calculates the velocity in RPMs and returns the value */
 01AF           ; int getVelocity(void)
 01AF           ; {
 01AF                   .dbline 254
 01AF           ;       int vel = 0;
 01AF 560100            mov [X+1],0
 01B2 560000            mov [X+0],0
 01B5                   .dbline 255
 01B5           ;       return vel;     
 01B5 62D000            mov REG[0xd0],>__r0
 01B8 5201              mov A,[X+1]
 01BA 5300              mov [__r1],A
 01BC 5200              mov A,[X+0]
 01BE 5300              mov [__r0],A
 01C0                   .dbline -2
 01C0           L19:
 01C0 38FE              add SP,-2
 01C2 20                pop X
 01C3                   .dbline 0 ; func end
 01C3 7F                ret
 01C4                   .dbsym l vel 0 I
 01C4                   .dbend
 01C4                   .dbfunc e action _action fV
                        .area func_lit(rom, con, rel, proclab)
 0000           L102:
 0000 0259              .word L28
 0002 028E              .word L32
 0004 02C3              .word L36
 0006 0307              .word L37
 0008 0366              .word L43
 000A 03C5              .word L49
 000C 03E6              .word L53
 000E 0407              .word L57
 0010 0448              .word L63
 0012 0489              .word L69
 0014 04B4              .word L73
 0016 04DF              .word L77
 0018 050D              .word L81
 001A 0535              .word L85
 001C 055D              .word L89
 001E 0585              .word L93
                        .area text(rom, con, rel)
                ;          param -> X-6
                ;        command -> X-4
 0492           _action::
 0492                   .dbline -1
 0492 10                push X
 0493 4F                mov X,SP
 0494 3802              add SP,2
 0496                   .dbline 289
 0496           ; }
 0496           ; 
 0496           ; /* Action lookup. Takes the appropriate action for the given command and param.
 0496           ;  * command: the command read from the UART.
 0496           ;  * param: the data (if any) associated with the command.
 0496           ;  */
 0496           ; void action(char command, char* param)
 0496           ; {     
 0496                   .dbline 290
 0496           ;       if(debug)
 0496 62D000            mov REG[0xd0],>_debug
 0499 3C0000            cmp [_debug],0
 049C A033              jz L24
 049E                   .dbline 292
 049E           ;       {
 049E           ;               UART_PutCRLF();
 049E                   .dbline 292
 049E 10                push X
 049F 7C0000            xcall _UART_PutCRLF
 04A2 20                pop X
 04A3                   .dbline 379
 04A3           ;                       }
 04A3           L70:
 04A3                   .dbline 381
 04A3           ;                       
 04A3           ;                       count1 = 0;
 04A3 62D000            mov REG[0xd0],>_count1
 04A6 550000            mov [_count1],0
 04A9 550100            mov [_count1+1],0
 04AC 550200            mov [_count1+2],0
 04AF 550300            mov [_count1+3],0
 04B2                   .dbline 382
 04B2           ;                       break;
 04B2 8120              xjmp L26
 04B4           L73:
 04B4                   .dbline 384
 04B4           ;               case 'k': //RSTC2
 04B4           ;                       if(debug)
 04B4 62D000            mov REG[0xd0],>_debug
 04B7 3C0000            cmp [_debug],0
 04BA A013              jz L74
 04BC                   .dbline 386
 04BC           ;                       {
 04BC           ;                               UART_PutCRLF();
 04BC                   .dbline 386
 04BC 10                push X
 04BD 7C0000            xcall _UART_PutCRLF
 04C0                   .dbline 387
 04C0           ;                               UART_CPutString("Resetting count2");
 04C0 5091              mov A,>L76
 04C2 08                push A
 04C3 5091              mov A,<L76
 04C5 5C                mov X,A
 04C6 18                pop A
 04C7 7C0000            xcall _UART_CPutString
 04CA                   .dbline 388
 04CA           ;                               UART_PutCRLF();
 04CA 7C0000            xcall _UART_PutCRLF
 04CD 20                pop X
 04CE                   .dbline 389
 04CE           ;                       }
 04CE           L74:
 04CE                   .dbline 391
 04CE           ;                       
 04CE           ;                       count2 = 0;
 04CE 62D000            mov REG[0xd0],>_count2
 04D1 550000            mov [_count2],0
 04D4 550100            mov [_count2+1],0
 04D7 550200            mov [_count2+2],0
 04DA 550300            mov [_count2+3],0
 04DD                   .dbline 392
 04DD           ;                       break;
 04DD 80F5              xjmp L26
 04DF           L77:
 04DF                   .dbline 394
 04DF           ;               case 'l': //STOP
 04DF           ;                       if(debug)
 04DF 62D000            mov REG[0xd0],>_debug
 04E2 3C0000            cmp [_debug],0
 04E5 A013              jz L78
 04E7                   .dbline 396
 04E7           ;                       {
 04E7           ;                               UART_PutCRLF();
 04E7                   .dbline 396
 04E7 10                push X
 04E8 7C0000            xcall _UART_PutCRLF
 04EB                   .dbline 397
 04EB           ;                               UART_CPutString("Stopping motors");
 04EB 5081              mov A,>L80
 04ED 08                push A
 04EE 5081              mov A,<L80
 04F0 5C                mov X,A
 04F1 18                pop A
 04F2 7C0000            xcall _UART_CPutString
 04F5                   .dbline 398
 04F5           ;                               UART_PutCRLF();
 04F5 7C0000            xcall _UART_PutCRLF
 04F8 20                pop X
 04F9                   .dbline 399
 04F9           ;                       }
 04F9           L78:
 04F9                   .dbline 401
 04F9           ;                       
 04F9           ;                       PWMA_WritePulseWidth(0);
 04F9 10                push X
 04FA 5000              mov A,0
 04FC 7C0000            xcall _PWMA_WritePulseWidth
 04FF                   .dbline 402
 04FF           ;                       PWMB_WritePulseWidth(0);
 04FF 5000              mov A,0
 0501 7C0000            xcall _PWMB_WritePulseWidth
 0504                   .dbline 403
 0504           ;                       PWMA_Stop();
 0504 7C0000            xcall _PWMA_Stop
 0507                   .dbline 404
 0507           ;                       PWMB_Stop();
 0507 7C0000            xcall _PWMB_Stop
 050A 20                pop X
 050B                   .dbline 405
 050B           ;                       break;
 050B 80C7              xjmp L26
 050D           L81:
 050D                   .dbline 407
 050D           ;               case 'm': //FORWARD
 050D           ;                       if (debug)
 050D 62D000            mov REG[0xd0],>_debug
 0510 3C0000            cmp [_debug],0
 0513 A013              jz L82
 0515                   .dbline 409
 0515           ;                       {
 0515           ;                               UART_PutCRLF();
 0515                   .dbline 409
 0515 10                push X
 0516 7C0000            xcall _UART_PutCRLF
 0519                   .dbline 410
 0519           ;                               UART_CPutString("Setting drive mode to forward.");
 0519 5062              mov A,>L84
 051B 08                push A
 051C 5062              mov A,<L84
 051E 5C                mov X,A
 051F 18                pop A
 0520 7C0000            xcall _UART_CPutString
 0523                   .dbline 411
 0523           ;                               UART_PutCRLF();
 0523 7C0000            xcall _UART_PutCRLF
 0526 20                pop X
 0527                   .dbline 412
 0527           ;                       }
 0527           L82:
 0527                   .dbline 414
 0527           ;                       
 0527           ;                       AIN1_Data_ADDR |= AIN1_MASK;
 0527 430410            or REG[0x4],16
 052A                   .dbline 415
 052A           ;                       AIN2_Data_ADDR |= AIN2_MASK;
 052A 430440            or REG[0x4],64
 052D                   .dbline 416
 052D           ;                       BIN1_Data_ADDR &= ~BIN1_MASK;
 052D 4108FD            and REG[0x8],-3
 0530                   .dbline 417
 0530           ;                       BIN2_Data_ADDR &= ~BIN2_MASK;
 0530 41047F            and REG[0x4],127
 0533                   .dbline 418
 0533           ;                       break;
 0533 809F              xjmp L26
 0535           L85:
 0535                   .dbline 420
 0535           ;               case 'n': //BACKWARD
 0535           ;                       if (debug)
 0535 62D000            mov REG[0xd0],>_debug
 0538 3C0000            cmp [_debug],0
 053B A013              jz L86
 053D                   .dbline 422
 053D           ;                       {
 053D           ;                               UART_PutCRLF();
 053D                   .dbline 422
 053D 10                push X
 053E 7C0000            xcall _UART_PutCRLF
 0541                   .dbline 423
 0541           ;                               UART_CPutString("Setting drive mode to backward.");
 0541 5042              mov A,>L88
 0543 08                push A
 0544 5042              mov A,<L88
 0546 5C                mov X,A
 0547 18                pop A
 0548 7C0000            xcall _UART_CPutString
 054B                   .dbline 424
 054B           ;                               UART_PutCRLF();
 054B 7C0000            xcall _UART_PutCRLF
 054E 20                pop X
 054F                   .dbline 425
 054F           ;                       }
 054F           L86:
 054F                   .dbline 427
 054F           ;                       
 054F           ;                       AIN1_Data_ADDR &= ~AIN1_MASK;
 054F 4104EF            and REG[0x4],-17
 0552                   .dbline 428
 0552           ;                       AIN2_Data_ADDR &= ~AIN2_MASK;
 0552 4104BF            and REG[0x4],-65
 0555                   .dbline 429
 0555           ;                       BIN1_Data_ADDR |= BIN1_MASK;
 0555 430802            or REG[0x8],2
 0558                   .dbline 430
 0558           ;                       BIN2_Data_ADDR |= BIN2_MASK;
 0558 430480            or REG[0x4],-128
 055B                   .dbline 431
 055B           ;                       break;
 055B 8077              xjmp L26
 055D           L89:
 055D                   .dbline 433
 055D           ;               case 'o': //TURNL
 055D           ;                       if (debug)
 055D 62D000            mov REG[0xd0],>_debug
 0560 3C0000            cmp [_debug],0
 0563 A013              jz L90
 0565                   .dbline 435
 0565           ;                       {
 0565           ;                               UART_PutCRLF();
 0565                   .dbline 435
 0565 10                push X
 0566 7C0000            xcall _UART_PutCRLF
 0569                   .dbline 436
 0569           ;                               UART_CPutString("Setting drive mode to left.");
 0569 5026              mov A,>L92
 056B 08                push A
 056C 5026              mov A,<L92
 056E 5C                mov X,A
 056F 18                pop A
 0570 7C0000            xcall _UART_CPutString
 0573                   .dbline 437
 0573           ;                               UART_PutCRLF();
 0573 7C0000            xcall _UART_PutCRLF
 0576 20                pop X
 0577                   .dbline 438
 0577           ;                       }
 0577           L90:
 0577                   .dbline 440
 0577           ;                       
 0577           ;                       AIN1_Data_ADDR |= AIN1_MASK;
 0577 430410            or REG[0x4],16
 057A                   .dbline 441
 057A           ;                       AIN2_Data_ADDR &= ~AIN2_MASK;
 057A 4104BF            and REG[0x4],-65
 057D                   .dbline 442
 057D           ;                       BIN1_Data_ADDR &= ~BIN1_MASK;
 057D 4108FD            and REG[0x8],-3
 0580                   .dbline 443
 0580           ;                       BIN2_Data_ADDR |= BIN2_MASK;
 0580 430480            or REG[0x4],-128
 0583                   .dbline 444
 0583           ;                       break;
 0583 804F              xjmp L26
 0585           L93:
 0585                   .dbline 446
 0585           ;               case 'p': //TURNR
 0585           ;                       if (debug)
 0585 62D000            mov REG[0xd0],>_debug
 0588 3C0000            cmp [_debug],0
 058B A013              jz L94
 058D                   .dbline 448
 058D           ;                       {
 058D           ;                               UART_PutCRLF();
 058D                   .dbline 448
 058D 10                push X
 058E 7C0000            xcall _UART_PutCRLF
 0591                   .dbline 449
 0591           ;                               UART_CPutString("Setting drive mode to right.");
 0591 5009              mov A,>L96
 0593 08                push A
 0594 5009              mov A,<L96
 0596 5C                mov X,A
 0597 18                pop A
 0598 7C0000            xcall _UART_CPutString
 059B                   .dbline 450
 059B           ;                               UART_PutCRLF();
 059B 7C0000            xcall _UART_PutCRLF
 059E 20                pop X
 059F                   .dbline 451
 059F           ;                       }
 059F           L94:
 059F                   .dbline 453
 059F           ;                       
 059F           ;                       AIN1_Data_ADDR &= ~AIN1_MASK;
 059F 4104EF            and REG[0x4],-17
 05A2                   .dbline 454
 05A2           ;                       AIN2_Data_ADDR |= AIN2_MASK;
 05A2 430440            or REG[0x4],64
 05A5                   .dbline 455
 05A5           ;                       BIN1_Data_ADDR |= BIN1_MASK;
 05A5 430802            or REG[0x8],2
 05A8                   .dbline 456
 05A8           ;                       BIN2_Data_ADDR &= ~BIN2_MASK;
 05A8 41047F            and REG[0x4],127
 05AB                   .dbline 457
 05AB           ;                       break;
 05AB 8027              xjmp L26
 05AD           L25:
 05AD                   .dbline 459
 05AD           ;               default : //ERROR
 05AD           ;                       if (debug)
 05AD 62D000            mov REG[0xd0],>_debug
 05B0 3C0000            cmp [_debug],0
 05B3 A006              jz L97
 05B5                   .dbline 460
 05B5           ;                               UART_PutCRLF();
 05B5 10                push X
 05B6 7C0000            xcall _UART_PutCRLF
 05B9 20                pop X
 05BA           L97:
 05BA                   .dbline 462
 05BA           ;                       
 05BA           ;                       UART_CPutString("fu1337"); //error code
 05BA 10                push X
 05BB 5002              mov A,>L99
 05BD 08                push A
 05BE 5002              mov A,<L99
 05C0 5C                mov X,A
 05C1 18                pop A
 05C2 7C0000            xcall _UART_CPutString
 05C5 20                pop X
 05C6                   .dbline 464
 05C6           ;                       
 05C6           ;                       if (debug)
 05C6 62D000            mov REG[0xd0],>_debug
 05C9 3C0000            cmp [_debug],0
 05CC A006              jz L26
 05CE                   .dbline 465
 05CE           ;                               UART_PutCRLF();
 05CE 10                push X
 05CF 7C0000            xcall _UART_PutCRLF
 05D2 20                pop X
 05D3                   .dbline 466
 05D3           ;                       break;
 05D3           L26:
 05D3                   .dbline -2
 05D3           L20:
 05D3 38FE              add SP,-2
 05D5 20                pop X
 05D6                   .dbline 0 ; func end
 05D6 7F                ret
 05D7                   .dbsym l param -6 pc
 05D7                   .dbsym l command -4 c
 05D7                   .dbend
 05D7                   .dbfunc e encoder1_ISR _encoder1_ISR fV
 05D7           _encoder1_ISR::
 05D7                   .dbline -1
 05D7 71C0              or F,-64
 05D9 08                push A
 05DA 5DD0              mov A,REG[0xd0]
 05DC 08                push A
 05DD                   .dbline 472
 05DD           ;       }
 05DD           ; }
 05DD           ; 
 05DD           ; //Encoder 1 interrupts are generated by the falling edge and positive edge paramers.
 05DD           ; void encoder1_ISR(void)
 05DD           ; {
 05DD                   .dbline 474
 05DD           ;       //grab the new state of the encoder register.
 05DD           ;       curPrt1 = (ENC1A_Data_ADDR & (ENC1A_MASK | ENC1B_MASK));
 05DD 5D08              mov A,REG[0x8]
 05DF 2150              and A,80
 05E1 62D000            mov REG[0xd0],>_curPrt1
 05E4 5300              mov [_curPrt1],A
 05E6                   .dbline 477
 05E6           ;               
 05E6           ;       //check which state transitioned.
 05E6           ;       if ((prevPrt1 == 0x00) && (curPrt1 == stateA1)) //A low to high
 05E6 62D000            mov REG[0xd0],>_prevPrt1
 05E9 3C0000            cmp [_prevPrt1],0
 05EC B01A              jnz L104
 05EE 62D000            mov REG[0xd0],>_curPrt1
 05F1 3C0020            cmp [_curPrt1],32
 05F4 B012              jnz L104
 05F6                   .dbline 479
 05F6           ;       {
 05F6           ;               count1++;
 05F6                   .dbline 479
 05F6 62D000            mov REG[0xd0],>_count1
 05F9 060301            add [_count1+3],1
 05FC 0E0200            adc [_count1+2],0
 05FF 0E0100            adc [_count1+1],0
 0602 0E0000            adc [_count1],0
 0605                   .dbline 480
 0605           ;       }
 0605 8020              xjmp L105
 0607           L104:
 0607                   .dbline 481
 0607           ;       else if ((prevPrt1 == 0x00) && (curPrt1 == stateB1)) //B low to high
 0607 62D000            mov REG[0xd0],>_prevPrt1
 060A 3C0000            cmp [_prevPrt1],0
 060D B018              jnz L106
 060F 62D000            mov REG[0xd0],>_curPrt1
 0612 3C0008            cmp [_curPrt1],8
 0615 B010              jnz L106
 0617                   .dbline 483
 0617           ;       {
 0617           ;               count1--;
 0617                   .dbline 483
 0617 62D000            mov REG[0xd0],>_count1
 061A 160301            sub [_count1+3],1
 061D 1E0200            sbb [_count1+2],0
 0620 1E0100            sbb [_count1+1],0
 0623 1E0000            sbb [_count1],0
 0626                   .dbline 484
 0626           ;       }
 0626           L106:
 0626           L105:
 0626                   .dbline -2
 0626           L103:
 0626 18                pop A
 0627 60D0              mov REG[208],A
 0629 18                pop A
 062A                   .dbline 0 ; func end
 062A 7E                reti
 062B                   .dbend
 062B                   .dbfunc e encoder2_ISR _encoder2_ISR fV
 062B           _encoder2_ISR::
 062B                   .dbline -1
 062B 71C0              or F,-64
 062D 08                push A
 062E 5DD0              mov A,REG[0xd0]
 0630 08                push A
 0631                   .dbline 490
 0631           ; }
 0631           ; 
 0631           ; //Encoder 2 interrupts are generated directly by the GPIO interrupt. Logically equivalent
 0631           ; //to the encoder1_ISR
 0631           ; void encoder2_ISR(void)
 0631           ; {
 0631                   .dbline 491
 0631           ;       curPrt2 = (ENC2A_Data_ADDR & (ENC2A_MASK | ENC2B_MASK));        
 0631 5D08              mov A,REG[0x8]
 0633 2128              and A,40
 0635 62D000            mov REG[0xd0],>_curPrt2
 0638 5300              mov [_curPrt2],A
 063A                   .dbline 493
 063A           ;               
 063A           ;       if ((prevPrt2 == 0x00) && (curPrt2 == stateA2)) 
 063A 62D000            mov REG[0xd0],>_prevPrt2
 063D 3C0000            cmp [_prevPrt2],0
 0640 B01A              jnz L109
 0642 62D000            mov REG[0xd0],>_curPrt2
 0645 3C0010            cmp [_curPrt2],16
 0648 B012              jnz L109
 064A                   .dbline 495
 064A           ;       {
 064A           ;               count2++;
 064A                   .dbline 495
 064A 62D000            mov REG[0xd0],>_count2
 064D 060301            add [_count2+3],1
 0650 0E0200            adc [_count2+2],0
 0653 0E0100            adc [_count2+1],0
 0656 0E0000            adc [_count2],0
 0659                   .dbline 496
 0659           ;       }
 0659 8020              xjmp L110
 065B           L109:
 065B                   .dbline 497
 065B           ;       else if ((prevPrt2 == 0x00) && (curPrt2 == stateB2))
 065B 62D000            mov REG[0xd0],>_prevPrt2
 065E 3C0000            cmp [_prevPrt2],0
 0661 B018              jnz L111
 0663 62D000            mov REG[0xd0],>_curPrt2
 0666 3C0004            cmp [_curPrt2],4
 0669 B010              jnz L111
 066B                   .dbline 499
 066B           ;       {
 066B           ;               count2--;
 066B                   .dbline 499
 066B 62D000            mov REG[0xd0],>_count2
 066E 160301            sub [_count2+3],1
 0671 1E0200            sbb [_count2+2],0
 0674 1E0100            sbb [_count2+1],0
 0677 1E0000            sbb [_count2],0
 067A                   .dbline 500
 067A           ;       }
 067A           L111:
 067A           L110:
 067A                   .dbline -2
 067A           L108:
 067A 18                pop A
 067B 60D0              mov REG[208],A
 067D 18                pop A
 067E                   .dbline 0 ; func end
 067E 7E                reti
 067F                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _prevPrt2::
 0000 00                .byte 0
 0001                   .dbsym e prevPrt2 _prevPrt2 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _curPrt2::
 0000 00                .byte 0
 0001                   .dbsym e curPrt2 _curPrt2 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _prevPrt1::
 0000 00                .byte 0
 0001                   .dbsym e prevPrt1 _prevPrt1 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
 0000           _curPrt1::
 0000 00                .byte 0
 0001                   .dbsym e curPrt1 _curPrt1 c
                        .area lit(rom, con, rel, lit)
 0002           L99:
 0002 66753133333700    .byte 'f,'u,49,51,51,55,0
 0009           L96:
 0009 53657474696E67206472697665206D6F  .byte 'S,'e,'t,'t,'i,'n,'g,32,'d,'r,'i,'v,'e,32,'m,'o
 0019 646520746F2072696768742E00        .byte 'd,'e,32,'t,'o,32,'r,'i,'g,'h,'t,46,0
 0026           L92:
 0026 53657474696E67206472697665206D6F  .byte 'S,'e,'t,'t,'i,'n,'g,32,'d,'r,'i,'v,'e,32,'m,'o
 0036 646520746F206C6566742E00  .byte 'd,'e,32,'t,'o,32,'l,'e,'f,'t,46,0
 0042           L88:
 0042 53657474696E67206472697665206D6F  .byte 'S,'e,'t,'t,'i,'n,'g,32,'d,'r,'i,'v,'e,32,'m,'o
 0052 646520746F206261636B776172642E00  .byte 'd,'e,32,'t,'o,32,'b,'a,'c,'k,'w,'a,'r,'d,46,0
 0062           L84:
 0062 53657474696E67206472697665206D6F  .byte 'S,'e,'t,'t,'i,'n,'g,32,'d,'r,'i,'v,'e,32,'m,'o
 0072 646520746F20666F72776172642E00    .byte 'd,'e,32,'t,'o,32,'f,'o,'r,'w,'a,'r,'d,46,0
 0081           L80:
 0081 53746F7070696E67206D6F746F727300  .byte 'S,'t,'o,'p,'p,'i,'n,'g,32,'m,'o,'t,'o,'r,'s,0
 0091           L76:
 0091 526573657474696E6720636F756E7432  .byte 'R,'e,'s,'e,'t,'t,'i,'n,'g,32,'c,'o,'u,'n,'t,50
 00A1 00                .byte 0
 00A2           L72:
 00A2 526573657474696E6720636F756E7431  .byte 'R,'e,'s,'e,'t,'t,'i,'n,'g,32,'c,'o,'u,'n,'t,49
 00B2 00                .byte 0
 00B3           L66:
 00B3 456E636F646572203220636F756E743A  .byte 'E,'n,'c,'o,'d,'e,'r,32,50,32,'c,'o,'u,'n,'t,58
 00C3 2000              .byte 32,0
 00C5           L60:
 00C5 456E636F646572203120636F756E743A  .byte 'E,'n,'c,'o,'d,'e,'r,32,49,32,'c,'o,'u,'n,'t,58
 00D5 2000              .byte 32,0
 00D7           L56:
 00D7 53746F7070696E672050574D20666F72  .byte 'S,'t,'o,'p,'p,'i,'n,'g,32,'P,'W,'M,32,'f,'o,'r
 00E7 20736572766F20312E00      .byte 32,'s,'e,'r,'v,'o,32,49,46,0
 00F1           L52:
 00F1 53746F7070696E672050574D20666F72  .byte 'S,'t,'o,'p,'p,'i,'n,'g,32,'P,'W,'M,32,'f,'o,'r
 0101 20736572766F20302E00      .byte 32,'s,'e,'r,'v,'o,32,48,46,0
 010B           L46:
 010B 53657474696E6720736572766F203120  .byte 'S,'e,'t,'t,'i,'n,'g,32,'s,'e,'r,'v,'o,32,49,32
 011B 70756C736520776964746820746F3A20  .byte 'p,'u,'l,'s,'e,32,'w,'i,'d,'t,'h,32,'t,'o,58,32
 012B 00                .byte 0
 012C           L40:
 012C 53657474696E6720736572766F203020  .byte 'S,'e,'t,'t,'i,'n,'g,32,'s,'e,'r,'v,'o,32,48,32
 013C 70756C736520776964746820746F3A20  .byte 'p,'u,'l,'s,'e,32,'w,'i,'d,'t,'h,32,'t,'o,58,32
 014C 00                .byte 0
 014D           L35:
 014D 53657474696E672050574D2064757479  .byte 'S,'e,'t,'t,'i,'n,'g,32,'P,'W,'M,32,'d,'u,'t,'y
 015D 206379636C6520746F3A2000  .byte 32,'c,'y,'c,'l,'e,32,'t,'o,58,32,0
 0169           L31:
 0169 53657474696E672076656C6F63697479  .byte 'S,'e,'t,'t,'i,'n,'g,32,'v,'e,'l,'o,'c,'i,'t,'y
 0179 20746F3A2000      .byte 32,'t,'o,58,32,0
 017F           L24:
 017F 506172616D3A2000  .byte 'P,'a,'r,'a,'m,58,32,0
 0187           L23:
 0187 436F6D6D616E643A2000      .byte 'C,'o,'m,'m,'a,'n,'d,58,32,0
 0191           L16:
 0191 4B49505220626F747320726F6C6C206F  .byte 'K,'I,'P,'R,32,'b,'o,'t,'s,32,'r,'o,'l,'l,32,'o
 01A1 75742100          .byte 'u,'t,33,0
