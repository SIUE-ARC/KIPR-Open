FILE: .\boot.asm                        (0001) ;  Generated by PSoC Designer 5.4.2946
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#903 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.30
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY8C29xxx microcontroller family.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; The following equate is required for proper operation. Reseting its value
                                        (0068) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                        (0069) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                        (0070) ; and PLL_Lock must take place within user code. See the family data sheet for
                                        (0071) ; the requirements of starting the ECO and PLL lock mode.
                                        (0072) ;
                                        (0073) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                        (0074) ;                invoking main
                                        (0075) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
                                        (0076) ;               the time code in main starts executing.
                                        (0077) ;
                                        (0078) WAIT_FOR_32K:                    equ 1
                                        (0079) 
                                        (0080) 
                                        (0081) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0082) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0083) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0084) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0085) ; bytes on the stack which are otherwise required for the return address. If
                                        (0086) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0087) ; release, the C compiler automatically places an infinite loop at the end
                                        (0088) ; of main, rather than a return instruction.)
                                        (0089) ;
                                        (0090) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0091) 
                                        (0092) 
                                        (0093) ;-----------------------------------------------------------------------------
                                        (0094) ; Interrupt Vector Table
                                        (0095) ;-----------------------------------------------------------------------------
                                        (0096) ;
                                        (0097) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0098) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0099) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0100) ; vector jump targets are modified automatically according to the user
                                        (0101) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0102) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0103) ; configuration files. If you need to hard code a vector, update the
                                        (0104) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0105) ; of this file.
                                        (0106) ;-----------------------------------------------------------------------------
                                        (0107) 
                                        (0108)     AREA TOP (ROM, ABS, CON)
                                        (0109) 
                                        (0110)     org   0                        ;Reset Interrupt Vector
                                        (0111) IF	(TOOLCHAIN & HITECH)
                                        (0112) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0113) ELSE
0000: 80 67    JMP   0x0068             (0114)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0115) ENDIF
                                        (0116)     ;@PSoC_BOOT_ISR_UserCode_START@
                                        (0117)     ;---------------------------------------------------
                                        (0118)     ; Insert your custom code below this banner
                                        (0119)     ;---------------------------------------------------
                                        (0120) 
                                        (0121)     org   04h                      ;Low Voltage Detect (LVD) Interrupt Vector
0004: 30       HALT                     (0122)     halt                           ;Stop execution if power falls too low
                                        (0123) 
                                        (0124)     org   08h                      ;Analog Column 0 Interrupt Vector
                                        (0125)     // call	void_handler
0008: 7E       RETI                     (0126)     reti
                                        (0127) 
                                        (0128)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                        (0129)     // call	void_handler
000C: 7E       RETI                     (0130)     reti
                                        (0131) 
                                        (0132)     org   10h                      ;Analog Column 2 Interrupt Vector
                                        (0133)     // call	void_handler
0010: 7E       RETI                     (0134)     reti
                                        (0135) 
                                        (0136)     org   14h                      ;Analog Column 3 Interrupt Vector
                                        (0137)     // call	void_handler
0014: 7E       RETI                     (0138)     reti
                                        (0139) 
                                        (0140)     org   18h                      ;VC3 Interrupt Vector
                                        (0141)     // call	void_handler
0018: 7E       RETI                     (0142)     reti
                                        (0143) 
                                        (0144)     org   1Ch                      ;GPIO Interrupt Vector
001C: 7D 11 36 LJMP  _encoder2_ISR      (0145)     ljmp _encoder2_ISR
001F: 7E       RETI                     (0146)     reti
                                        (0147) 
                                        (0148)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
0020: 7D 10 E2 LJMP  _encoder1_ISR      (0149)     ljmp _encoder1_ISR
0023: 7E       RETI                     (0150)     reti
                                        (0151) 
                                        (0152)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                        (0153)     // call	void_handler
0024: 7E       RETI                     (0154)     reti
                                        (0155) 
                                        (0156)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
0028: 7D 09 8F LJMP  _Servo0_ISR        (0157)     ljmp	_Servo0_ISR
002B: 7E       RETI                     (0158)     reti
                                        (0159) 
                                        (0160)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
002C: 7D 0A 33 LJMP  _PWMA_ISR          (0161)     ljmp	_PWMA_ISR
002F: 7E       RETI                     (0162)     reti
                                        (0163) 
                                        (0164)     org   30h                      ;PSoC Block DBB10 Interrupt Vector
0030: 7D 10 E2 LJMP  _encoder1_ISR      (0165)     ljmp _encoder1_ISR
0033: 7E       RETI                     (0166)     reti
                                        (0167) 
                                        (0168)     org   34h                      ;PSoC Block DBB11 Interrupt Vector
0034: 7D 10 E2 LJMP  _encoder1_ISR      (0169)     ljmp _encoder1_ISR
0037: 7E       RETI                     (0170)     reti
                                        (0171) 
                                        (0172)     org   38h                      ;PSoC Block DCB12 Interrupt Vector
0038: 7D 06 D3 LJMP  _UART_TX_ISR       (0173)     ljmp	_UART_TX_ISR
003B: 7E       RETI                     (0174)     reti
                                        (0175) 
                                        (0176)     org   3Ch                      ;PSoC Block DCB13 Interrupt Vector
003C: 7D 06 D4 LJMP  _UART_RX_ISR       (0177)     ljmp	_UART_RX_ISR
003F: 7E       RETI                     (0178)     reti
                                        (0179) 
                                        (0180)     org   40h                      ;PSoC Block DBB20 Interrupt Vector
0040: 7D 09 EC LJMP  _PWMB_ISR          (0181)     ljmp	_PWMB_ISR
0043: 7E       RETI                     (0182)     reti
                                        (0183) 
                                        (0184)     org   44h                      ;PSoC Block DBB21 Interrupt Vector
0044: 7D 0A 8A LJMP  _ENC1B_NEDGE_ISR   (0185)     ljmp	_ENC1B_NEDGE_ISR
0047: 7E       RETI                     (0186)     reti
                                        (0187) 
                                        (0188)     org   48h                      ;PSoC Block DCB22 Interrupt Vector
                                        (0189)     // call	void_handler
0048: 7E       RETI                     (0190)     reti
                                        (0191) 
                                        (0192)     org   4Ch                      ;PSoC Block DCB23 Interrupt Vector
004C: 7D 09 32 LJMP  _Servo1_ISR        (0193)     ljmp	_Servo1_ISR
004F: 7E       RETI                     (0194)     reti
                                        (0195) 
                                        (0196)     org   50h                      ;PSoC Block DBB30 Interrupt Vector
                                        (0197)     // call	void_handler
0050: 7E       RETI                     (0198)     reti
                                        (0199) 
                                        (0200)     org   54h                      ;PSoC Block DBB31 Interrupt Vector
0054: 7D 10 E2 LJMP  _encoder1_ISR      (0201)     ljmp _encoder1_ISR
0057: 7E       RETI                     (0202)     reti
                                        (0203) 
                                        (0204)     org   58h                      ;PSoC Block DCB32 Interrupt Vector
                                        (0205)     // call	void_handler
0058: 7E       RETI                     (0206)     reti
                                        (0207) 
                                        (0208)     org   5Ch                      ;PSoC Block DCB33 Interrupt Vector
                                        (0209)     // call	void_handler
005C: 7E       RETI                     (0210)     reti
                                        (0211) 
                                        (0212)     org   60h                      ;PSoC I2C Interrupt Vector
                                        (0213)     // call	void_handler
0060: 7E       RETI                     (0214)     reti
                                        (0215) 
                                        (0216)     org   64h                      ;Sleep Timer Interrupt Vector
                                        (0217)     // call	void_handler
0064: 7E       RETI                     (0218)     reti
0068: 71 10    OR    F,0x10             
                                        (0219)     ;---------------------------------------------------
                                        (0220)     ; Insert your custom code above this banner
                                        (0221)     ;---------------------------------------------------
                                        (0222)     ;@PSoC_BOOT_ISR_UserCode_END@
                                        (0223) 
                                        (0224) ;-----------------------------------------------------------------------------
                                        (0225) ;  Start of Execution.
                                        (0226) ;-----------------------------------------------------------------------------
                                        (0227) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0228) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0229) ;
                                        (0230) 
                                        (0231) IF	(TOOLCHAIN & HITECH)
                                        (0232)  	AREA PD_startup(CODE, REL, CON)
                                        (0233) ELSE
                                        (0234)     org 68h
                                        (0235) ENDIF
                                        (0236) __Start:
                                        (0237) 
                                        (0238)     ; initialize SMP values for voltage stabilization, if required,
                                        (0239)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0240)     ; least for now. 
                                        (0241)     ;
                                        (0242)     M8C_SetBank1
006A: 62 FA 00 MOV   REG[0xFA],0x0      (0243)     mov reg[0FAh], 0				;Reset flash location
006D: 62 E3 87 MOV   REG[0xE3],0x87     (0244)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
0070: 70 EF    AND   F,0xEF             
                                        (0245)     M8C_SetBank0
                                        (0246) 
                                        (0247)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
0072: 50 20    MOV   A,0x20             (0248)     mov   A, 20h
0074: 28       ROMX                     (0249)     romx
0075: 50 40    MOV   A,0x40             (0250)     mov   A, 40h
0077: 28       ROMX                     (0251)     romx
0078: 50 60    MOV   A,0x60             (0252)     mov   A, 60h
007A: 28       ROMX                     (0253)     romx
007B: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0254)     ; %45%20%46%46% End workaround
                                        (0255) 
                                        (0256) M8C_ClearWDTAndSleep			   ; Clear WDT before enabling it.
                                        (0257) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0258)     M8C_EnableWatchDog
                                        (0259) ENDIF
                                        (0260) 
                                        (0261) IF ( SELECT_32K )
                                        (0262)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                        (0263) ELSE
007E: 41 FE FB AND   REG[0xFE],0xFB     (0264)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0265) ENDIF
                                        (0266) 
                                        (0267)     ;---------------------------
                                        (0268)     ; Set up the Temporary stack
                                        (0269)     ;---------------------------
                                        (0270)     ; A temporary stack is set up for the SSC instructions.
                                        (0271)     ; The real stack start will be assigned later.
                                        (0272)     ;
                                        (0273) _stack_start:          equ 80h
0081: 50 80    MOV   A,0x80             (0274)     mov   A, _stack_start          ; Set top of stack to end of used RAM
0083: 4E       SWAP  SP,A               (0275)     swap  SP, A                    ; This is only temporary if going to LMM
0084: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0276) 
                                        (0277)     ;-----------------------------------------------
                                        (0278)     ; Set Power-related Trim & the AGND Bypass bit.
                                        (0279)     ;-----------------------------------------------
                                        (0280) M8C_ClearWDTAndSleep ; Clear WDT before enabling it.
                                        (0281) 
                                        (0282) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                        (0283)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0284)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0285)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0286)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0287)   IF ( AGND_BYPASS )
                                        (0288)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0289)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                        (0290)     ; bit in the write-only BDG_TR register. Recalculate the register
                                        (0291)     ; value using the proper trim values.
                                        (0292)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0293)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0294)   ENDIF
                                        (0295)  ENDIF
                                        (0296) ENDIF ; 5.0 V Operation
                                        (0297) 
                                        (0298) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                        (0299)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0300)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0301)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0302)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0303)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0304)  ENDIF
                                        (0305) ENDIF ; 3.3 Volt Operation
                                        (0306) 
0087: 55 F8 00 MOV   [prevPrt1+205],0x0 (0307)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
008A: 55 F9 00 MOV   [prevPrt1+206],0x0 (0308)     mov  [bSSC_KEYSP], 0
008D: 71 10    OR    F,0x10             
                                        (0309) 
                                        (0310)     ;---------------------------------------
                                        (0311)     ; Initialize Crystal Oscillator and PLL
                                        (0312)     ;---------------------------------------
                                        (0313) 
                                        (0314) IF ( SELECT_32K & WAIT_FOR_32K )
                                        (0315)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                        (0316)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                        (0317)     ; is left off. Set the SleepTimer period is set to 1 sec to time the wait for
                                        (0318)     ; the ECO to stabilize.
                                        (0319)     ;
                                        (0320)     M8C_SetBank1
                                        (0321)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                        (0322)     M8C_SetBank0
                                        (0323)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                        (0324)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                        (0325)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                        (0326) .WaitFor1s:
                                        (0327)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                        (0328)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                        (0329)                                           ;   since interrupts are not globally enabled
                                        (0330) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                        (0331)     ; Either no ECO, or waiting for stable clock is to be done in main
                                        (0332)     M8C_SetBank1
008F: 62 E0 02 MOV   REG[0xE0],0x2      (0333)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
0092: 70 EF    AND   F,0xEF             
0094: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0334)     M8C_SetBank0
                                        (0335)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0336) 
                                        (0337) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                        (0338) 
                                        (0339) IF ( PLL_MODE )
                                        (0340)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
                                        (0341)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
                                        (0342)     ;
                                        (0343)     M8C_SetBank1
                                        (0344)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                        (0345)     M8C_SetBank0
                                        (0346)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                        (0347)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
                                        (0348) 
                                        (0349) .WaitFor16ms:
                                        (0350)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0351)     jz   .WaitFor16ms
                                        (0352)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
                                        (0353)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
                                        (0354)     M8C_SetBank0
                                        (0355) 
                                        (0356) IF      ( WAIT_FOR_32K )
                                        (0357) ELSE ; !( WAIT_FOR_32K )
                                        (0358)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
                                        (0359)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
                                        (0360) ENDIF ;(WAIT_FOR_32K)
                                        (0361) ENDIF ;(PLL_MODE)
                                        (0362) 
                                        (0363) 	;-------------------------------------------------------
                                        (0364)     ; Initialize Proper Drive Mode for External Clock Pin
                                        (0365)     ;-------------------------------------------------------
                                        (0366) 
                                        (0367)     ; Change EXTCLK pin from Hi-Z Analog (110b) drive mode to Hi-Z (010b) drive mode
                                        (0368) 
                                        (0369) IF (SYSCLK_SOURCE)
                                        (0370)     and reg[PRT1DM2],  ~0x10        ; Clear bit 4 of EXTCLK pin's DM2 register 
                                        (0371) ENDIF
                                        (0372)     ; EXTCLK pin is now in proper drive mode to input the external clock signal
                                        (0373) 
                                        (0374)     ;------------------------
                                        (0375)     ; Close CT leakage path.
                                        (0376)     ;------------------------
0097: 62 71 05 MOV   REG[0x71],0x5      (0377)     mov   reg[ACB00CR0], 05h
009A: 62 75 05 MOV   REG[0x75],0x5      (0378)     mov   reg[ACB01CR0], 05h
009D: 62 79 05 MOV   REG[0x79],0x5      (0379)     mov   reg[ACB02CR0], 05h
00A0: 62 7D 05 MOV   REG[0x7D],0x5      (0380)     mov   reg[ACB03CR0], 05h
00A3: 62 D1 07 MOV   REG[0xD1],0x7      
                                        (0381) 
                                        (0382) 
                                        (0383) IF	(TOOLCHAIN & HITECH)
                                        (0384)     ;---------------------------------------------
                                        (0385)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                        (0386)     ;---------------------------------------------
                                        (0387) 	global		__Lstackps
                                        (0388) 	mov     a,low __Lstackps
                                        (0389) 	swap    a,sp
                                        (0390) 
                                        (0391) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0392)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0393)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0394)     RAM_SETPAGE_CUR 0
                                        (0395)     RAM_SETPAGE_MVW 0
                                        (0396)     RAM_SETPAGE_MVR 0
                                        (0397)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0398)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0399)     ELSE
                                        (0400)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0401)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0402) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0403) ELSE
                                        (0404)     ;---------------------------------------------
                                        (0405)     ; ImageCraft Enter the Large Memory Model, if applicable
                                        (0406)     ;---------------------------------------------
                                        (0407) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0408)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00A6: 50 00    MOV   A,0x0              (0409)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00A8: 4E       SWAP  SP,A               (0410)     swap  A, SP
00A9: 62 D3 07 MOV   REG[0xD3],0x7      
00AC: 62 D0 00 MOV   REG[0xD0],0x0      
00AF: 62 D5 00 MOV   REG[0xD5],0x0      
00B2: 62 D4 00 MOV   REG[0xD4],0x0      
                                        (0411)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0412)     RAM_SETPAGE_CUR 0
                                        (0413)     RAM_SETPAGE_MVW 0
                                        (0414)     RAM_SETPAGE_MVR 0
                                        (0415) 
                                        (0416)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00B5: 71 C0    OR    F,0xC0             (0417)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0418)   ELSE
                                        (0419)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0420)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0421) ELSE
                                        (0422)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
                                        (0423)     swap  SP, A
                                        (0424) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0425) ENDIF ;	TOOLCHAIN
                                        (0426) 
                                        (0427)     ;@PSoC_BOOT_LOADCFG_UserCode_START@
                                        (0428)     ;---------------------------------------------------
                                        (0429)     ; Insert your custom code below this banner
                                        (0430)     ;---------------------------------------------------
                                        (0431) 
                                        (0432)     ;---------------------------------------------------
                                        (0433)     ; Insert your custom code above this banner
                                        (0434)     ;---------------------------------------------------
                                        (0435)     ;@PSoC_BOOT_LOADCFG_UserCode_END@ 
                                        (0436) 
                                        (0437)     ;-------------------------
                                        (0438)     ; Load Base Configuration
                                        (0439)     ;-------------------------
                                        (0440)     ; Load global parameter settings and load the user modules in the
                                        (0441)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0442)     ; to minimize start up time; (2) We may still need to play with the
                                        (0443)     ; Sleep Timer.
                                        (0444)     ;
00B7: 7C 06 71 LCALL 0x0671             (0445)     lcall LoadConfigInit
                                        (0446) 
                                        (0447)     ;-----------------------------------
                                        (0448)     ; Initialize C Run-Time Environment
                                        (0449)     ;-----------------------------------
                                        (0450) IF ( C_LANGUAGE_SUPPORT )
                                        (0451) IF ( SYSTEM_SMALL_MEMORY_MODEL )
                                        (0452)     mov  A,0                           ; clear the 'bss' segment to zero
                                        (0453)     mov  [__r0],<__bss_start
                                        (0454) BssLoop:
                                        (0455)     cmp  [__r0],<__bss_end
                                        (0456)     jz   BssDone
                                        (0457)     mvi  [__r0],A
                                        (0458)     jmp  BssLoop
                                        (0459) BssDone:
                                        (0460)     mov  A,>__idata_start              ; copy idata to data segment
                                        (0461)     mov  X,<__idata_start
                                        (0462)     mov  [__r0],<__data_start
                                        (0463) IDataLoop:
                                        (0464)     cmp  [__r0],<__data_end
                                        (0465)     jz   C_RTE_Done
                                        (0466)     push A
                                        (0467)     romx
                                        (0468)     mvi  [__r0],A
                                        (0469)     pop  A
                                        (0470)     inc  X
                                        (0471)     adc  A,0
                                        (0472)     jmp  IDataLoop
                                        (0473) 
                                        (0474) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                        (0475) 
                                        (0476) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00BA: 62 D0 00 MOV   REG[0xD0],0x0      (0477)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                        (0478)                                        ; to use the Virtual Register page.
                                        (0479) 
                                        (0480)     ; Dereference the constant (flash) pointer pXIData to access the start
                                        (0481)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                        (0482)     ; text segment and may have been relocated by the Code Compressor.
                                        (0483)     ;
00BD: 50 05    MOV   A,0x5              (0484)     mov   A, >__pXIData                ; Get the address of the flash
00BF: 57 4A    MOV   X,0x4A             (0485)     mov   X, <__pXIData                ;   pointer to the xidata area.
00C1: 08       PUSH  A                  (0486)     push  A
00C2: 28       ROMX                     (0487)     romx                               ; get the MSB of xidata's address
00C3: 53 1A    MOV   [__r0],A           (0488)     mov   [__r0], A
00C5: 18       POP   A                  (0489)     pop   A
00C6: 75       INC   X                  (0490)     inc   X
00C7: 09 00    ADC   A,0x0              (0491)     adc   A, 0
00C9: 28       ROMX                     (0492)     romx                               ; get the LSB of xidata's address
00CA: 4B       SWAP  A,X                (0493)     swap  A, X
00CB: 51 1A    MOV   A,[__r0]           (0494)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                        (0495)                                        ;   XIData structure list in flash
00CD: 80 04    JMP   0x00D2             (0496)     jmp   .AccessStruct
                                        (0497) 
                                        (0498)     ; Unpack one element in the xidata "structure list" that specifies the
                                        (0499)     ; values of C variables. Each structure contains 3 member elements.
                                        (0500)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                        (0501)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                        (0502)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                        (0503)     ; contains 0xFF. There are two formats for the struct depending on the
                                        (0504)     ; value in the second member element, an unsigned byte:
                                        (0505)     ; (1) If the value of the second element is non-zero, it represents
                                        (0506)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                        (0507)     ; third member of the struct is an array of bytes of length 'size' and
                                        (0508)     ; the bytes are copied to the block of RAM.
                                        (0509)     ; (2) If the value of the second element is zero, the block of RAM is
                                        (0510)     ; to be cleared to zero. In this case, the third member of the struct
                                        (0511)     ; is an unsigned byte containing the number of bytes to clear.
                                        (0512) 
                                        (0513) .AccessNextStructLoop:
00CF: 75       INC   X                  (0514)     inc   X                            ; pXIData++
00D0: 09 00    ADC   A,0x0              (0515)     adc   A, 0
00D2: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0516) .AccessStruct:                         ; Entry point for first block
                                        (0517)     ;
                                        (0518)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                        (0519)     ;
                                        (0520)     M8C_ClearWDT                       ; Clear the watchdog for long inits
00D5: 08       PUSH  A                  (0521)     push  A
00D6: 28       ROMX                     (0522)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
00D7: 60 D5    MOV   REG[0xD5],A        (0523)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
00D9: 74       INC   A                  (0524)     inc   A                            ; End of Struct List? (MSB==0xFF?)
00DA: A0 4B    JZ    0x0126             (0525)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
00DC: 18       POP   A                  (0526)     pop   A                            ; restore pXIData to [A,X]
00DD: 75       INC   X                  (0527)     inc   X                            ; pXIData++
00DE: 09 00    ADC   A,0x0              (0528)     adc   A, 0
00E0: 08       PUSH  A                  (0529)     push  A
00E1: 28       ROMX                     (0530)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
00E2: 53 1A    MOV   [__r0],A           (0531)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
00E4: 18       POP   A                  (0532)     pop   A                            ; restore pXIData to [A,X]
00E5: 75       INC   X                  (0533)     inc   X                            ; pXIData++ (point to size)
00E6: 09 00    ADC   A,0x0              (0534)     adc   A, 0
00E8: 08       PUSH  A                  (0535)     push  A
00E9: 28       ROMX                     (0536)     romx                               ; Get the size (CPU.A <- *pXIData)
00EA: A0 1C    JZ    0x0107             (0537)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
00EC: 53 19    MOV   [__r1],A           (0538)     mov   [__r1], A                    ;             else downcount in __r1
00EE: 18       POP   A                  (0539)     pop   A                            ; restore pXIData to [A,X]
                                        (0540) 
                                        (0541) .CopyNextByteLoop:
                                        (0542)     ; For each byte in the structure's array member, copy from flash to RAM.
                                        (0543)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                        (0544)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                        (0545)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0546)     ;
00EF: 75       INC   X                  (0547)     inc   X                            ; pXIData++ (point to next data byte)
00F0: 09 00    ADC   A,0x0              (0548)     adc   A, 0
00F2: 08       PUSH  A                  (0549)     push  A
00F3: 28       ROMX                     (0550)     romx                               ; Get the data value (CPU.A <- *pXIData)
00F4: 3F 1A    MVI   [__r0],A           (0551)     mvi   [__r0], A                    ; Transfer the data to RAM
00F6: 47 1A FF TST   [__r0],0xFF        (0552)     tst   [__r0], 0xff                 ; Check for page crossing
00F9: B0 06    JNZ   0x0100             (0553)     jnz   .CopyLoopTail                ;   No crossing, keep going
00FB: 5D D5    MOV   A,REG[0xD5]        (0554)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
00FD: 74       INC   A                  (0555)     inc   A
00FE: 60 D5    MOV   REG[0xD5],A        (0556)     mov   reg[ MVW_PP], A
                                        (0557) .CopyLoopTail:
0100: 18       POP   A                  (0558)     pop   A                            ; restore pXIData to [A,X]
0101: 7A 19    DEC   [__r1]             (0559)     dec   [__r1]                       ; End of this array in flash?
0103: BF EB    JNZ   0x00EF             (0560)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
0105: 8F C9    JMP   0x00CF             (0561)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                        (0562) 
                                        (0563) .ClearRAMBlockToZero:
0107: 18       POP   A                  (0564)     pop   A                            ; restore pXIData to [A,X]
0108: 75       INC   X                  (0565)     inc   X                            ; pXIData++ (point to next data byte)
0109: 09 00    ADC   A,0x0              (0566)     adc   A, 0
010B: 08       PUSH  A                  (0567)     push  A
010C: 28       ROMX                     (0568)     romx                               ; Get the run length (CPU.A <- *pXIData)
010D: 53 19    MOV   [__r1],A           (0569)     mov   [__r1], A                    ; Initialize downcounter
010F: 50 00    MOV   A,0x0              (0570)     mov   A, 0                         ; Initialize source data
                                        (0571) 
                                        (0572) .ClearRAMBlockLoop:
                                        (0573)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                        (0574)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0575)     ;
0111: 3F 1A    MVI   [__r0],A           (0576)     mvi   [__r0], A                    ; Clear a byte
0113: 47 1A FF TST   [__r0],0xFF        (0577)     tst   [__r0], 0xff                 ; Check for page crossing
0116: B0 08    JNZ   0x011F             (0578)     jnz   .ClearLoopTail               ;   No crossing, keep going
0118: 5D D5    MOV   A,REG[0xD5]        (0579)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
011A: 74       INC   A                  (0580)     inc   A
011B: 60 D5    MOV   REG[0xD5],A        (0581)     mov   reg[ MVW_PP], A
011D: 50 00    MOV   A,0x0              (0582)     mov   A, 0                         ; Restore the zero used for clearing
                                        (0583) .ClearLoopTail:
011F: 7A 19    DEC   [__r1]             (0584)     dec   [__r1]                       ; Was this the last byte?
0121: BF EF    JNZ   0x0111             (0585)     jnz   .ClearRAMBlockLoop           ;   No,  continue
0123: 18       POP   A                  (0586)     pop   A                            ;   Yes, restore pXIData to [A,X] and
0124: 8F AA    JMP   0x00CF             (0587)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                        (0588) 
                                        (0589) .C_RTE_WrapUp:
0126: 18       POP   A                  (0590)     pop   A                            ; balance stack
0127: 71 10    OR    F,0x10             
                                        (0591) 
                                        (0592) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                        (0593) 
                                        (0594) C_RTE_Done:
                                        (0595) 
                                        (0596) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0597) 
                                        (0598)     ;-------------------------------
                                        (0599)     ; Voltage Stabilization for SMP
                                        (0600)     ;-------------------------------
                                        (0601) 
                                        (0602) IF ( POWER_SETTING & POWER_SET_5V0)    ; 5.0V Operation
                                        (0603) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
                                        (0604)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0605)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
                                        (0606)     ; 5V before enabling the Precision Power-On Reset (PPOR).
                                        (0607)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0608)     or   reg[INT_MSK0],INT_MSK0_SLEEP
                                        (0609)     M8C_SetBank1
                                        (0610)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
                                        (0611)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
                                        (0612)     M8C_SetBank0
                                        (0613)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
                                        (0614)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
                                        (0615) .WaitFor2ms:
                                        (0616)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0617)     jz   .WaitFor2ms                       ; Branch fails when 2 msec has passed
                                        (0618) ENDIF ; SMP is operational
                                        (0619) ENDIF ; 5.0V Operation
                                        (0620) 
                                        (0621)     ;-------------------------------
                                        (0622)     ; Set Power-On Reset (POR) Level
                                        (0623)     ;-------------------------------
                                        (0624)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH, 
                                        (0625)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper 
                                        (0626)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. 
                                        (0627)     ;  These values should not be changed from the settings here. See Section "POR and LVD" of 
                                        (0628)     ;  Technical Reference Manual #001-14463 for more information.
                                        (0629) 
                                        (0630)     M8C_SetBank1
                                        (0631) 
                                        (0632) IF (POWER_SETTING & POWER_SET_5V0)          ; 5.0V Operation?
                                        (0633)  IF (POWER_SETTING & POWER_SET_SLOW_IMO)    ; and Slow Mode?
                                        (0634)  ELSE                                       ;    No, fast mode
                                        (0635)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz ) ;    As fast as 24MHz?
                                        (0636)                                             ;       no, set midpoint POR in user code, if desired
                                        (0637)   ELSE ; 24HMz                              ;
0129: 43 E3 20 OR    REG[0xE3],0x20     (0638)     or    reg[VLT_CR],  VLT_CR_POR_HIGH     ;      yes, highest POR trip point required
012C: 70 EF    AND   F,0xEF             
                                        (0639)   ENDIF ; 24MHz
                                        (0640)  ENDIF ; Slow Mode
                                        (0641) ENDIF ; 5.0V Operation
                                        (0642) 
                                        (0643)     M8C_SetBank0
                                        (0644) 
                                        (0645)     ;----------------------------
                                        (0646)     ; Wrap up and invoke "main"
                                        (0647)     ;----------------------------
                                        (0648) 
                                        (0649)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0650)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0651)     ;
012E: 62 E0 00 MOV   REG[0xE0],0x0      (0652)     mov  reg[INT_MSK0],0
0131: 71 10    OR    F,0x10             
                                        (0653) 
                                        (0654)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0655)     ; And put decimator in full mode so it does not consume too much current.
                                        (0656)     ;
                                        (0657)     M8C_SetBank1
0133: 62 E0 03 MOV   REG[0xE0],0x3      (0658)     mov  reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
0136: 43 E7 80 OR    REG[0xE7],0x80     (0659)     or   reg[DEC_CR2],80h                    ; Put decimator in full mode
0139: 70 EF    AND   F,0xEF             
                                        (0660)     M8C_SetBank0
                                        (0661) 
                                        (0662)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0663)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0664)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0665)     ;
013B: 62 E2 00 MOV   REG[0xE2],0x0      (0666)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0667)                                    ; have been set during the boot process.
                                        (0668) IF	(TOOLCHAIN & HITECH)
                                        (0669) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0670) ELSE
                                        (0671) IF ENABLE_LJMP_TO_MAIN
                                        (0672)     ljmp  _main                    ; goto main (no return)
                                        (0673) ELSE
013E: 7C 0B 0B LCALL __UserModules_end|_main|__text_start|_main(0674)     lcall _main                    ; call main
                                        (0675) .Exit:
0141: 8F FF    JMP   0x0141             (0676)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0677) ENDIF
                                        (0678) ENDIF ; TOOLCHAIN
                                        (0679) 
                                        (0680)     ;---------------------------------
                                        (0681)     ; Library Access to Global Parms
                                        (0682)     ;---------------------------------
                                        (0683)     ;
                                        (0684)  bGetPowerSetting:
                                        (0685) _bGetPowerSetting:
                                        (0686)     ; Returns value of POWER_SETTING in the A register.
                                        (0687)     ; No inputs. No Side Effects.
                                        (0688)     ;
0143: 50 10    MOV   A,0x10             (0689)     mov   A, POWER_SETTING
0145: 7F       RET                      (0690)     ret
                                        (0691) 
                                        (0692) IF	(TOOLCHAIN & HITECH)
                                        (0693) ELSE
                                        (0694)     ;---------------------------------
                                        (0695)     ; Order Critical RAM & ROM AREAs
                                        (0696)     ;---------------------------------
                                        (0697)     ;  'TOP' is all that has been defined so far...
                                        (0698) 
                                        (0699)     ;  ROM AREAs for C CONST, static & global items
                                        (0700)     ;
                                        (0701)     AREA lit               (ROM, REL, CON, LIT)   ; 'const' definitions
                                        (0702)     AREA idata             (ROM, REL, CON, LIT)   ; Constants for initializing RAM
                                        (0703) __idata_start:
                                        (0704) 
                                        (0705)     AREA func_lit          (ROM, REL, CON, proclab)   ; Function Pointers
                                        (0706) __func_lit_start:
                                        (0707) 
                                        (0708) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0709)     ; We use the func_lit area to store a pointer to extended initialized
                                        (0710)     ; data (xidata) area that follows the text area. Func_lit isn't
                                        (0711)     ; relocated by the code compressor, but the text area may shrink and
                                        (0712)     ; that moves xidata around.
                                        (0713)     ;
                                        (0714) __pXIData:         word __text_end           ; ptr to extended idata
                                        (0715) ENDIF
                                        (0716) 
                                        (0717)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
                                        (0718)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
                                        (0719) 
                                        (0720)     ; CODE segment for general use
                                        (0721)     ;
                                        (0722)     AREA text (ROM, REL, CON)
                                        (0723) __text_start:
                                        (0724) 
                                        (0725)     ; RAM area usage
                                        (0726)     ;
                                        (0727)     AREA data              (RAM, REL, CON)   ; initialized RAM
                                        (0728) __data_start:
                                        (0729) 
                                        (0730)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
                                        (0731)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
                                        (0732)     AREA bss               (RAM, REL, CON)   ; general use
                                        (0733) __bss_start:
                                        (0734) 
                                        (0735) ENDIF ; TOOLCHAIN
                                        (0736) 
                                        (0737) ; end of file boot.asm
FILE: lib\psocconfigtbl.asm             (0001) ;  Generated by PSoC Designer 5.4.2946
056C: 70 EF    AND   F,0xEF             (0002) ;
                                        (0003) ; =============================================================================
                                        (0004) ; FILENAME: PSoCConfigTBL.asm
                                        (0005) ;  
                                        (0006) ; Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0007) ;  
                                        (0008) ; NOTES:
                                        (0009) ; Do not modify this file. It is generated by PSoC Designer each time the
                                        (0010) ; generate application function is run. The values of the parameters in this
                                        (0011) ; file can be modified by changing the values of the global parameters in the
                                        (0012) ; device editor.
                                        (0013) ;  
                                        (0014) ; =============================================================================
                                        (0015)  
                                        (0016) include "m8c.inc"
                                        (0017) ;  Personalization tables 
                                        (0018) export LoadConfigTBL_kipr_2_Bank1
                                        (0019) export LoadConfigTBL_kipr_2_Bank0
                                        (0020) export LoadConfigTBL_kipr_2_Ordered
                                        (0021) AREA lit(rom, rel)
                                        (0022) LoadConfigTBL_kipr_2_Bank0:
                                        (0023) ;  Instance name ENC1A_NEDGE, User Module DigInv
                                        (0024) ;       Instance name ENC1A_NEDGE, Block Name DigInv(DBB10)
                                        (0025) 	db		33h, 00h		;ENC1A_NEDGE_CONTROL_REG(DBB10CR0)
                                        (0026) 	db		31h, 00h		;ENC1A_NEDGE_PERIOD_REG (DBB10DR1)
                                        (0027) 	db		32h, 00h		;ENC1A_NEDGE_COMPARE_REG(DBB10DR2)
                                        (0028) ;  Instance name ENC1A_PEDGE, User Module DigBuf
                                        (0029) ;       Instance name ENC1A_PEDGE, Block Name DigBuf(DBB00)
                                        (0030) 	db		23h, 03h		;ENC1A_PEDGE_CONTROL_REG(DBB00CR0)
                                        (0031) 	db		21h, 00h		;ENC1A_PEDGE_DATA_1_REG(DBB00DR1)
                                        (0032) 	db		22h, 00h		;ENC1A_PEDGE_DATA_2_REG(DBB00DR2)
                                        (0033) ;  Instance name ENC1B_NEDGE, User Module DigInv
                                        (0034) ;       Instance name ENC1B_NEDGE, Block Name DigInv(DBB21)
                                        (0035) 	db		47h, 00h		;ENC1B_NEDGE_CONTROL_REG(DBB21CR0)
                                        (0036) 	db		45h, 00h		;ENC1B_NEDGE_PERIOD_REG (DBB21DR1)
                                        (0037) 	db		46h, 00h		;ENC1B_NEDGE_COMPARE_REG(DBB21DR2)
                                        (0038) ;  Instance name ENC1B_PEDGE, User Module DigBuf
                                        (0039) ;       Instance name ENC1B_PEDGE, Block Name DigBuf(DBB11)
                                        (0040) 	db		37h, 03h		;ENC1B_PEDGE_CONTROL_REG(DBB11CR0)
                                        (0041) 	db		35h, 00h		;ENC1B_PEDGE_DATA_1_REG(DBB11DR1)
                                        (0042) 	db		36h, 00h		;ENC1B_PEDGE_DATA_2_REG(DBB11DR2)
                                        (0043) ;  Instance name PWMA, User Module PWM8
                                        (0044) ;       Instance name PWMA, Block Name PWM8(DCB03)
                                        (0045) 	db		2fh, 00h		;PWMA_CONTROL_REG(DCB03CR0)
                                        (0046) 	db		2dh, ffh		;PWMA_PERIOD_REG(DCB03DR1)
                                        (0047) 	db		2eh, 00h		;PWMA_COMPARE_REG(DCB03DR2)
                                        (0048) ;  Instance name PWMB, User Module PWM8
                                        (0049) ;       Instance name PWMB, Block Name PWM8(DBB20)
                                        (0050) 	db		43h, 00h		;PWMB_CONTROL_REG(DBB20CR0)
                                        (0051) 	db		41h, ffh		;PWMB_PERIOD_REG(DBB20DR1)
                                        (0052) 	db		42h, 00h		;PWMB_COMPARE_REG(DBB20DR2)
                                        (0053) ;  Instance name Servo0, User Module PWM16
                                        (0054) ;       Instance name Servo0, Block Name PWM16_LSB(DBB01)
                                        (0055) 	db		27h, 00h		;Servo0_CONTROL_LSB_REG(DBB01CR0)
                                        (0056) 	db		25h, 1fh		;Servo0_PERIOD_LSB_REG(DBB01DR1)
                                        (0057) 	db		26h, e7h		;Servo0_COMPARE_LSB_REG(DBB01DR2)
                                        (0058) ;       Instance name Servo0, Block Name PWM16_MSB(DCB02)
                                        (0059) 	db		2bh, 00h		;Servo0_CONTROL_MSB_REG(DCB02CR0)
                                        (0060) 	db		29h, 4eh		;Servo0_PERIOD_MSB_REG(DCB02DR1)
                                        (0061) 	db		2ah, 03h		;Servo0_COMPARE_MSB_REG(DCB02DR2)
                                        (0062) ;  Instance name Servo1, User Module PWM16
                                        (0063) ;       Instance name Servo1, Block Name PWM16_LSB(DCB22)
                                        (0064) 	db		4bh, 00h		;Servo1_CONTROL_LSB_REG(DCB22CR0)
                                        (0065) 	db		49h, 1fh		;Servo1_PERIOD_LSB_REG(DCB22DR1)
                                        (0066) 	db		4ah, e7h		;Servo1_COMPARE_LSB_REG(DCB22DR2)
                                        (0067) ;       Instance name Servo1, Block Name PWM16_MSB(DCB23)
                                        (0068) 	db		4fh, 00h		;Servo1_CONTROL_MSB_REG(DCB23CR0)
                                        (0069) 	db		4dh, 4eh		;Servo1_PERIOD_MSB_REG(DCB23DR1)
                                        (0070) 	db		4eh, 03h		;Servo1_COMPARE_MSB_REG(DCB23DR2)
                                        (0071) ;  Instance name UART, User Module UART
                                        (0072) ;       Instance name UART, Block Name RX(DCB13)
                                        (0073) 	db		3fh, 00h		;UART_RX_CONTROL_REG(DCB13CR0)
                                        (0074) 	db		3dh, 00h		;UART_(DCB13DR1)
                                        (0075) 	db		3eh, 00h		;UART_RX_BUFFER_REG (DCB13DR2)
                                        (0076) ;       Instance name UART, Block Name TX(DCB12)
                                        (0077) 	db		3bh, 00h		;UART_TX_CONTROL_REG(DCB12CR0)
                                        (0078) 	db		39h, 00h		;UART_TX_BUFFER_REG (DCB12DR1)
                                        (0079) 	db		3ah, 00h		;UART_(DCB12DR2)
                                        (0080) ;  Global Register values Bank 0
                                        (0081) 	db		60h, 28h		; AnalogColumnInputSelect register (AMX_IN)
                                        (0082) 	db		66h, 00h		; AnalogComparatorControl1 register (CMP_CR1)
                                        (0083) 	db		63h, 05h		; AnalogReferenceControl register (ARF_CR)
                                        (0084) 	db		65h, 00h		; AnalogSyncControl register (ASY_CR)
                                        (0085) 	db		e6h, 00h		; DecimatorControl_0 register (DEC_CR0)
                                        (0086) 	db		e7h, 00h		; DecimatorControl_1 register (DEC_CR1)
                                        (0087) 	db		d6h, 00h		; I2CConfig register (I2C_CFG)
                                        (0088) 	db		b0h, 10h		; Row_0_InputMux register (RDI0RI)
                                        (0089) 	db		b1h, 00h		; Row_0_InputSync register (RDI0SYN)
                                        (0090) 	db		b2h, 00h		; Row_0_LogicInputAMux register (RDI0IS)
                                        (0091) 	db		b3h, 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
                                        (0092) 	db		b4h, 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
                                        (0093) 	db		b5h, 01h		; Row_0_OutputDrive_0 register (RDI0SRO0)
                                        (0094) 	db		b6h, 10h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                        (0095) 	db		b8h, 55h		; Row_1_InputMux register (RDI1RI)
                                        (0096) 	db		b9h, 00h		; Row_1_InputSync register (RDI1SYN)
                                        (0097) 	db		bah, 10h		; Row_1_LogicInputAMux register (RDI1IS)
                                        (0098) 	db		bbh, 33h		; Row_1_LogicSelect_0 register (RDI1LT0)
                                        (0099) 	db		bch, 33h		; Row_1_LogicSelect_1 register (RDI1LT1)
                                        (0100) 	db		bdh, 10h		; Row_1_OutputDrive_0 register (RDI1SRO0)
                                        (0101) 	db		beh, 00h		; Row_1_OutputDrive_1 register (RDI1SRO1)
                                        (0102) 	db		c0h, 01h		; Row_2_InputMux register (RDI2RI)
                                        (0103) 	db		c1h, 00h		; Row_2_InputSync register (RDI2SYN)
                                        (0104) 	db		c2h, 20h		; Row_2_LogicInputAMux register (RDI2IS)
                                        (0105) 	db		c3h, 33h		; Row_2_LogicSelect_0 register (RDI2LT0)
                                        (0106) 	db		c4h, 33h		; Row_2_LogicSelect_1 register (RDI3LT1)
                                        (0107) 	db		c5h, 80h		; Row_2_OutputDrive_0 register (RDI2SRO0)
                                        (0108) 	db		c6h, 20h		; Row_2_OutputDrive_1 register (RDI2SRO1)
                                        (0109) 	db		c8h, 55h		; Row_3_InputMux register (RDI3RI)
                                        (0110) 	db		c9h, 00h		; Row_3_InputSync register (RDI3SYN)
                                        (0111) 	db		cah, 30h		; Row_3_LogicInputAMux register (RDI3IS)
                                        (0112) 	db		cbh, 33h		; Row_3_LogicSelect_0 register (RDI3LT0)
                                        (0113) 	db		cch, 33h		; Row_3_LogicSelect_1 register (RDI3LT1)
                                        (0114) 	db		cdh, 00h		; Row_3_OutputDrive_0 register (RDI3SRO0)
                                        (0115) 	db		ceh, 00h		; Row_3_OutputDrive_1 register (RDI3SRO1)
                                        (0116) 	db		6ch, 00h		; TMP_DR0 register (TMP_DR0)
                                        (0117) 	db		6dh, 00h		; TMP_DR1 register (TMP_DR1)
                                        (0118) 	db		6eh, 00h		; TMP_DR2 register (TMP_DR2)
                                        (0119) 	db		6fh, 00h		; TMP_DR3 register (TMP_DR3)
                                        (0120) 	db		ffh
                                        (0121) LoadConfigTBL_kipr_2_Bank1:
                                        (0122) ;  Instance name ENC1A_NEDGE, User Module DigInv
                                        (0123) ;       Instance name ENC1A_NEDGE, Block Name DigInv(DBB10)
                                        (0124) 	db		30h, 20h		;ENC1A_NEDGE_FUNC_REG   (DBB10FN)
                                        (0125) 	db		31h, 0eh		;ENC1A_NEDGE_INPUT_REG  (DBB10IN)
                                        (0126) 	db		32h, 40h		;ENC1A_NEDGE_OUTPUT_REG (DBB10OU)
                                        (0127) ;  Instance name ENC1A_PEDGE, User Module DigBuf
                                        (0128) ;       Instance name ENC1A_PEDGE, Block Name DigBuf(DBB00)
                                        (0129) 	db		20h, 22h		;ENC1A_PEDGE_FUNC_REG(DBB00FN)
                                        (0130) 	db		21h, e0h		;ENC1A_PEDGE_INPUT_REG(DBB00IN)
                                        (0131) 	db		22h, 40h		;ENC1A_PEDGE_OUTPUT_REG(DBB00OU)
                                        (0132) ;  Instance name ENC1B_NEDGE, User Module DigInv
                                        (0133) ;       Instance name ENC1B_NEDGE, Block Name DigInv(DBB21)
                                        (0134) 	db		44h, 20h		;ENC1B_NEDGE_FUNC_REG   (DBB21FN)
                                        (0135) 	db		45h, 0ch		;ENC1B_NEDGE_INPUT_REG  (DBB21IN)
                                        (0136) 	db		46h, 40h		;ENC1B_NEDGE_OUTPUT_REG (DBB21OU)
                                        (0137) ;  Instance name ENC1B_PEDGE, User Module DigBuf
                                        (0138) ;       Instance name ENC1B_PEDGE, Block Name DigBuf(DBB11)
                                        (0139) 	db		34h, 22h		;ENC1B_PEDGE_FUNC_REG(DBB11FN)
                                        (0140) 	db		35h, c0h		;ENC1B_PEDGE_INPUT_REG(DBB11IN)
                                        (0141) 	db		36h, 40h		;ENC1B_PEDGE_OUTPUT_REG(DBB11OU)
                                        (0142) ;  Instance name PWMA, User Module PWM8
                                        (0143) ;       Instance name PWMA, Block Name PWM8(DCB03)
                                        (0144) 	db		2ch, 21h		;PWMA_FUNC_REG(DCB03FN)
                                        (0145) 	db		2dh, 16h		;PWMA_INPUT_REG(DCB03IN)
                                        (0146) 	db		2eh, 44h		;PWMA_OUTPUT_REG(DCB03OU)
                                        (0147) ;  Instance name PWMB, User Module PWM8
                                        (0148) ;       Instance name PWMB, Block Name PWM8(DBB20)
                                        (0149) 	db		40h, 21h		;PWMB_FUNC_REG(DBB20FN)
                                        (0150) 	db		41h, 11h		;PWMB_INPUT_REG(DBA20IN)
                                        (0151) 	db		42h, 45h		;PWMB_OUTPUT_REG(DBA20OU)
                                        (0152) ;  Instance name Servo0, User Module PWM16
                                        (0153) ;       Instance name Servo0, Block Name PWM16_LSB(DBB01)
                                        (0154) 	db		24h, 01h		;Servo0_FUNC_LSB_REG(DBB01FN)
                                        (0155) 	db		25h, 16h		;Servo0_INPUT_LSB_REG(DBB01IN)
                                        (0156) 	db		26h, 40h		;Servo0_OUTPUT_LSB_REG(DBB01OU)
                                        (0157) ;       Instance name Servo0, Block Name PWM16_MSB(DCB02)
                                        (0158) 	db		28h, 21h		;Servo0_FUNC_MSB_REG(DCB02FN)
                                        (0159) 	db		29h, 36h		;Servo0_INPUT_MSB_REG(DCB02IN)
                                        (0160) 	db		2ah, 47h		;Servo0_OUTPUT_MSB_REG(DCB02OU)
                                        (0161) ;  Instance name Servo1, User Module PWM16
                                        (0162) ;       Instance name Servo1, Block Name PWM16_LSB(DCB22)
                                        (0163) 	db		48h, 01h		;Servo1_FUNC_LSB_REG(DCB22FN)
                                        (0164) 	db		49h, 16h		;Servo1_INPUT_LSB_REG(DCB22IN)
                                        (0165) 	db		4ah, 40h		;Servo1_OUTPUT_LSB_REG(DCB22OU)
                                        (0166) ;       Instance name Servo1, Block Name PWM16_MSB(DCB23)
                                        (0167) 	db		4ch, 21h		;Servo1_FUNC_MSB_REG(DCB23FN)
                                        (0168) 	db		4dh, 36h		;Servo1_INPUT_MSB_REG(DCB23IN)
                                        (0169) 	db		4eh, 47h		;Servo1_OUTPUT_MSB_REG(DCB23OU)
                                        (0170) ;  Instance name UART, User Module UART
                                        (0171) ;       Instance name UART, Block Name RX(DCB13)
                                        (0172) 	db		3ch, 05h		;UART_RX_FUNC_REG   (DCB13FN)
                                        (0173) 	db		3dh, f1h		;UART_RX_INPUT_REG  (DCB13IN)
                                        (0174) 	db		3eh, 40h		;UART_RX_OUTPUT_REG (DCB13OU)
                                        (0175) ;       Instance name UART, Block Name TX(DCB12)
                                        (0176) 	db		38h, 0dh		;UART_TX_FUNC_REG   (DCB12FN)
                                        (0177) 	db		39h, 01h		;UART_TX_INPUT_REG  (DCB12IN)
                                        (0178) 	db		3ah, 45h		;UART_TX_OUTPUT_REG (DCB12OU)
                                        (0179) ;  Global Register values Bank 1
                                        (0180) 	db		61h, 00h		; AnalogClockSelect1 register (CLK_CR1)
                                        (0181) 	db		69h, 00h		; AnalogClockSelect2 register (CLK_CR2)
                                        (0182) 	db		60h, 00h		; AnalogColumnClockSelect register (CLK_CR0)
                                        (0183) 	db		62h, 00h		; AnalogIOControl_0 register (ABF_CR0)
                                        (0184) 	db		67h, 33h		; AnalogLUTControl0 register (ALT_CR0)
                                        (0185) 	db		68h, 33h		; AnalogLUTControl1 register (ALT_CR1)
                                        (0186) 	db		63h, 00h		; AnalogModulatorControl_0 register (AMD_CR0)
                                        (0187) 	db		66h, 00h		; AnalogModulatorControl_1 register (AMD_CR1)
                                        (0188) 	db		d1h, 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
                                        (0189) 	db		d3h, 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
                                        (0190) 	db		d0h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
                                        (0191) 	db		d2h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
                                        (0192) 	db		e1h, b1h		; OscillatorControl_1 register (OSC_CR1)
                                        (0193) 	db		e2h, 00h		; OscillatorControl_2 register (OSC_CR2)
                                        (0194) 	db		dfh, 19h		; OscillatorControl_3 register (OSC_CR3)
                                        (0195) 	db		deh, 00h		; OscillatorControl_4 register (OSC_CR4)
                                        (0196) 	db		ddh, 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
                                        (0197) 	db		e7h, 00h		; Type2Decimator_Control register (DEC_CR2)
                                        (0198) 	db		ffh
                                        (0199) AREA psoc_config(rom, rel)
                                        (0200) LoadConfigTBL_kipr_2_Ordered:
                                        (0201) ;  Ordered Global Register values
                                        (0202) 	M8C_SetBank0
056E: 62 00 00 MOV   REG[0x0],0x0       (0203) 	mov	reg[00h], 00h		; Port_0_Data register (PRT0DR)
0571: 71 10    OR    F,0x10             
                                        (0204) 	M8C_SetBank1
0573: 62 00 8A MOV   REG[0x0],0x8A      (0205) 	mov	reg[00h], 8ah		; Port_0_DriveMode_0 register (PRT0DM0)
0576: 62 01 75 MOV   REG[0x1],0x75      (0206) 	mov	reg[01h], 75h		; Port_0_DriveMode_1 register (PRT0DM1)
0579: 70 EF    AND   F,0xEF             
                                        (0207) 	M8C_SetBank0
057B: 62 03 75 MOV   REG[0x3],0x75      (0208) 	mov	reg[03h], 75h		; Port_0_DriveMode_2 register (PRT0DM2)
057E: 62 02 8A MOV   REG[0x2],0x8A      (0209) 	mov	reg[02h], 8ah		; Port_0_GlobalSelect register (PRT0GS)
0581: 71 10    OR    F,0x10             
                                        (0210) 	M8C_SetBank1
0583: 62 02 00 MOV   REG[0x2],0x0       (0211) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
0586: 62 03 00 MOV   REG[0x3],0x0       (0212) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
0589: 70 EF    AND   F,0xEF             
                                        (0213) 	M8C_SetBank0
058B: 62 01 00 MOV   REG[0x1],0x0       (0214) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
058E: 62 04 00 MOV   REG[0x4],0x0       (0215) 	mov	reg[04h], 00h		; Port_1_Data register (PRT1DR)
0591: 71 10    OR    F,0x10             
                                        (0216) 	M8C_SetBank1
0593: 62 04 F0 MOV   REG[0x4],0xF0      (0217) 	mov	reg[04h], f0h		; Port_1_DriveMode_0 register (PRT1DM0)
0596: 62 05 0F MOV   REG[0x5],0xF       (0218) 	mov	reg[05h], 0fh		; Port_1_DriveMode_1 register (PRT1DM1)
0599: 70 EF    AND   F,0xEF             
                                        (0219) 	M8C_SetBank0
059B: 62 07 0F MOV   REG[0x7],0xF       (0220) 	mov	reg[07h], 0fh		; Port_1_DriveMode_2 register (PRT1DM2)
059E: 62 06 20 MOV   REG[0x6],0x20      (0221) 	mov	reg[06h], 20h		; Port_1_GlobalSelect register (PRT1GS)
05A1: 71 10    OR    F,0x10             
                                        (0222) 	M8C_SetBank1
05A3: 62 06 00 MOV   REG[0x6],0x0       (0223) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
05A6: 62 07 00 MOV   REG[0x7],0x0       (0224) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
05A9: 70 EF    AND   F,0xEF             
                                        (0225) 	M8C_SetBank0
05AB: 62 05 00 MOV   REG[0x5],0x0       (0226) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
05AE: 62 08 04 MOV   REG[0x8],0x4       (0227) 	mov	reg[08h], 04h		; Port_2_Data register (PRT2DR)
05B1: 71 10    OR    F,0x10             
                                        (0228) 	M8C_SetBank1
05B3: 62 08 07 MOV   REG[0x8],0x7       (0229) 	mov	reg[08h], 07h		; Port_2_DriveMode_0 register (PRT2DM0)
05B6: 62 09 F8 MOV   REG[0x9],0xF8      (0230) 	mov	reg[09h], f8h		; Port_2_DriveMode_1 register (PRT2DM1)
05B9: 70 EF    AND   F,0xEF             
                                        (0231) 	M8C_SetBank0
05BB: 62 0B 08 MOV   REG[0xB],0x8       (0232) 	mov	reg[0bh], 08h		; Port_2_DriveMode_2 register (PRT2DM2)
05BE: 62 0A D1 MOV   REG[0xA],0xD1      (0233) 	mov	reg[0ah], d1h		; Port_2_GlobalSelect register (PRT2GS)
05C1: 71 10    OR    F,0x10             
                                        (0234) 	M8C_SetBank1
05C3: 62 0A 28 MOV   REG[0xA],0x28      (0235) 	mov	reg[0ah], 28h		; Port_2_IntCtrl_0 register (PRT2IC0)
05C6: 62 0B 28 MOV   REG[0xB],0x28      (0236) 	mov	reg[0bh], 28h		; Port_2_IntCtrl_1 register (PRT2IC1)
05C9: 70 EF    AND   F,0xEF             
                                        (0237) 	M8C_SetBank0
05CB: 62 09 28 MOV   REG[0x9],0x28      (0238) 	mov	reg[09h], 28h		; Port_2_IntEn register (PRT2IE)
05CE: 62 0C 00 MOV   REG[0xC],0x0       (0239) 	mov	reg[0ch], 00h		; Port_3_Data register (PRT3DR)
05D1: 71 10    OR    F,0x10             
                                        (0240) 	M8C_SetBank1
05D3: 62 0C 00 MOV   REG[0xC],0x0       (0241) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
05D6: 62 0D 00 MOV   REG[0xD],0x0       (0242) 	mov	reg[0dh], 00h		; Port_3_DriveMode_1 register (PRT3DM1)
05D9: 70 EF    AND   F,0xEF             
                                        (0243) 	M8C_SetBank0
05DB: 62 0F 00 MOV   REG[0xF],0x0       (0244) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
05DE: 62 0E 00 MOV   REG[0xE],0x0       (0245) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
05E1: 71 10    OR    F,0x10             
                                        (0246) 	M8C_SetBank1
05E3: 62 0E 00 MOV   REG[0xE],0x0       (0247) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
05E6: 62 0F 00 MOV   REG[0xF],0x0       (0248) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
05E9: 70 EF    AND   F,0xEF             
                                        (0249) 	M8C_SetBank0
05EB: 62 0D 00 MOV   REG[0xD],0x0       (0250) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
05EE: 62 10 00 MOV   REG[0x10],0x0      (0251) 	mov	reg[10h], 00h		; Port_4_Data register (PRT4DR)
05F1: 71 10    OR    F,0x10             
                                        (0252) 	M8C_SetBank1
05F3: 62 10 00 MOV   REG[0x10],0x0      (0253) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
05F6: 62 11 00 MOV   REG[0x11],0x0      (0254) 	mov	reg[11h], 00h		; Port_4_DriveMode_1 register (PRT4DM1)
05F9: 70 EF    AND   F,0xEF             
                                        (0255) 	M8C_SetBank0
05FB: 62 13 00 MOV   REG[0x13],0x0      (0256) 	mov	reg[13h], 00h		; Port_4_DriveMode_2 register (PRT4DM2)
05FE: 62 12 00 MOV   REG[0x12],0x0      (0257) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
0601: 71 10    OR    F,0x10             
                                        (0258) 	M8C_SetBank1
0603: 62 12 00 MOV   REG[0x12],0x0      (0259) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
0606: 62 13 00 MOV   REG[0x13],0x0      (0260) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
0609: 70 EF    AND   F,0xEF             
                                        (0261) 	M8C_SetBank0
060B: 62 11 00 MOV   REG[0x11],0x0      (0262) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
060E: 62 14 00 MOV   REG[0x14],0x0      (0263) 	mov	reg[14h], 00h		; Port_5_Data register (PRT5DR)
0611: 71 10    OR    F,0x10             
                                        (0264) 	M8C_SetBank1
0613: 62 14 00 MOV   REG[0x14],0x0      (0265) 	mov	reg[14h], 00h		; Port_5_DriveMode_0 register (PRT5DM0)
0616: 62 15 00 MOV   REG[0x15],0x0      (0266) 	mov	reg[15h], 00h		; Port_5_DriveMode_1 register (PRT5DM1)
0619: 70 EF    AND   F,0xEF             
                                        (0267) 	M8C_SetBank0
061B: 62 17 00 MOV   REG[0x17],0x0      (0268) 	mov	reg[17h], 00h		; Port_5_DriveMode_2 register (PRT5DM2)
061E: 62 16 00 MOV   REG[0x16],0x0      (0269) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
0621: 71 10    OR    F,0x10             
                                        (0270) 	M8C_SetBank1
0623: 62 16 00 MOV   REG[0x16],0x0      (0271) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
0626: 62 17 00 MOV   REG[0x17],0x0      (0272) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
0629: 70 EF    AND   F,0xEF             
                                        (0273) 	M8C_SetBank0
062B: 62 15 00 MOV   REG[0x15],0x0      (0274) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
062E: 62 18 00 MOV   REG[0x18],0x0      (0275) 	mov	reg[18h], 00h		; Port_6_Data register (PRT6DR)
0631: 71 10    OR    F,0x10             
                                        (0276) 	M8C_SetBank1
0633: 62 18 00 MOV   REG[0x18],0x0      (0277) 	mov	reg[18h], 00h		; Port_6_DriveMode_0 register (PRT6DM0)
0636: 62 19 00 MOV   REG[0x19],0x0      (0278) 	mov	reg[19h], 00h		; Port_6_DriveMode_1 register (PRT6DM1)
0639: 70 EF    AND   F,0xEF             
                                        (0279) 	M8C_SetBank0
063B: 62 1B 00 MOV   REG[0x1B],0x0      (0280) 	mov	reg[1bh], 00h		; Port_6_DriveMode_2 register (PRT6DM2)
063E: 62 1A 00 MOV   REG[0x1A],0x0      (0281) 	mov	reg[1ah], 00h		; Port_6_GlobalSelect register (PRT6GS)
0641: 71 10    OR    F,0x10             
                                        (0282) 	M8C_SetBank1
0643: 62 1A 00 MOV   REG[0x1A],0x0      (0283) 	mov	reg[1ah], 00h		; Port_6_IntCtrl_0 register (PRT6IC0)
0646: 62 1B 00 MOV   REG[0x1B],0x0      (0284) 	mov	reg[1bh], 00h		; Port_6_IntCtrl_1 register (PRT6IC1)
0649: 70 EF    AND   F,0xEF             
                                        (0285) 	M8C_SetBank0
064B: 62 19 00 MOV   REG[0x19],0x0      (0286) 	mov	reg[19h], 00h		; Port_6_IntEn register (PRT6IE)
064E: 62 1C 00 MOV   REG[0x1C],0x0      (0287) 	mov	reg[1ch], 00h		; Port_7_Data register (PRT7DR)
0651: 71 10    OR    F,0x10             
                                        (0288) 	M8C_SetBank1
0653: 62 1C 00 MOV   REG[0x1C],0x0      (0289) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
0656: 62 1D 00 MOV   REG[0x1D],0x0      (0290) 	mov	reg[1dh], 00h		; Port_7_DriveMode_1 register (PRT7DM1)
0659: 70 EF    AND   F,0xEF             
                                        (0291) 	M8C_SetBank0
065B: 62 1F 00 MOV   REG[0x1F],0x0      (0292) 	mov	reg[1fh], 00h		; Port_7_DriveMode_2 register (PRT7DM2)
065E: 62 1E 00 MOV   REG[0x1E],0x0      (0293) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
0661: 71 10    OR    F,0x10             
                                        (0294) 	M8C_SetBank1
0663: 62 1E 00 MOV   REG[0x1E],0x0      (0295) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
0666: 62 1F 00 MOV   REG[0x1F],0x0      (0296) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
0669: 70 EF    AND   F,0xEF             
                                        (0297) 	M8C_SetBank0
066B: 62 1D 00 MOV   REG[0x1D],0x0      (0298) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
066E: 70 EF    AND   F,0xEF             
                                        (0299) 	M8C_SetBank0
0670: 7F       RET                      (0300) 	ret
                                        (0301) 
                                        (0302) 
                                        (0303) ; PSoC Configuration file trailer PsocConfig.asm
FILE: lib\psocconfig.asm                (0001) ;  Generated by PSoC Designer 5.4.2946
                                        (0002) ;
                                        (0003) ;==========================================================================
                                        (0004) ;  PSoCConfig.asm
                                        (0005) ;  @PSOC_VERSION
                                        (0006) ;
                                        (0007) ;  Version: 0.85
                                        (0008) ;  Revised: June 22, 2004
                                        (0009) ;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;
                                        (0011) ;  This file is generated by the Device Editor on Application Generation.
                                        (0012) ;  It contains code which loads the configuration data table generated in
                                        (0013) ;  the file PSoCConfigTBL.asm
                                        (0014) ;
                                        (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                        (0016) ;  Edits to this file will not be preserved.
                                        (0017) ;==========================================================================
                                        (0018) ;
                                        (0019) include "m8c.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "GlobalParams.inc"
                                        (0022) 
                                        (0023) export LoadConfigInit
                                        (0024) export _LoadConfigInit
                                        (0025) export LoadConfig_kipr_2
                                        (0026) export _LoadConfig_kipr_2
                                        (0027) 
                                        (0028) export NO_SHADOW
                                        (0029) export _NO_SHADOW
                                        (0030) 
                                        (0031) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0032) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0033) 
                                        (0034) AREA psoc_config(rom, rel)
                                        (0035) 
                                        (0036) ;---------------------------------------------------------------------------
                                        (0037) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0038) ;                  parameters handled by boot code, like CPU speed). This
                                        (0039) ;                  function can be called from user code, but typically it
                                        (0040) ;                  is only called from boot.
                                        (0041) ;
                                        (0042) ;       INPUTS: None.
                                        (0043) ;      RETURNS: Nothing.
                                        (0044) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0045) ;               In the large memory model currently only the page
                                        (0046) ;               pointer registers listed below are modified.  This does
                                        (0047) ;               not guarantee that in future implementations of this
                                        (0048) ;               function other page pointer registers will not be
                                        (0049) ;               modified.
                                        (0050) ;          
                                        (0051) ;               Page Pointer Registers Modified: 
                                        (0052) ;               CUR_PP
                                        (0053) ;
                                        (0054) _LoadConfigInit:
                                        (0055)  LoadConfigInit:
                                        (0056)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0057)     
0671: 7C 06 78 LCALL 0x0678             (0058) 	lcall	LoadConfig_kipr_2
0674: 7C 05 6C LCALL 0x056C             (0059) 	lcall	LoadConfigTBL_kipr_2_Ordered
                                        (0060) 
                                        (0061) 
                                        (0062)     RAM_EPILOGUE RAM_USE_CLASS_4
0677: 7F       RET                      (0063)     ret
                                        (0064) 
                                        (0065) ;---------------------------------------------------------------------------
                                        (0066) ; Load Configuration kipr_2
                                        (0067) ;
                                        (0068) ;    Load configuration registers for kipr_2.
                                        (0069) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0070) ;
                                        (0071) ;       INPUTS: None.
                                        (0072) ;      RETURNS: Nothing.
                                        (0073) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0074) ;               modified as may the Page Pointer registers!
                                        (0075) ;               In the large memory model currently only the page
                                        (0076) ;               pointer registers listed below are modified.  This does
                                        (0077) ;               not guarantee that in future implementations of this
                                        (0078) ;               function other page pointer registers will not be
                                        (0079) ;               modified.
                                        (0080) ;          
                                        (0081) ;               Page Pointer Registers Modified: 
                                        (0082) ;               CUR_PP
                                        (0083) ;
                                        (0084) _LoadConfig_kipr_2:
                                        (0085)  LoadConfig_kipr_2:
                                        (0086)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0087) 
0678: 10       PUSH  X                  (0088) 	push	x
0679: 70 EF    AND   F,0xEF             
                                        (0089)     M8C_SetBank0                    ; Force bank 0
067B: 50 00    MOV   A,0x0              (0090)     mov     a, 0                    ; Specify bank 0
067D: 67       ASR   A                  (0091)     asr     a                       ; Store in carry flag
                                        (0092)                                     ; Load bank 0 table:
067E: 50 03    MOV   A,0x3              (0093)     mov     A, >LoadConfigTBL_kipr_2_Bank0
0680: 57 45    MOV   X,0x45             (0094)     mov     X, <LoadConfigTBL_kipr_2_Bank0
0682: 7C 06 93 LCALL 0x0693             (0095)     lcall   LoadConfig              ; Load the bank 0 values
                                        (0096) 
0685: 50 01    MOV   A,0x1              (0097)     mov     a, 1                    ; Specify bank 1
0687: 67       ASR   A                  (0098)     asr     a                       ; Store in carry flag
                                        (0099)                                     ; Load bank 1 table:
0688: 50 03    MOV   A,0x3              (0100)     mov     A, >LoadConfigTBL_kipr_2_Bank1
068A: 57 DC    MOV   X,0xDC             (0101)     mov     X, <LoadConfigTBL_kipr_2_Bank1
068C: 7C 06 93 LCALL 0x0693             (0102)     lcall   LoadConfig              ; Load the bank 1 values
068F: 70 EF    AND   F,0xEF             
                                        (0103) 
                                        (0104)     M8C_SetBank0                    ; Force return to bank 0
0691: 20       POP   X                  (0105) 	pop		x
                                        (0106) 
                                        (0107)     RAM_EPILOGUE RAM_USE_CLASS_4
0692: 7F       RET                      (0108)     ret
                                        (0109) 
                                        (0110) 
                                        (0111) 
                                        (0112) 
                                        (0113) ;---------------------------------------------------------------------------
                                        (0114) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
                                        (0115) ;              pairs. Terminate on address=0xFF.
                                        (0116) ;
                                        (0117) ;  INPUTS:  [A,X] points to the table to be loaded
                                        (0118) ;           Flag Register Carry bit encodes the Register Bank
                                        (0119) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
                                        (0120) ;
                                        (0121) ;  RETURNS: nothing.
                                        (0122) ;
                                        (0123) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
                                        (0124) ;                X-3 Temporary store for register address
                                        (0125) ;                X-2 LSB of config table address
                                        (0126) ;                X-1 MSB of config table address
                                        (0127) ;
                                        (0128) LoadConfig:
                                        (0129)     RAM_PROLOGUE RAM_USE_CLASS_2
0693: 38 02    ADD   SP,0x2             (0130)     add     SP, 2                   ; Set up local vars
0695: 10       PUSH  X                  (0131)     push    X                       ; Save config table address on stack
0696: 08       PUSH  A                  (0132)     push    A
0697: 4F       MOV   X,SP               (0133)     mov     X, SP
0698: 56 FC 00 MOV   [X-4],0x0          (0134)     mov     [X-4], 0                ; Set default Destination to Bank 0
069B: D0 04    JNC   0x06A0             (0135)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
069D: 56 FC 01 MOV   [X-4],0x1          (0136)     mov     [X-4], 1                ; No Carry: default to Bank 1
                                        (0137) .BankSelectSaved:
06A0: 18       POP   A                  (0138)     pop     A
06A1: 20       POP   X                  (0139)     pop     X
06A2: 70 EF    AND   F,0xEF             
06A4: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0140) 
                                        (0141) LoadConfigLp:
                                        (0142)     M8C_SetBank0                    ; Switch to bank 0
                                        (0143)     M8C_ClearWDT                    ; Clear the watchdog for long inits
06A7: 10       PUSH  X                  (0144)     push    X                       ; Preserve the config table address
06A8: 08       PUSH  A                  (0145)     push    A
06A9: 28       ROMX                     (0146)     romx                            ; Load register address from table
06AA: 39 FF    CMP   A,0xFF             (0147)     cmp     A, END_CONFIG_TABLE     ; End of table?
06AC: A0 1F    JZ    0x06CC             (0148)     jz      EndLoadConfig           ;   Yes, go wrap it up
06AE: 4F       MOV   X,SP               (0149)     mov     X, SP                   ;
06AF: 48 FC 01 TST   [X-4],0x1          (0150)     tst     [X-4], 1                ; Loading IO Bank 1?
06B2: A0 03    JZ    0x06B6             (0151)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
06B4: 71 10    OR    F,0x10             
                                        (0152)     M8C_SetBank1                    ;   Yes, switch to Bank 1
                                        (0153) .IOBankNowSet:
06B6: 54 FD    MOV   [X-3],A            (0154)     mov     [X-3], A                ; Stash the register address
06B8: 18       POP   A                  (0155)     pop     A                       ; Retrieve the table address
06B9: 20       POP   X                  (0156)     pop     X
06BA: 75       INC   X                  (0157)     inc     X                       ; Advance to the data byte
06BB: 09 00    ADC   A,0x0              (0158)     adc     A, 0
06BD: 10       PUSH  X                  (0159)     push    X                       ; Save the config table address again
06BE: 08       PUSH  A                  (0160)     push    A
06BF: 28       ROMX                     (0161)     romx                            ; load config data from the table
06C0: 4F       MOV   X,SP               (0162)     mov     X, SP                   ; retrieve the register address
06C1: 59 FD    MOV   X,[X-3]            (0163)     mov     X, [X-3]
06C3: 61 00    MOV   REG[X+0x0],A       (0164)     mov     reg[X], A               ; Configure the register
06C5: 18       POP   A                  (0165)     pop     A                       ; retrieve the table address
06C6: 20       POP   X                  (0166)     pop     X
06C7: 75       INC   X                  (0167)     inc     X                       ; advance to next table entry
06C8: 09 00    ADC   A,0x0              (0168)     adc     A, 0
06CA: 8F D7    JMP   0x06A2             (0169)     jmp     LoadConfigLp            ; loop to configure another register
                                        (0170) EndLoadConfig:
06CC: 38 FC    ADD   SP,0xFC            (0171)     add     SP, -4
06CE: 70 3F    AND   F,0x3F             
06D0: 71 C0    OR    F,0xC0             
                                        (0172)     RAM_EPILOGUE RAM_USE_CLASS_2
06D2: 7F       RET                      (0173)     ret
                                        (0174) 
                                        (0175) AREA InterruptRAM(ram, rel)
                                        (0176) 
                                        (0177) NO_SHADOW:
                                        (0178) _NO_SHADOW:
FILE: lib\uartint.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   UARTINT.asm
                                        (0004) ;;  Version: 5.3, Updated on 2014/7/14 at 8:16:55
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  UART Interrupt Service Routine.
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) 
                                        (0014) include "UART.inc"
                                        (0015) include "memory.inc"
                                        (0016) include "m8c.inc"
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _UART_TX_ISR
                                        (0022) export  _UART_RX_ISR
                                        (0023) 
                                        (0024) IF (UART_RXBUF_ENABLE)
                                        (0025) export  UART_aRxBuffer
                                        (0026) export _UART_aRxBuffer
                                        (0027) export  UART_bRxCnt
                                        (0028) export _UART_bRxCnt
                                        (0029) export  UART_fStatus
                                        (0030) export _UART_fStatus
                                        (0031) ENDIF
                                        (0032) 
                                        (0033) 
                                        (0034) ;-----------------------------------------------
                                        (0035) ; Variable Allocation
                                        (0036) ;-----------------------------------------------
                                        (0037) AREA InterruptRAM (RAM, REL, CON)
                                        (0038) 
                                        (0039) IF (UART_RXBUF_ENABLE)
                                        (0040)  UART_fStatus:
                                        (0041) _UART_fStatus:      BLK  1
                                        (0042)  UART_bRxCnt:
                                        (0043) _UART_bRxCnt:       BLK  1
                                        (0044) AREA UART_RAM (RAM, REL, CON)
                                        (0045)  UART_aRxBuffer:
                                        (0046) _UART_aRxBuffer:    BLK UART_RX_BUFFER_SIZE
                                        (0047) ENDIF
                                        (0048) 
                                        (0049) AREA InterruptRAM (RAM, REL, CON)
                                        (0050) 
                                        (0051) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0052) ;---------------------------------------------------
                                        (0053) ; Insert your custom declarations below this banner
                                        (0054) ;---------------------------------------------------
                                        (0055) 
                                        (0056) ;------------------------
                                        (0057) ;  Includes
                                        (0058) ;------------------------
                                        (0059) 
                                        (0060) 
                                        (0061) ;------------------------
                                        (0062) ;  Constant Definitions
                                        (0063) ;------------------------
                                        (0064) 
                                        (0065) 
                                        (0066) ;------------------------
                                        (0067) ; Variable Allocation
                                        (0068) ;------------------------
                                        (0069) 
                                        (0070) 
                                        (0071) ;---------------------------------------------------
                                        (0072) ; Insert your custom declarations above this banner
                                        (0073) ;---------------------------------------------------
                                        (0074) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0075) 
                                        (0076) 
                                        (0077) AREA UserModules (ROM, REL, CON)
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;  FUNCTION NAME: _UART_TX_ISR
                                        (0081) ;
                                        (0082) ;  DESCRIPTION:
                                        (0083) ;     UART TX interrupt handler for instance UART.
                                        (0084) ;
                                        (0085) ;     This is a place holder function.  If the user requires use of an interrupt
                                        (0086) ;     handler for this function, then place code where specified.
                                        (0087) ;-----------------------------------------------------------------------------
                                        (0088) 
                                        (0089) _UART_TX_ISR:
                                        (0090)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0091)    ;---------------------------------------------------
                                        (0092)    ; Insert your custom assembly code below this banner
                                        (0093)    ;---------------------------------------------------
                                        (0094)    ;   NOTE: interrupt service routines must preserve
                                        (0095)    ;   the values of the A and X CPU registers.
                                        (0096)    
                                        (0097)    ;---------------------------------------------------
                                        (0098)    ; Insert your custom assembly code above this banner
                                        (0099)    ;---------------------------------------------------
                                        (0100)    
                                        (0101)    ;---------------------------------------------------
                                        (0102)    ; Insert a lcall to a C function below this banner
                                        (0103)    ; and un-comment the lines between these banners
                                        (0104)    ;---------------------------------------------------
                                        (0105)    
                                        (0106)    ;PRESERVE_CPU_CONTEXT
                                        (0107)    ;lcall _My_C_Function
                                        (0108)    ;RESTORE_CPU_CONTEXT
                                        (0109)    
                                        (0110)    ;---------------------------------------------------
                                        (0111)    ; Insert a lcall to a C function above this banner
                                        (0112)    ; and un-comment the lines between these banners
                                        (0113)    ;---------------------------------------------------
                                        (0114)    ;@PSoC_UserCode_END@ (Do not change this line.)
06D3: 7E       RETI                     (0115)    reti
                                        (0116) 
                                        (0117) 
                                        (0118) ;-----------------------------------------------------------------------------
                                        (0119) ;  FUNCTION NAME: _UART_RX_ISR
                                        (0120) ;
                                        (0121) ;  DESCRIPTION:
                                        (0122) ;     UART RX interrupt handler for instance UART.
                                        (0123) ;     This ISR handles the background processing of received characters if
                                        (0124) ;     the buffer is enabled.
                                        (0125) ;
                                        (0126) ;
                                        (0127) ;  The following assumes that the RX buffer feature has been enabled.
                                        (0128) ;
                                        (0129) ;  SIDE EFFECTS:
                                        (0130) ;     There are 3 posible errors that may occur with the serial port.
                                        (0131) ;      1) Parity Error
                                        (0132) ;      2) Framing Error
                                        (0133) ;      3) OverRun Error
                                        (0134) ;
                                        (0135) ;  This user module check for parity and framing error.  If either of these
                                        (0136) ;  two errors are detected, the data is read and ignored.  When an overRun
                                        (0137) ;  error occurs, the last byte was lost, but the current byte is valid.  For
                                        (0138) ;  this reason this error is ignored at this time.  Code could be added to
                                        (0139) ;  this ISR to set a flag if an error condition occurs.
                                        (0140) ;
                                        (0141) ;  THEORY of OPERATION:
                                        (0142) ;     When using the RX buffer feature, the ISR collects received characters
                                        (0143) ;     in a buffer until the user defined command terminator is detected.  After
                                        (0144) ;     the command terminator is detected, the command bit is set and all other
                                        (0145) ;     characters will be ignored until the command bit is reset.  Up to
                                        (0146) ;     buffer_size - 1 characters will be collected waiting for a command
                                        (0147) ;     terminator.  After that, the characters will be discarded, although
                                        (0148) ;     a command determinator will still cause the command bit to be set.
                                        (0149) ;
                                        (0150) ;-----------------------------------------------------------------------------
                                        (0151) _UART_RX_ISR:
                                        (0152) 
                                        (0153)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                        (0154)    ;---------------------------------------------------
                                        (0155)    ; Insert your custom assembly code below this banner
                                        (0156)    ;---------------------------------------------------
                                        (0157)    ;   NOTE: interrupt service routines must preserve
                                        (0158)    ;   the values of the A and X CPU registers.
                                        (0159)    
                                        (0160)    ;---------------------------------------------------
                                        (0161)    ; Insert your custom assembly code above this banner
                                        (0162)    ;---------------------------------------------------
                                        (0163)    
                                        (0164)    ;---------------------------------------------------
                                        (0165)    ; Insert a lcall to a C function below this banner
                                        (0166)    ; and un-comment the lines between these banners
                                        (0167)    ;---------------------------------------------------
                                        (0168)    
                                        (0169)    ;PRESERVE_CPU_CONTEXT
                                        (0170)    ;lcall _My_C_Function
                                        (0171)    ;RESTORE_CPU_CONTEXT
                                        (0172)    
                                        (0173)    ;---------------------------------------------------
                                        (0174)    ; Insert a lcall to a C function above this banner
                                        (0175)    ; and un-comment the lines between these banners
                                        (0176)    ;---------------------------------------------------
                                        (0177)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0178) 
                                        (0179) IF (UART_RXBUF_ENABLE)
06D4: 08       PUSH  A                  (0180)    push A
06D5: 10       PUSH  X                  (0181)    push X
06D6: 5D D3    MOV   A,REG[0xD3]        
06D8: 08       PUSH  A                  
                                        (0182)    
                                        (0183)    IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0184)       REG_PRESERVE IDX_PP
                                        (0185)    ENDIF
                                        (0186)    
06D9: 58 01    MOV   X,[0x1]            (0187)    mov  X,[UART_bRxCnt]                                    ; Load X with byte counter
06DB: 5D 3F    MOV   A,REG[0x3F]        (0188)    mov  A,REG[UART_RX_CONTROL_REG]                         ; Read the control register
06DD: 08       PUSH  A                  (0189)    push A                                                  ; Store copy for later test
                                        (0190)                                                            ; IF real RX interrupt
06DE: 21 08    AND   A,0x8              (0191)    and  A,UART_RX_REG_FULL                                 ; Did really really get an IRQ
06E0: B0 04    JNZ   0x06E5             (0192)    jnz  .UARTRX_ReadRx                                     ; Data ready, go get it
06E2: 18       POP   A                  (0193)    pop  A                                                  ; Restore stack
06E3: 80 5E    JMP   0x0742             (0194)    jmp  .RESTORE_IDX_PP
                                        (0195) 
                                        (0196) .UARTRX_ReadRx:
06E5: 18       POP   A                  (0197)    pop  A                                                  ; Restore status flags
                                        (0198)                                                            ; IF there is no error, get data
                                        (0199)                                                            ; Check for parity or framing error
06E6: 21 E0    AND   A,0xE0             (0200)    and  A,UART_RX_ERROR
06E8: A0 12    JZ    0x06FB             (0201)    jz   .UARTRX_NO_ERROR                                   ; If there is not an Error go read data
                                        (0202) 
06EA: 2C 00    OR    [0x0],A            (0203)    or   [UART_fStatus],A                                   ; Set error flags (parity,framing,overrun) bits
06EC: 49 3E 00 TST   REG[0x3E],0x0      (0204)    tst  REG[UART_RX_BUFFER_REG], 0x00                      ; Read the data buffer to clear it.
06EF: 21 20    AND   A,0x20             (0205)    and  A,UART_RX_FRAMING_ERROR                            ; Check for framing error special case
06F1: A0 50    JZ    0x0742             (0206)    jz   .RESTORE_IDX_PP                                    ; Not framing error, all done
                                        (0207) 
                                        (0208)                                                            ; Disable and re-enable RX to reset after
                                        (0209)                                                            ; framing error.
06F3: 41 3F FE AND   REG[0x3F],0xFE     (0210)    and   REG[UART_RX_CONTROL_REG], ~UART_RX_ENABLE         ; Disable RX
06F6: 43 3F 01 OR    REG[0x3F],0x1      (0211)    or    REG[UART_RX_CONTROL_REG],  UART_RX_ENABLE         ; Enable RX
06F9: 80 48    JMP   0x0742             (0212)    jmp  .RESTORE_IDX_PP                                    ; Done with framing error, leave.
                                        (0213) 
                                        (0214) 
                                        (0215) .UARTRX_NO_ERROR:
06FB: 5D 3E    MOV   A,REG[0x3E]        (0216)    mov  A,REG[UART_RX_BUFFER_REG ]                         ; Read the data buffer
                                        (0217) 
                                        (0218)                                                            ; IF buffer not full
06FD: 47 00 01 TST   [0x0],0x1          (0219)    tst  [UART_fStatus],UART_RX_BUF_CMDTERM                 ; Check for buffer full
0700: B0 41    JNZ   0x0742             (0220)    jnz  .RESTORE_IDX_PP                                    ; All done
                                        (0221) 
0702: 39 07    CMP   A,0x7              (0222)    cmp  A,UART_CMD_TERM                                    ; Check for End of command
0704: B0 14    JNZ   0x0719             (0223)    jnz  .UARTRX_CHK_BACKSPACE
0706: 2E 00 01 OR    [0x0],0x1          (0224)    or   [UART_fStatus],UART_RX_BUF_CMDTERM                 ; Set command ready bit
0709: 62 D3 00 MOV   REG[0xD3],0x0      
070C: 70 3F    AND   F,0x3F             
070E: 71 80    OR    F,0x80             
                                        (0225) 
                                        (0226) 
                                        (0227) 
                                        (0228)    RAM_SETPAGE_IDX >UART_aRxBuffer
                                        (0229)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
0710: 56 02 00 MOV   [X+2],0x0          (0230)    mov  [X + UART_aRxBuffer],00h                           ; Zero out last data
0713: 70 3F    AND   F,0x3F             
0715: 71 00    OR    F,0x0              
                                        (0231)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
0717: 80 2A    JMP   0x0742             (0232)    jmp  .RESTORE_IDX_PP
                                        (0233) 
                                        (0234) .UARTRX_CHK_BACKSPACE:                                     ; 
                                        (0235) IF(UART_BACKSPACE_ENABLE)                                  ; Enable if backspace/delete mode
                                        (0236)    cmp  A,UART_BACKSPACE_ENABLE                            ; Check for backspace character
                                        (0237)    jnz  .UARTRX_IGNORE                                     ; If not, skip the backspace stuff
                                        (0238)    cmp  [UART_bRxCnt],00h                                  ; Check if buffer empty
                                        (0239)    jz   .RESTORE_IDX_PP                                    ; 
                                        (0240)    dec  [UART_bRxCnt]                                      ; Decrement buffer count by one.
                                        (0241)    jmp  .RESTORE_IDX_PP
                                        (0242) ENDIF                                                      ; 
                                        (0243) 
                                        (0244) .UARTRX_IGNORE:
                                        (0245) IF(UART_RX_IGNORE_BELOW)                                   ; Ignore charaters below this value
0719: 39 20    CMP   A,0x20             (0246)    cmp  A,UART_RX_IGNORE_BELOW                             ; If ignore char is set to 0x00, do not
071B: C0 26    JC    0x0742             (0247)    jc   .RESTORE_IDX_PP                                    ; ignore any characters.
071D: 62 D3 00 MOV   REG[0xD3],0x0      
                                        (0248) ENDIF
                                        (0249) 
                                        (0250) .UARTRX_CHK_OVFL:                                          ; Check for MAX String here
                                        (0251) 	
                                        (0252)    RAM_SETPAGE_IDX >UART_aRxBuffer                         ;   using idexed address mode
0720: 3C 01 0F CMP   [0x1],0xF          (0253)    cmp  [UART_bRxCnt],(UART_RX_BUFFER_SIZE - 1)
0723: C0 11    JC    0x0735             (0254)    jc   .UARTRX_ISR_GETDATA
0725: 70 3F    AND   F,0x3F             
0727: 71 80    OR    F,0x80             
                                        (0255)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
0729: 56 02 00 MOV   [X+2],0x0          (0256)    mov  [X + UART_aRxBuffer],00h                           ; Zero out last data in the buffer
072C: 70 3F    AND   F,0x3F             
072E: 71 00    OR    F,0x0              
                                        (0257)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
0730: 2E 00 10 OR    [0x0],0x10         (0258)    or   [UART_fStatus],UART_RX_BUF_OVERRUN                 ; Set error flags (parity,framing,overrun) bits
0733: 80 0E    JMP   0x0742             (0259)    jmp  .RESTORE_IDX_PP
0735: 70 3F    AND   F,0x3F             
0737: 71 80    OR    F,0x80             
                                        (0260) 
                                        (0261) .UARTRX_ISR_GETDATA:                                       ; IF input data == "CR", then end of command
                                        (0262)                                                            ; X is already loaded with pointer
                                        (0263)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
0739: 54 02    MOV   [X+2],A            (0264)    mov  [X+UART_aRxBuffer],A                               ; store data in array
073B: 70 3F    AND   F,0x3F             
073D: 71 00    OR    F,0x0              
                                        (0265)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
073F: 75       INC   X                  (0266)    inc  X                                                  ; Inc the pointer
0740: 5A 01    MOV   [0x1],X            (0267)    mov  [UART_bRxCnt],X                                    ; Restore the pointer
0742: 18       POP   A                  
0743: 60 D3    MOV   REG[0xD3],A        
                                        (0268)                                                            ; ENDIF max string size
                                        (0269) .RESTORE_IDX_PP:
                                        (0270)    IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0271)       REG_RESTORE IDX_PP
                                        (0272)    ENDIF
                                        (0273) 
                                        (0274) .END_UARTRX_ISR:
0745: 20       POP   X                  (0275)    pop  X
0746: 18       POP   A                  (0276)    pop  A
                                        (0277) 
                                        (0278) ENDIF
                                        (0279) 
                                        (0280) UART_RX_ISR_END:
0747: 7E       RETI                     (0281)    reti
                                        (0282) 
                                        (0283) ; end of file UARTINT.asm
                                        (0284) 
FILE: lib\uart.asm                      (0001) ;;*****************************************************************************
0748: 43 E1 40 OR    REG[0xE1],0x40     (0002) ;;*****************************************************************************
074B: 43 E1 80 OR    REG[0xE1],0x80     
                                        (0003) ;;  Filename:   UART.asm
                                        (0004) ;;  Version: 5.3, Updated on 2014/7/14 at 8:16:55
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  UART User Module software implementation file for the
                                        (0008) ;;                22/24/25/26/27xxx families.
                                        (0009) ;;
                                        (0010) ;;
                                        (0011) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0012) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0013) ;;        This means it is the caller's responsibility to preserve any values
                                        (0014) ;;        in the X and A registers that are still needed after the API functions
                                        (0015) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0016) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0017) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0018) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0019) ;;-----------------------------------------------------------------------------
                                        (0020) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0021) ;;*****************************************************************************
                                        (0022) ;;*****************************************************************************
                                        (0023) 
                                        (0024) 
                                        (0025) include "m8c.inc"
                                        (0026) include "memory.inc"
                                        (0027) include "UART.inc"
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ;  Global Symbols
                                        (0031) ;-----------------------------------------------
                                        (0032) ;-------------------------------------------------------------------
                                        (0033) ;  Declare the functions global for both assembler and C compiler.
                                        (0034) ;
                                        (0035) ;  Note that there are two names for each API. First name is
                                        (0036) ;  assembler reference. Name with underscore is name refence for
                                        (0037) ;  C compiler.  Calling function in C source code does not require
                                        (0038) ;  the underscore.
                                        (0039) ;-------------------------------------------------------------------
                                        (0040) export  UART_SetTxIntMode
                                        (0041) export _UART_SetTxIntMode
                                        (0042) export  UART_EnableInt
                                        (0043) export _UART_EnableInt
                                        (0044) export  UART_DisableInt
                                        (0045) export _UART_DisableInt
                                        (0046) 
                                        (0047) export  UART_Start
                                        (0048) export _UART_Start
                                        (0049) export  UART_Stop
                                        (0050) export _UART_Stop
                                        (0051) export  UART_SendData
                                        (0052) export _UART_SendData
                                        (0053) export  UART_bReadTxStatus
                                        (0054) export _UART_bReadTxStatus
                                        (0055) export  UART_bReadRxData
                                        (0056) export _UART_bReadRxData
                                        (0057) export  UART_bReadRxStatus
                                        (0058) export _UART_bReadRxStatus
                                        (0059) 
                                        (0060) export  UART_IntCntl
                                        (0061) export _UART_IntCntl
                                        (0062) 
                                        (0063) export  UART_TxIntMode
                                        (0064) export _UART_TxIntMode
                                        (0065) 
                                        (0066) export  UART_PutSHexByte
                                        (0067) export _UART_PutSHexByte
                                        (0068) export  UART_PutSHexInt
                                        (0069) export _UART_PutSHexInt
                                        (0070) 
                                        (0071) export  UART_CPutString
                                        (0072) export _UART_CPutString
                                        (0073) export  UART_PutString
                                        (0074) export _UART_PutString
                                        (0075) export  UART_PutChar
                                        (0076) export _UART_PutChar
                                        (0077) export  UART_Write
                                        (0078) export _UART_Write
                                        (0079) export  UART_CWrite
                                        (0080) export _UART_CWrite
                                        (0081) 
                                        (0082) export  UART_cGetChar
                                        (0083) export _UART_cGetChar
                                        (0084) export  UART_cReadChar
                                        (0085) export _UART_cReadChar
                                        (0086) export  UART_iReadChar
                                        (0087) export _UART_iReadChar
                                        (0088) export  UART_PutCRLF
                                        (0089) export _UART_PutCRLF
                                        (0090) 
                                        (0091) IF (UART_RXBUF_ENABLE)
                                        (0092) export  UART_CmdReset
                                        (0093) export _UART_CmdReset
                                        (0094) export  UART_bCmdCheck
                                        (0095) export _UART_bCmdCheck
                                        (0096) export  UART_bCmdLength
                                        (0097) export _UART_bCmdLength
                                        (0098) export  UART_bErrCheck
                                        (0099) export _UART_bErrCheck
                                        (0100) 
                                        (0101) export  UART_szGetParam
                                        (0102) export _UART_szGetParam
                                        (0103) export  UART_szGetRestOfParams
                                        (0104) export _UART_szGetRestOfParams
                                        (0105) ENDIF
                                        (0106) 
                                        (0107) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        (0108) ; WARNING WARNING WARNING
                                        (0109) ; The following exports are for backwards compatibility only and should
                                        (0110) ; not be used for new designs. They may be eliminated in a future release.
                                        (0111) ; Their status is "NO FURTHER MAINTENANCE". 
                                        (0112) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        (0113) export  bUART_ReadTxStatus
                                        (0114) export _bUART_ReadTxStatus
                                        (0115) export  bUART_ReadRxData
                                        (0116) export _bUART_ReadRxData
                                        (0117) export  bUART_ReadRxStatus
                                        (0118) export _bUART_ReadRxStatus
                                        (0119) 	
                                        (0120) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        (0121) ;             END WARNING
                                        (0122) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        (0123) 
                                        (0124) ;-----------------------------------------------
                                        (0125) ; Variable Allocation
                                        (0126) ;-----------------------------------------------
                                        (0127) IF (UART_RXBUF_ENABLE)
                                        (0128)     
                                        (0129) area UART_RAM (RAM, REL, CON)
                                        (0130)     
                                        (0131)  ptrParam:   BLK  1
                                        (0132) 
                                        (0133) ENDIF
                                        (0134) 
                                        (0135) area text (ROM,REL)
                                        (0136) 
                                        (0137) ;-----------------------------------------------
                                        (0138) ;  EQUATES
                                        (0139) ;-----------------------------------------------
                                        (0140) bfCONTROL_REG_START_BIT:        equ    1    ; Control register start bit
                                        (0141) bfFUNCTION_REG_TX_INT_MODE_BIT: equ 0x10    ; the TX Int Mode bit
                                        (0142) 
                                        (0143) area UserModules (ROM, REL, CON)
                                        (0144) 
                                        (0145) ;=============================================================================
                                        (0146) ;=============================================================================
                                        (0147) ;
                                        (0148) ;     Low-Level Commands
                                        (0149) ;
                                        (0150) ;=============================================================================
                                        (0151) ;=============================================================================
                                        (0152) 
                                        (0153) .SECTION
                                        (0154) ;-----------------------------------------------------------------------------
                                        (0155) ;  FUNCTION NAME: UART_EnableInt
                                        (0156) ;
                                        (0157) ;  DESCRIPTION:
                                        (0158) ;     Enables this UART's interrupt by setting the interrupt enable mask
                                        (0159) ;     bit associated with this User Module. Remember to call the global
                                        (0160) ;     interrupt enable function by using the macro: M8C_EnableGInt.
                                        (0161) ;-----------------------------------------------------------------------------
                                        (0162) ;
                                        (0163) ;  ARGUMENTS:
                                        (0164) ;     none.
                                        (0165) ;
                                        (0166) ;  RETURNS:
                                        (0167) ;     none.
                                        (0168) ;
                                        (0169) ;  SIDE EFFECTS:
                                        (0170) ;    The A and X registers may be modified by this or future implementations
                                        (0171) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0172) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0173) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0174) ;    functions.
                                        (0175) ;
                                        (0176)  UART_EnableInt:
                                        (0177) _UART_EnableInt:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0179)    M8C_EnableIntMask UART_TX_INT_REG, UART_TX_INT_MASK
                                        (0180)    M8C_EnableIntMask UART_RX_INT_REG, UART_RX_INT_MASK
                                        (0181)    RAM_EPILOGUE RAM_USE_CLASS_1
074E: 7F       RET                      (0182)    ret
074F: 41 E1 BF AND   REG[0xE1],0xBF     
0752: 41 E1 7F AND   REG[0xE1],0x7F     
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185)     
                                        (0186) .SECTION
                                        (0187) ;-----------------------------------------------------------------------------
                                        (0188) ;  FUNCTION NAME: UART_DisableInt
                                        (0189) ;
                                        (0190) ;  DESCRIPTION:
                                        (0191) ;     Disables this UART's interrupt by clearing the interrupt enable mask bit
                                        (0192) ;     associated with this User Module.
                                        (0193) ;-----------------------------------------------------------------------------
                                        (0194) ;
                                        (0195) ;  ARGUMENTS:
                                        (0196) ;     none.
                                        (0197) ;
                                        (0198) ;  RETURNS:
                                        (0199) ;     none.
                                        (0200) ;
                                        (0201) ;  SIDE EFFECTS:
                                        (0202) ;    The A and X registers may be modified by this or future implementations
                                        (0203) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0204) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0205) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0206) ;    functions.
                                        (0207) ;
                                        (0208)  UART_DisableInt:
                                        (0209) _UART_DisableInt:
                                        (0210)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0211)    M8C_DisableIntMask UART_TX_INT_REG, UART_TX_INT_MASK
                                        (0212)    M8C_DisableIntMask UART_RX_INT_REG, UART_RX_INT_MASK
                                        (0213)    RAM_EPILOGUE RAM_USE_CLASS_1
0755: 7F       RET                      (0214)    ret
0756: 71 10    OR    F,0x10             
                                        (0215) .ENDSECTION
                                        (0216) 
                                        (0217) 
                                        (0218) .SECTION
                                        (0219) ;-----------------------------------------------------------------------------
                                        (0220) ;  FUNCTION NAME: UART_SetTxIntMode(BYTE bTxIntMode)
                                        (0221) ;
                                        (0222) ;  DESCRIPTION:
                                        (0223) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                        (0224) ;-----------------------------------------------------------------------------
                                        (0225) ;
                                        (0226) ;  ARGUMENTS:
                                        (0227) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                        (0228) ;        Passed in the A register
                                        (0229) ;
                                        (0230) ;  RETURNS:
                                        (0231) ;     none.
                                        (0232) ;
                                        (0233) ;  SIDE EFFECTS:
                                        (0234) ;    The A and X registers may be modified by this or future implementations
                                        (0235) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0236) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0237) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0238) ;    functions.
                                        (0239) ;
                                        (0240) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0241) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                        (0242) ;     on TX register empty or TX transmit complete
                                        (0243) ;
                                        (0244)  UART_SetTxIntMode:
                                        (0245) _UART_SetTxIntMode:
                                        (0246)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0247)    M8C_SetBank1
0758: 21 01    AND   A,0x1              (0248)    and   A, UART_INT_MODE_TX_COMPLETE
075A: A0 07    JZ    0x0762             (0249)    jz    .SetModeRegEmpty
075C: 43 38 10 OR    REG[0x38],0x10     (0250)    or    REG[UART_TX_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
075F: 70 EF    AND   F,0xEF             
                                        (0251)    M8C_SetBank0
                                        (0252)    RAM_EPILOGUE RAM_USE_CLASS_1
0761: 7F       RET                      (0253)    ret
                                        (0254) 
                                        (0255) .SetModeRegEmpty:
0762: 41 38 EF AND   REG[0x38],0xEF     (0256)    and   REG[UART_TX_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
0765: 70 EF    AND   F,0xEF             
                                        (0257)    M8C_SetBank0
                                        (0258)    RAM_EPILOGUE RAM_USE_CLASS_1
0767: 7F       RET                      (0259)    ret
                                        (0260) .ENDSECTION
                                        (0261) 
                                        (0262) 
                                        (0263) .SECTION
                                        (0264) ;-----------------------------------------------------------------------------
                                        (0265) ;  FUNCTION NAME: UART_Start(BYTE bParity)
                                        (0266) ;
                                        (0267) ;  DESCRIPTION:
                                        (0268) ;     Sets the start bit and parity in the Control register of this user module.
                                        (0269) ;-----------------------------------------------------------------------------
                                        (0270) ;
                                        (0271) ;  ARGUMENTS:
                                        (0272) ;     BYTE bParity - parity setting for the Transmitter and receiver. Use defined masks.
                                        (0273) ;        Passed in the A register.
                                        (0274) ;
                                        (0275) ;  RETURNS:
                                        (0276) ;     none.
                                        (0277) ;
                                        (0278) ;  SIDE EFFECTS:
                                        (0279) ;    The A and X registers may be modified by this or future implementations
                                        (0280) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0281) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0282) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0283) ;    functions.
                                        (0284) ;
                                        (0285)  UART_Start:
                                        (0286) _UART_Start:
                                        (0287)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0288)    ; Note, Proxy Class 4 only if receive buffer used; otherwise Proxy Class 1.
                                        (0289) 
0768: 29 01    OR    A,0x1              (0290)    or    A, bfCONTROL_REG_START_BIT
076A: 60 3B    MOV   REG[0x3B],A        (0291)    mov   REG[UART_TX_CONTROL_REG], A
076C: 60 3F    MOV   REG[0x3F],A        (0292)    mov   REG[UART_RX_CONTROL_REG], A
                                        (0293) IF ( UART_RXBUF_ENABLE )
076E: 91 2A    CALL  _UART_CmdReset     (0294)    call  _UART_CmdReset
                                        (0295) ENDIF
                                        (0296)    RAM_EPILOGUE RAM_USE_CLASS_1
0770: 7F       RET                      (0297)    ret
                                        (0298) .ENDSECTION
                                        (0299) 
                                        (0300) 
                                        (0301) .SECTION
                                        (0302) ;-----------------------------------------------------------------------------
                                        (0303) ;  FUNCTION NAME: UART_Stop
                                        (0304) ;
                                        (0305) ;  DESCRIPTION:
                                        (0306) ;     Disables UART operation.
                                        (0307) ;-----------------------------------------------------------------------------
                                        (0308) ;
                                        (0309) ;  ARGUMENTS:
                                        (0310) ;     none.
                                        (0311) ;
                                        (0312) ;  RETURNS:
                                        (0313) ;     none.
                                        (0314) ;
                                        (0315) ;  SIDE EFFECTS:
                                        (0316) ;    The A and X registers may be modified by this or future implementations
                                        (0317) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0318) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0319) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0320) ;    functions.
                                        (0321) ;
                                        (0322)  UART_Stop:
                                        (0323) _UART_Stop:
                                        (0324)    RAM_PROLOGUE RAM_USE_CLASS_1
0771: 41 3B FE AND   REG[0x3B],0xFE     (0325)    and   REG[UART_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
0774: 41 3F FE AND   REG[0x3F],0xFE     (0326)    and   REG[UART_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                        (0327)    RAM_EPILOGUE RAM_USE_CLASS_1
0777: 7F       RET                      (0328)    ret
                                        (0329) .ENDSECTION
                                        (0330) 
                                        (0331) 
                                        (0332) .SECTION
                                        (0333) ;-----------------------------------------------------------------------------
                                        (0334) ;  FUNCTION NAME: UART_SendData
                                        (0335) ;
                                        (0336) ;  DESCRIPTION:
                                        (0337) ;     Initiates a transmission of data.
                                        (0338) ;-----------------------------------------------------------------------------
                                        (0339) ;
                                        (0340) ;  ARGUMENTS:
                                        (0341) ;     BYTE  TxData - data to transmit. PASSED in A register.
                                        (0342) ;
                                        (0343) ;  RETURNS:
                                        (0344) ;     none.
                                        (0345) ;
                                        (0346) ;  SIDE EFFECTS:
                                        (0347) ;    The A and X registers may be modified by this or future implementations
                                        (0348) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0349) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0350) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0351) ;    functions.
                                        (0352) ;
                                        (0353)  UART_SendData:
                                        (0354) _UART_SendData:
                                        (0355)    RAM_PROLOGUE RAM_USE_CLASS_1
0778: 60 39    MOV   REG[0x39],A        (0356)    mov REG[UART_TX_BUFFER_REG], A
                                        (0357)    RAM_EPILOGUE RAM_USE_CLASS_1
077A: 7F       RET                      (0358)    ret
                                        (0359) .ENDSECTION
                                        (0360) 
                                        (0361) 
                                        (0362) .SECTION
                                        (0363) ;-----------------------------------------------------------------------------
                                        (0364) ;  FUNCTION NAME: UART_bReadTxStatus
                                        (0365) ;
                                        (0366) ;  DESCRIPTION:
                                        (0367) ;     Reads the Tx Status bits in the Control/Status register.
                                        (0368) ;-----------------------------------------------------------------------------
                                        (0369) ;
                                        (0370) ;  ARGUMENTS:
                                        (0371) ;     none.
                                        (0372) ;
                                        (0373) ;  RETURNS:
                                        (0374) ;     BYTE  bTxStatus - transmit status data.  Use defined masks for detecting
                                        (0375) ;           status bits (returned in A)
                                        (0376) ;
                                        (0377) ;  SIDE EFFECTS:
                                        (0378) ;    The A and X registers may be modified by this or future implementations
                                        (0379) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0380) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0381) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0382) ;    functions.
                                        (0383) ;
                                        (0384)  UART_bReadTxStatus:
                                        (0385) _UART_bReadTxStatus:
                                        (0386)  bUART_ReadTxStatus:                             ; For backwards compatibility only
                                        (0387) _bUART_ReadTxStatus:                             ; For backwards compatibility only
                                        (0388)    RAM_PROLOGUE RAM_USE_CLASS_1
077B: 5D 3B    MOV   A,REG[0x3B]        (0389)    mov A,  REG[UART_TX_CONTROL_REG]
                                        (0390)    RAM_EPILOGUE RAM_USE_CLASS_1
077D: 7F       RET                      (0391)    ret
                                        (0392) .ENDSECTION
                                        (0393) 
                                        (0394) 
                                        (0395) .SECTION
                                        (0396) ;-----------------------------------------------------------------------------
                                        (0397) ;  FUNCTION NAME: UART_bReadRxData
                                        (0398) ;
                                        (0399) ;  DESCRIPTION:
                                        (0400) ;     Reads the RX buffer register.  Should check the status regiser to make
                                        (0401) ;     sure data is valid.
                                        (0402) ;-----------------------------------------------------------------------------
                                        (0403) ;
                                        (0404) ;  ARGUMENTS:
                                        (0405) ;     none.
                                        (0406) ;
                                        (0407) ;  RETURNS:
                                        (0408) ;     bRxData - returned in A.
                                        (0409) ;
                                        (0410) ;  SIDE EFFECTS:
                                        (0411) ;    The A and X registers may be modified by this or future implementations
                                        (0412) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0413) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0414) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0415) ;    functions.
                                        (0416) ;
                                        (0417)  UART_bReadRxData:
                                        (0418) _UART_bReadRxData:
                                        (0419)  bUART_ReadRxData:                               ; For backwards compatibility only
                                        (0420) _bUART_ReadRxData:                               ; For backwards compatibility only
                                        (0421)    RAM_PROLOGUE RAM_USE_CLASS_1
077E: 5D 3E    MOV   A,REG[0x3E]        (0422)    mov A, REG[UART_RX_BUFFER_REG]
                                        (0423)    RAM_EPILOGUE RAM_USE_CLASS_1
0780: 7F       RET                      (0424)    ret
                                        (0425) .ENDSECTION
                                        (0426) 
                                        (0427) 
                                        (0428) .SECTION
                                        (0429) ;-----------------------------------------------------------------------------
                                        (0430) ;  FUNCTION NAME: UART_bReadRxStatus
                                        (0431) ;
                                        (0432) ;  DESCRIPTION:
                                        (0433) ;     Reads the RX Status bits in the Control/Status register.
                                        (0434) ;-----------------------------------------------------------------------------
                                        (0435) ;
                                        (0436) ;  ARGUMENTS:
                                        (0437) ;     none.
                                        (0438) ;
                                        (0439) ;  RETURNS:
                                        (0440) ;     BYTE  bRXStatus - receive status data.  Use the following defined bits
                                        (0441) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                        (0442) ;           returned in A.
                                        (0443) ;
                                        (0444) ;  SIDE EFFECTS:
                                        (0445) ;    The A and X registers may be modified by this or future implementations
                                        (0446) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0447) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0448) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0449) ;    functions.
                                        (0450) ;
                                        (0451)  UART_bReadRxStatus:
                                        (0452) _UART_bReadRxStatus:
                                        (0453)  bUART_ReadRxStatus:                             ; For backwards compatibility only
                                        (0454) _bUART_ReadRxStatus:                             ; For backwards compatibility only
                                        (0455)    RAM_PROLOGUE RAM_USE_CLASS_1
0781: 5D 3F    MOV   A,REG[0x3F]        (0456)    mov A,  REG[UART_RX_CONTROL_REG]
                                        (0457)    RAM_EPILOGUE RAM_USE_CLASS_1
0783: 7F       RET                      (0458)    ret
                                        (0459) .ENDSECTION
                                        (0460) 
                                        (0461) 
                                        (0462) .SECTION
                                        (0463) ;-----------------------------------------------------------------------------
                                        (0464) ;  FUNCTION NAME: UART_TxIntMode
                                        (0465) ;
                                        (0466) ;  DESCRIPTION:
                                        (0467) ;     This function is used to change the TX Interrupt mode.
                                        (0468) ;-----------------------------------------------------------------------------
                                        (0469) ;
                                        (0470) ;  ARGUMENTS:
                                        (0471) ;     A => Tx Interrupt mode
                                        (0472) ;             0 => Interrupt on TX_Reg_Empty  (Default)
                                        (0473) ;             1 => Interrupt on TX Complete
                                        (0474) ;
                                        (0475) ;  RETURNS:
                                        (0476) ;     none.
                                        (0477) ;
                                        (0478) ;  SIDE EFFECTS:
                                        (0479) ;    The A and X registers may be modified by this or future implementations
                                        (0480) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0481) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0482) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0483) ;    functions.
                                        (0484) ;
                                        (0485)  UART_TxIntMode:
                                        (0486) _UART_TxIntMode:
                                        (0487)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0488) 
0784: 21 01    AND   A,0x1              (0489)    and  A,UART_INT_MODE_TX_COMPLETE
0786: 71 10    OR    F,0x10             
                                        (0490)    M8C_SetBank1
0788: 39 01    CMP   A,0x1              (0491)    cmp  A,UART_INT_MODE_TX_COMPLETE
078A: A0 06    JZ    0x0791             (0492)    jz   .SetTxCmpMode
                                        (0493) 
078C: 41 38 EF AND   REG[0x38],0xEF     (0494)    and  reg[UART_TX_FUNC_REG],0xEF               ; Set Interrupt on Tx_Reg_Empty
078F: 80 04    JMP   0x0794             (0495)    jmp  .TxIntMode_End
                                        (0496) 
                                        (0497) .SetTxCmpMode:                                       ; Set Interrupt on TX Complete
0791: 43 38 10 OR    REG[0x38],0x10     (0498)    or   reg[UART_TX_FUNC_REG],0x10
0794: 70 EF    AND   F,0xEF             
                                        (0499) 
                                        (0500) .TxIntMode_End:
                                        (0501)    M8C_SetBank0
                                        (0502)    RAM_EPILOGUE RAM_USE_CLASS_1
0796: 7F       RET                      (0503)    ret
                                        (0504) .ENDSECTION
                                        (0505) 
                                        (0506)     
                                        (0507) .SECTION
                                        (0508) ;-----------------------------------------------------------------------------
                                        (0509) ;  FUNCTION NAME: UART_IntCntl
                                        (0510) ;
                                        (0511) ;  DESCRIPTION:
                                        (0512) ;     This function is used to enable/disable the Rx and Tx interrupt.
                                        (0513) ;-----------------------------------------------------------------------------
                                        (0514) ;
                                        (0515) ;  ARGUMENTS:
                                        (0516) ;     A => Interrupt mask
                                        (0517) ;
                                        (0518) ;  RETURNS:
                                        (0519) ;     none.
                                        (0520) ;
                                        (0521) ;  SIDE EFFECTS:
                                        (0522) ;    The A and X registers may be modified by this or future implementations
                                        (0523) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0524) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0525) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0526) ;    functions.
                                        (0527) ;
                                        (0528) ;  THEORY of OPERATION or PROCEDURE:
                                        (0529) ;     Set or Clears the Tx/Rx user module interrupt enable mask bit in the TX
                                        (0530) ;     and RX block.
                                        (0531) ;
                                        (0532)  UART_IntCntl:
                                        (0533) _UART_IntCntl:
                                        (0534)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0535) 
0797: 08       PUSH  A                  (0536)    push A
0798: 21 01    AND   A,0x1              (0537)    and  A,UART_ENABLE_RX_INT
079A: A0 06    JZ    0x07A1             (0538)    jz   .DisRxInt
079C: 43 E1 80 OR    REG[0xE1],0x80     
                                        (0539)      ; Enable Rx Interrupt
                                        (0540)    M8C_EnableIntMask UART_RX_INT_REG, UART_RX_INT_MASK
079F: 80 04    JMP   0x07A4             (0541)    jmp  .CheckTxInt
07A1: 41 E1 7F AND   REG[0xE1],0x7F     
                                        (0542) .DisRxInt:
                                        (0543)      ; Disable Rx Interrupt
                                        (0544)    M8C_DisableIntMask UART_RX_INT_REG, UART_RX_INT_MASK
                                        (0545) 
                                        (0546) .CheckTxInt:
07A4: 18       POP   A                  (0547)    pop  A
07A5: 21 02    AND   A,0x2              (0548)    and  A,UART_ENABLE_TX_INT
07A7: A0 06    JZ    0x07AE             (0549)    jz   .DisTxInt
07A9: 43 E1 40 OR    REG[0xE1],0x40     
                                        (0550)      ; Enable Tx Interrupt
                                        (0551)    M8C_EnableIntMask UART_TX_INT_REG, UART_TX_INT_MASK
07AC: 80 04    JMP   0x07B1             (0552)    jmp  .End_IntCntl
07AE: 41 E1 BF AND   REG[0xE1],0xBF     
                                        (0553) .DisTxInt:
                                        (0554)      ; Disable Tx Interrupt
                                        (0555)    M8C_DisableIntMask UART_TX_INT_REG, UART_TX_INT_MASK
                                        (0556) 
                                        (0557) .End_IntCntl:
                                        (0558)    RAM_EPILOGUE RAM_USE_CLASS_1
07B1: 7F       RET                      (0559)    ret
                                        (0560) .ENDSECTION
                                        (0561) 
                                        (0562) 
                                        (0563) ;=============================================================================
                                        (0564) ;=============================================================================
                                        (0565) ;
                                        (0566) ;     High-Level Commands
                                        (0567) ;
                                        (0568) ;=============================================================================
                                        (0569) ;=============================================================================
                                        (0570) 
                                        (0571) 
                                        (0572) ;-----------------------------------------------------------------------------
                                        (0573) ;  FUNCTION NAME: UART_PutSHexByte
                                        (0574) ;
                                        (0575) ;  DESCRIPTION:
                                        (0576) ;     Print a byte in Hex (two characters) to the UART Tx
                                        (0577) ;-----------------------------------------------------------------------------
                                        (0578) ;
                                        (0579) ;  ARGUMENTS:
                                        (0580) ;     A  => (BYTE) Data/char to be printed
                                        (0581) ;
                                        (0582) ;  RETURNS:
                                        (0583) ;     none.
                                        (0584) ;
                                        (0585) ;  SIDE EFFECTS:
                                        (0586) ;    The A and X registers may be modified by this or future implementations
                                        (0587) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0588) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0589) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0590) ;    functions.
                                        (0591) ;
                                        (0592) .LITERAL
                                        (0593) UART_HEX_STR:
                                        (0594)      DS    "0123456789ABCDEF"
                                        (0595) .ENDLITERAL
                                        (0596) 
                                        (0597) .SECTION
                                        (0598)  UART_PutSHexByte:
                                        (0599) _UART_PutSHexByte:
                                        (0600)    RAM_PROLOGUE RAM_USE_CLASS_1
07C2: 08       PUSH  A                  (0601)    push  A                             ; Save lower nibble
07C3: 67       ASR   A                  (0602)    asr   A                             ; Shift high nibble to right
07C4: 67       ASR   A                  (0603)    asr   A
07C5: 67       ASR   A                  (0604)    asr   A
07C6: 67       ASR   A                  (0605)    asr   A
07C7: 21 0F    AND   A,0xF              (0606)    and   A,0Fh                         ; Mask off nibble
07C9: FF E7    INDEX 0x07B2             (0607)    index UART_HEX_STR                  ; Get Hex value
07CB: 90 0F    CALL  _UART_PutChar      (0608)    call  UART_PutChar                  ; Write data to screen
07CD: 18       POP   A                  (0609)    pop   A                             ; Restore value
07CE: 21 0F    AND   A,0xF              (0610)    and   A,0Fh                         ; Mask off lower nibble
07D0: FF E0    INDEX 0x07B2             (0611)    index UART_HEX_STR                  ; Get Hex value
07D2: 90 08    CALL  _UART_PutChar      (0612)    call  UART_PutChar                  ; Write data to screen
                                        (0613)    RAM_EPILOGUE RAM_USE_CLASS_1
07D4: 7F       RET                      (0614)    ret
                                        (0615) .ENDSECTION
                                        (0616) 
                                        (0617) 
                                        (0618) .SECTION
                                        (0619) ;-----------------------------------------------------------------------------
                                        (0620) ;  FUNCTION NAME: UART_PutSHexInt
                                        (0621) ;
                                        (0622) ;  DESCRIPTION:
                                        (0623) ;     Print an Int in Hex (four characters) to UART Tx
                                        (0624) ;-----------------------------------------------------------------------------
                                        (0625) ;
                                        (0626) ;  ARGUMENTS:
                                        (0627) ;     Pointer to string
                                        (0628) ;     A  => ASB of Int
                                        (0629) ;     X  => MSB of Int
                                        (0630) ;
                                        (0631) ;  RETURNS:
                                        (0632) ;     none.
                                        (0633) ;
                                        (0634) ;  SIDE EFFECTS:
                                        (0635) ;    The A and X registers may be modified by this or future implementations
                                        (0636) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0637) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0638) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0639) ;    functions.
                                        (0640) ;
                                        (0641) 
                                        (0642)  UART_PutSHexInt:
                                        (0643) _UART_PutSHexInt:
                                        (0644)    RAM_PROLOGUE RAM_USE_CLASS_1
07D5: 4B       SWAP  A,X                (0645)    swap  A,X
07D6: 9F EA    CALL  _UART_PutSHexByte  (0646)    call  UART_PutSHexByte              ; Print MSB
07D8: 5B       MOV   A,X                (0647)    mov   A,X                           ; Move LSB into position
07D9: 9F E7    CALL  _UART_PutSHexByte  (0648)    call  UART_PutSHexByte              ; Print LSB
                                        (0649)    RAM_EPILOGUE RAM_USE_CLASS_1
07DB: 7F       RET                      (0650)    ret
07DC: 49 3B 10 TST   REG[0x3B],0x10     
07DF: AF FC    JZ    _UART_PutChar      
07E1: 60 39    MOV   REG[0x39],A        
                                        (0651) .ENDSECTION
                                        (0652) 
                                        (0653) 
                                        (0654) .SECTION
                                        (0655) ;-----------------------------------------------------------------------------
                                        (0656) ;  FUNCTION NAME: UART_PutChar
                                        (0657) ;
                                        (0658) ;  DESCRIPTION:
                                        (0659) ;     Send character out through UART TX port.
                                        (0660) ;-----------------------------------------------------------------------------
                                        (0661) ;
                                        (0662) ;  ARGUMENTS:
                                        (0663) ;     A has Character to send to UART Tx Port
                                        (0664) ;
                                        (0665) ;  RETURNS:
                                        (0666) ;     none
                                        (0667) ;
                                        (0668) ;  SIDE EFFECTS:
                                        (0669) ;    The A and X registers may be modified by this or future implementations
                                        (0670) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0671) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0672) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0673) ;    functions.
                                        (0674) ;
                                        (0675) 
                                        (0676)    macro InLinePutChar( Source )
                                        (0677) .BufEmptyWaitLoop:
                                        (0678)    tst REG[UART_TX_CONTROL_REG], UART_TX_BUFFER_EMPTY     ; Check Tx Status
                                        (0679)    jz  .BufEmptyWaitLoop
                                        (0680)    mov REG[UART_TX_BUFFER_REG], @Source          ; Write data to Tx Port
                                        (0681)    endm
                                        (0682) 
                                        (0683)  UART_PutChar:
                                        (0684) _UART_PutChar:
                                        (0685)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0686)    InLinePutChar A
                                        (0687)    RAM_EPILOGUE RAM_USE_CLASS_1
07E3: 7F       RET                      (0688)    ret
                                        (0689) .ENDSECTION
                                        (0690) 
                                        (0691) 
                                        (0692) .SECTION
                                        (0693) ;-----------------------------------------------------------------------------
                                        (0694) ;  FUNCTION NAME: UART_cGetChar
                                        (0695) ;
                                        (0696) ;  DESCRIPTION:
                                        (0697) ;     Read character from UART RX port.
                                        (0698) ;-----------------------------------------------------------------------------
                                        (0699) ;
                                        (0700) ;  ARGUMENTS:
                                        (0701) ;      none
                                        (0702) ;
                                        (0703) ;  RETURNS:
                                        (0704) ;     char that is returned from UART
                                        (0705) ;
                                        (0706) ;  SIDE EFFECTS:
                                        (0707) ;    The A and X registers may be modified by this or future implementations
                                        (0708) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0709) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0710) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0711) ;    functions.
                                        (0712) ;
                                        (0713) ;    Program flow will stay in this function until a character is received.
                                        (0714) ;    If the watchdog timer is used, care must be taken to make sure that
                                        (0715) ;    the delay between characters is less than the watchdog timeout.
                                        (0716) ;
                                        (0717)  UART_cGetChar:
                                        (0718) _UART_cGetChar:
                                        (0719)    RAM_PROLOGUE RAM_USE_CLASS_1
07E4: 49 3F 08 TST   REG[0x3F],0x8      (0720)    tst REG[UART_RX_CONTROL_REG],UART_RX_REG_FULL    ; Check if a character is ready
07E7: AF FC    JZ    _UART_cGetChar     (0721)    jz  UART_cGetChar                             ; If not loop
07E9: 5D 3E    MOV   A,REG[0x3E]        (0722)    mov A, REG[UART_RX_BUFFER_REG]                ; Get character
                                        (0723)    RAM_EPILOGUE RAM_USE_CLASS_1
07EB: 7F       RET                      (0724)    ret
                                        (0725) .ENDSECTION
                                        (0726) 
                                        (0727) 
                                        (0728) .SECTION
                                        (0729) ;-----------------------------------------------------------------------------
                                        (0730) ;  FUNCTION NAME: UART_cReadChar
                                        (0731) ;
                                        (0732) ;  DESCRIPTION:
                                        (0733) ;     Read character from UART RX port.
                                        (0734) ;-----------------------------------------------------------------------------
                                        (0735) ;
                                        (0736) ;  ARGUMENTS:
                                        (0737) ;      none
                                        (0738) ;
                                        (0739) ;  RETURNS:
                                        (0740) ;     char that is returned from UART
                                        (0741) ;
                                        (0742) ;  SIDE EFFECTS:
                                        (0743) ;    The A and X registers may be modified by this or future implementations
                                        (0744) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0745) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0746) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0747) ;    functions.
                                        (0748) ;
                                        (0749) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                        (0750) ;    implies a valid character or an error condition occured.
                                        (0751) ;
                                        (0752)  UART_cReadChar:
                                        (0753) _UART_cReadChar:
                                        (0754)    RAM_PROLOGUE RAM_USE_CLASS_1
07EC: 5D 3F    MOV   A,REG[0x3F]        (0755)    mov  A,REG[UART_RX_CONTROL_REG]                         ; Get Status of RX
07EE: 08       PUSH  A                  (0756)    push A
07EF: 21 08    AND   A,0x8              (0757)    and  A,UART_RX_COMPLETE                                 ; Check if a character is ready
07F1: B0 04    JNZ   0x07F6             (0758)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
07F3: 18       POP   A                  (0759)    pop  A
07F4: 80 0B    JMP   0x0800             (0760)    jmp  .RX_NO_VALID_CHAR
                                        (0761) 
                                        (0762) .RX_DATA_RDY:
07F6: 5D 3E    MOV   A,REG[0x3E]        (0763)    mov  A,REG[UART_RX_BUFFER_REG ]          
07F8: 4B       SWAP  A,X                (0764)    swap A,X                                                ; determine if data is valid
                                        (0765) 
07F9: 18       POP   A                  (0766)    pop  A                                                  ; Check for errors
07FA: 21 A0    AND   A,0xA0             (0767)    and  A,(UART_RX_PARITY_ERROR | UART_RX_FRAMING_ERROR)
07FC: B0 03    JNZ   0x0800             (0768)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
07FE: 4B       SWAP  A,X                (0769)    swap A,X                                                ; Put data in A and exit
                                        (0770)    RAM_EPILOGUE RAM_USE_CLASS_1
07FF: 7F       RET                      (0771)    ret
                                        (0772) 
                                        (0773) .RX_NO_VALID_CHAR:
0800: 50 00    MOV   A,0x0              (0774)    mov A,0x00                                              ; Zero out character
                                        (0775) 
                                        (0776)  End_UART_cReadChar:
                                        (0777)    RAM_EPILOGUE RAM_USE_CLASS_1
0802: 7F       RET                      (0778)    ret
                                        (0779) .ENDSECTION
                                        (0780) 
                                        (0781) 
                                        (0782) .SECTION
                                        (0783) ;-----------------------------------------------------------------------------
                                        (0784) ;  FUNCTION NAME: UART_iReadChar
                                        (0785) ;
                                        (0786) ;  WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                        (0787) ;  to just set a value in the upper byte if error conditions exists.
                                        (0788) ;
                                        (0789) ;  DESCRIPTION:
                                        (0790) ;     Read character from UART RX port.
                                        (0791) ;-----------------------------------------------------------------------------
                                        (0792) ;
                                        (0793) ;  ARGUMENTS:
                                        (0794) ;      none
                                        (0795) ;
                                        (0796) ;  RETURNS:
                                        (0797) ;     An integer value is returned.  A negative value inplies and error
                                        (0798) ;     condition, a positive value between 0 and 255 is the return character.
                                        (0799) ;
                                        (0800) ;     Error Codes:
                                        (0801) ;        0x80CC    Parity Error
                                        (0802) ;        0x40CC    Overrun Error
                                        (0803) ;        0x20CC    Framing Error
                                        (0804) ;        0x01CC    No Data available
                                        (0805) ;
                                        (0806) ;  SIDE EFFECTS:
                                        (0807) ;    The A and X registers may be modified by this or future implementations
                                        (0808) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0809) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0810) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0811) ;    functions.
                                        (0812) ;
                                        (0813)  UART_iReadChar:
                                        (0814) _UART_iReadChar:
                                        (0815)    RAM_PROLOGUE RAM_USE_CLASS_1
0803: 5D 3F    MOV   A,REG[0x3F]        (0816)    mov  A,REG[UART_RX_CONTROL_REG]                         ; Get Status of RX
                                        (0817)                                                            ; Mask only errors and data ready
0805: 21 E8    AND   A,0xE8             (0818)    and  A,(UART_RX_ERROR|UART_RX_REG_FULL)
0807: 08       PUSH  A                  (0819)    push A
0808: 21 08    AND   A,0x8              (0820)    and  A,UART_RX_COMPLETE                                 ; Check if a character is ready
080A: B0 07    JNZ   0x0812             (0821)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
080C: 18       POP   A                  (0822)    pop  A
080D: 29 01    OR    A,0x1              (0823)    or   A,UART_RX_NO_DATA                                  ; Add no data flag
080F: 4B       SWAP  A,X                (0824)    swap A,X
0810: 80 07    JMP   0x0818             (0825)    jmp  End_UART_iReadChar
                                        (0826) 
                                        (0827) .RX_GET_DATA:
0812: 18       POP   A                  (0828)    pop  A
0813: 21 E0    AND   A,0xE0             (0829)    and  A,UART_RX_ERROR
0815: 4B       SWAP  A,X                (0830)    swap A,X
0816: 5D 3E    MOV   A,REG[0x3E]        (0831)    mov  A,REG[UART_RX_BUFFER_REG ]                         ; Read data first, then
                                        (0832)                                                            ; determine if data is valid
                                        (0833) 
                                        (0834)  End_UART_iReadChar:
                                        (0835)    RAM_EPILOGUE RAM_USE_CLASS_1
0818: 7F       RET                      (0836)    ret
0819: 70 BF    AND   F,0xBF             
081B: 60 D3    MOV   REG[0xD3],A        
                                        (0837) .ENDSECTION
                                        (0838) 
                                        (0839) 
                                        (0840) .SECTION
                                        (0841) ;-----------------------------------------------------------------------------
                                        (0842) ;  FUNCTION NAME: UART_PutString
                                        (0843) ;
                                        (0844) ;  DESCRIPTION:
                                        (0845) ;     Send String out through UART TX port.
                                        (0846) ;-----------------------------------------------------------------------------
                                        (0847) ;
                                        (0848) ;  ARGUMENTS:
                                        (0849) ;     Pointer to String
                                        (0850) ;     A has MSB of string address
                                        (0851) ;     X has LSB of string address
                                        (0852) ;
                                        (0853) ;  RETURNS:
                                        (0854) ;     none
                                        (0855) ;
                                        (0856) ;  SIDE EFFECTS:
                                        (0857) ;    The A and X registers may be modified by this or future implementations
                                        (0858) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0859) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0860) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0861) ;    functions.
                                        (0862) ;          
                                        (0863) ;    Currently only the page pointer registers listed below are modified: 
                                        (0864) ;          IDX_PP
                                        (0865) ;
                                        (0866)  UART_PutString:
                                        (0867) _UART_PutString:
                                        (0868)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0869)    RAM_SETPAGE_IDX A
                                        (0870) .PutStringLoop:
081D: 52 00    MOV   A,[X+0]            (0871)    mov   A,[X]                                   ; Get value pointed to by X
081F: A0 06    JZ    0x0826             (0872)    jz    End_PutString                           ; Check for end of string
0821: 9F B9    CALL  _UART_PutChar      (0873)    call  UART_PutChar                            ; Send character to Tx port
0823: 75       INC   X                  (0874)    inc   X                                       ; Advance pointer to next character
0824: 8F F8    JMP   0x081D             (0875)    jmp   .PutStringLoop                          ; Get next character
0826: 70 3F    AND   F,0x3F             
0828: 71 C0    OR    F,0xC0             
                                        (0876) 
                                        (0877) End_PutString:
                                        (0878)    RAM_EPILOGUE RAM_USE_CLASS_3
082A: 7F       RET                      (0879)    ret
082B: 70 BF    AND   F,0xBF             
082D: 62 D3 07 MOV   REG[0xD3],0x7      
                                        (0880) .ENDSECTION
                                        (0881)     
                                        (0882) .SECTION
                                        (0883) ;-----------------------------------------------------------------------------
                                        (0884) ;  FUNCTION NAME: UART_Write
                                        (0885) ;
                                        (0886) ;  DESCRIPTION:
                                        (0887) ;     Send String of length X to serial port
                                        (0888) ;-----------------------------------------------------------------------------
                                        (0889) ;
                                        (0890) ;  ARGUMENTS:
                                        (0891) ;     Pointer to String
                                        (0892) ;     [SP-5] Count of characters to send
                                        (0893) ;     [SP-4] has MSB of string address
                                        (0894) ;     [SP-3] has LSB of string address
                                        (0895) ;
                                        (0896) ;  RETURNS:
                                        (0897) ;     none
                                        (0898) ;
                                        (0899) ;  SIDE EFFECTS:
                                        (0900) ;    The A and X registers may be modified by this or future implementations
                                        (0901) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0902) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0903) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0904) ;    functions.
                                        (0905) ;          
                                        (0906) ;    Currently only the page pointer registers listed below are modified: 
                                        (0907) ;          IDX_PP
                                        (0908) ;
                                        (0909) CNT_LEN:    equ -5                               ; Length of data to send
                                        (0910) STR_MSB:    equ -4                               ; MSB pointer of string 
                                        (0911) STR_LSB:    equ -3                               ; LSB pointer of string 
                                        (0912) 
                                        (0913)  UART_Write:
                                        (0914) _UART_Write:
                                        (0915)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0916)    RAM_SETPAGE_IDX2STK                           ; Refer indexed addrs to the stack
0830: 4F       MOV   X,SP               (0917)    mov   X, SP                                   ; Establish the frame pointer 
                                        (0918) 
                                        (0919) .NextByteLoop:
0831: 52 FB    MOV   A,[X-5]            (0920)    mov   A, [X+CNT_LEN]                          ; End of the string?
0833: A0 1A    JZ    0x084E             (0921)    jz    .End_Write                              ;   Yes, prepare to exit
0835: 7B FB    DEC   [X-5]              (0922)    dec   [X+CNT_LEN]                             ; Decrement counter
                                        (0923) 
                                        (0924)    IF SYSTEM_LARGE_MEMORY_MODEL
0837: 52 FC    MOV   A,[X-4]            (0925)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
                                        (0926)    ENDIF
                                        (0927) 
0839: 59 FD    MOV   X,[X-3]            (0928)    mov   X, [X+STR_LSB]                          ; Load pointer to char to send
083B: 60 D3    MOV   REG[0xD3],A        
                                        (0929)    RAM_SETPAGE_IDX A                             ; switch index pages
083D: 52 00    MOV   A,[X+0]            (0930)    mov   A, [X]                                  ; Grab the data
083F: 49 3B 10 TST   REG[0x3B],0x10     
0842: AF FC    JZ    0x083F             
0844: 60 39    MOV   REG[0x39],A        
                                        (0931)    InLinePutChar A                               ; Put data in empty TX buf reg
0846: 4F       MOV   X,SP               (0932)    mov   X, SP                                   ; Recover frame pointer
0847: 62 D3 07 MOV   REG[0xD3],0x7      
                                        (0933)    RAM_SETPAGE_IDX2STK                           ; Prepare for stack access
084A: 77 FD    INC   [X-3]              (0934)    inc   [X+STR_LSB]                             ; Point to next byte, but do not
084C: 8F E4    JMP   0x0831             (0935)    jmp   .NextByteLoop                           ;    cross RAM page boundary!
084E: 70 3F    AND   F,0x3F             
0850: 71 C0    OR    F,0xC0             
                                        (0936) 
                                        (0937) .End_Write:
                                        (0938)    RAM_EPILOGUE RAM_USE_CLASS_3
0852: 7F       RET                      (0939)    ret
                                        (0940) .ENDSECTION
                                        (0941)     
                                        (0942) 
                                        (0943) .SECTION
                                        (0944) ;-----------------------------------------------------------------------------
                                        (0945) ;  FUNCTION NAME: UART_CWrite
                                        (0946) ;
                                        (0947) ;             WARNING WARNING NOT COMPLETE
                                        (0948) ;
                                        (0949) ;  DESCRIPTION:
                                        (0950) ;     Send String of length X to serial port
                                        (0951) ;-----------------------------------------------------------------------------
                                        (0952) ;
                                        (0953) ;  ARGUMENTS:
                                        (0954) ;     [SP-4] MSB of Count of character to send
                                        (0955) ;     [SP-3] LSB of Count of character to send
                                        (0956) ;     [SP-2] has MSB of string address
                                        (0957) ;     [SP-1] has LSB of string address
                                        (0958) ;
                                        (0959) ;  RETURNS:
                                        (0960) ;     none
                                        (0961) ;
                                        (0962) ;  SIDE EFFECTS:
                                        (0963) ;    The A and X registers may be modified by this or future implementations
                                        (0964) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0965) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0966) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0967) ;    functions.
                                        (0968) ;
                                        (0969) CLEN_MSB:   equ -6           ; MSB Length of data to send
                                        (0970) CLEN_LSB:   equ -5           ; LSB Length of data to send
                                        (0971) CSTR_MSB:   equ -4           ; MSB pointer of string
                                        (0972) CSTR_LSB:   equ -3           ; LSB pointer of string
                                        (0973) 
                                        (0974)  UART_CWrite:
                                        (0975) _UART_CWrite:
                                        (0976)    RAM_PROLOGUE RAM_USE_CLASS_2
0853: 4F       MOV   X,SP               (0977)    mov   X,SP
                                        (0978) .CW_Loop:
0854: 3D FA 00 CMP   [X-6],0x0          (0979)    cmp   [X+CLEN_MSB],0x00                  ; Check for zero counter
0857: B0 06    JNZ   0x085E             (0980)    jnz   .CW_WRITEIT
0859: 3D FB 00 CMP   [X-5],0x0          (0981)    cmp   [X+CLEN_LSB],0x00
085C: A0 1D    JZ    0x087A             (0982)    jz    .End_CWrite                        ; Leave if done
                                        (0983) 
                                        (0984) .CW_WRITEIT:                                
085E: 10       PUSH  X                  (0985)    push  X                                  ; Save frame pointer
085F: 52 FC    MOV   A,[X-4]            (0986)    mov   A,[X+CSTR_MSB]
0861: 59 FD    MOV   X,[X-3]            (0987)    mov   X,[X+CSTR_LSB]
0863: 28       ROMX                     (0988)    romx                                     ; Get character from ROM
0864: 49 3B 10 TST   REG[0x3B],0x10     
0867: AF FC    JZ    0x0864             
0869: 60 39    MOV   REG[0x39],A        
                                        (0989)    InLinePutChar A                          ; Put data in empty TX buf reg
086B: 20       POP   X                  (0990)    pop   X                                  ; Restore frame pointer
086C: 07 FD 01 ADD   [X-3],0x1          (0991)    add   [X+CSTR_LSB],1                     ; Increment the string pointer
086F: 0F FC 00 ADC   [X-4],0x0          (0992)    adc   [X+CSTR_MSB],0
0872: 17 FB 01 SUB   [X-5],0x1          (0993)    sub   [X+CLEN_LSB],0x01                  ; Dec the counter
0875: 1F FA 00 SBB   [X-6],0x0          (0994)    sbb   [X+CLEN_MSB],0x00
0878: 8F DB    JMP   0x0854             (0995)    jmp   .CW_Loop
087A: 70 3F    AND   F,0x3F             
087C: 71 C0    OR    F,0xC0             
                                        (0996) 
                                        (0997) .End_CWrite:
                                        (0998)    RAM_EPILOGUE RAM_USE_CLASS_2
087E: 7F       RET                      (0999)    ret
                                        (1000) .ENDSECTION
                                        (1001) 
                                        (1002) 
                                        (1003) .SECTION
                                        (1004) ;-----------------------------------------------------------------------------
                                        (1005) ;  FUNCTION NAME: UART_CPutString
                                        (1006) ;
                                        (1007) ;  DESCRIPTION:
                                        (1008) ;     Send String out through UART TX port.
                                        (1009) ;-----------------------------------------------------------------------------
                                        (1010) ;
                                        (1011) ;  ARGUMENTS:
                                        (1012) ;     Pointer to String
                                        (1013) ;     A has MSB of string address
                                        (1014) ;     X has LSB of string address
                                        (1015) ;
                                        (1016) ;  RETURNS:
                                        (1017) ;     none
                                        (1018) ;
                                        (1019) ;  SIDE EFFECTS:
                                        (1020) ;    The A and X registers may be modified by this or future implementations
                                        (1021) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1022) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1023) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1024) ;    functions.
                                        (1025) ;
                                        (1026)  UART_CPutString:
                                        (1027) _UART_CPutString:
                                        (1028)    RAM_PROLOGUE RAM_USE_CLASS_1
087F: 08       PUSH  A                  (1029)    push  A                                       ; Store ROM pointer
0880: 10       PUSH  X                  (1030)    push  X
0881: 28       ROMX                     (1031)    romx                                          ; Get character from ROM
0882: A0 0B    JZ    0x088E             (1032)    jz    .End_CPutString
0884: 9F 56    CALL  _UART_PutChar      (1033)    call  UART_PutChar                            ; Print character
0886: 20       POP   X                  (1034)    pop   X
0887: 18       POP   A                  (1035)    pop   A
0888: 75       INC   X                  (1036)    inc   X                                       ; Inc LSB of pointer
0889: DF F5    JNC   _UART_CPutString   (1037)    jnc   UART_CPutString                         ; Check for carry
088B: 74       INC   A                  (1038)    inc   A                                       ; Inc MSB of pointer
088C: 8F F2    JMP   _UART_CPutString   (1039)    jmp   UART_CPutString
                                        (1040) 
                                        (1041) 
                                        (1042) .End_CPutString:
088E: 38 FE    ADD   SP,0xFE            (1043)    add   SP, -2
                                        (1044)    RAM_EPILOGUE RAM_USE_CLASS_1
0890: 7F       RET                      (1045)    ret
                                        (1046) .ENDSECTION
                                        (1047) 
                                        (1048) 
                                        (1049) .SECTION
                                        (1050) ;-----------------------------------------------------------------------------
                                        (1051) ;  FUNCTION NAME: UART_PutCRLF
                                        (1052) ;
                                        (1053) ;  DESCRIPTION:
                                        (1054) ;     Send a CR and LF
                                        (1055) ;-----------------------------------------------------------------------------
                                        (1056) ;
                                        (1057) ;  ARGUMENTS:
                                        (1058) ;     none.
                                        (1059) ;
                                        (1060) ;  RETURNS:
                                        (1061) ;     none.
                                        (1062) ;
                                        (1063) ;  SIDE EFFECTS:
                                        (1064) ;    The A and X registers may be modified by this or future implementations
                                        (1065) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1066) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1067) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1068) ;    functions.
                                        (1069) ;
                                        (1070)  UART_PutCRLF:
                                        (1071) _UART_PutCRLF:
                                        (1072)    RAM_PROLOGUE RAM_USE_CLASS_1
0891: 50 0D    MOV   A,0xD              (1073)    mov  A,0x0D                        ; Send CR
0893: 9F 47    CALL  _UART_PutChar      (1074)    call UART_PutChar
0895: 50 0A    MOV   A,0xA              (1075)    mov  A,0x0A                        ; Send LF
0897: 9F 43    CALL  _UART_PutChar      (1076)    call UART_PutChar
                                        (1077)    RAM_EPILOGUE RAM_USE_CLASS_1
0899: 7F       RET                      (1078)    ret
089A: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1079) .ENDSECTION
                                        (1080) 
                                        (1081) 
                                        (1082) IF (UART_RXBUF_ENABLE)
                                        (1083) ;=============================================================================
                                        (1084) ;=============================================================================
                                        (1085) ;
                                        (1086) ;     Command Buffer commands
                                        (1087) ;
                                        (1088) ;=============================================================================
                                        (1089) ;=============================================================================
                                        (1090) 
                                        (1091) .SECTION
                                        (1092) ;-----------------------------------------------------------------------------
                                        (1093) ;  FUNCTION NAME: UART_CmdReset
                                        (1094) ;
                                        (1095) ;  DESCRIPTION:
                                        (1096) ;     Reset command string and status flags
                                        (1097) ;-----------------------------------------------------------------------------
                                        (1098) ;
                                        (1099) ;  ARGUMENTS:
                                        (1100) ;     none.
                                        (1101) ;
                                        (1102) ;  RETURNS:
                                        (1103) ;     none.
                                        (1104) ;
                                        (1105) ;  SIDE EFFECTS:
                                        (1106) ;    The A and X registers may be modified by this or future implementations
                                        (1107) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1108) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1109) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1110) ;    functions.
                                        (1111) ;          
                                        (1112) ;    Currently only the page pointer registers listed below are modified: 
                                        (1113) ;          CUR_PP
                                        (1114) ;
                                        (1115) ;  THEORY of OPERATION or PROCEDURE:
                                        (1116) ;     Clear the command buffer, command counter, and flag.
                                        (1117) ;
                                        (1118)  UART_CmdReset:
                                        (1119) _UART_CmdReset:
                                        (1120)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1121)    RAM_SETPAGE_CUR >UART_aRxBuffer
089D: 55 02 00 MOV   [0x2],0x0          (1122)    mov [UART_aRxBuffer], 0x00
08A0: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1123)    RAM_SETPAGE_CUR >UART_bRxCnt
08A3: 55 01 00 MOV   [0x1],0x0          (1124)    mov [UART_bRxCnt], 0x00
08A6: 26 00 00 AND   [0x0],0x0          (1125)    and [UART_fStatus], 0x00
08A9: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1126)    RAM_SETPAGE_CUR >ptrParam
08AC: 55 26 00 MOV   [curPrt1+1],0x0    (1127)    mov [ptrParam],0x00
                                        (1128)    RAM_EPILOGUE RAM_USE_CLASS_4
08AF: 7F       RET                      (1129)    ret
08B0: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1130) .ENDSECTION
                                        (1131) 
                                        (1132) 
                                        (1133) .SECTION
                                        (1134) ;-----------------------------------------------------------------------------
                                        (1135) ;  FUNCTION NAME: UART_bCmdCheck
                                        (1136) ;
                                        (1137) ;  DESCRIPTION:
                                        (1138) ;     Check to see if valid command in buffer.
                                        (1139) ;-----------------------------------------------------------------------------
                                        (1140) ;
                                        (1141) ;  ARGUMENTS:
                                        (1142) ;     none.
                                        (1143) ;
                                        (1144) ;  RETURNS:
                                        (1145) ;     BYTE  fStatus - Status of command receive buffer.
                                        (1146) ;                     Returns non-zero value in A if command is valid.
                                        (1147) ;
                                        (1148) ;  SIDE EFFECTS:
                                        (1149) ;    The A and X registers may be modified by this or future implementations
                                        (1150) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1151) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1152) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1153) ;    functions.
                                        (1154) ;          
                                        (1155) ;    Currently only the page pointer registers listed below are modified: 
                                        (1156) ;          CUR_PP
                                        (1157) ;
                                        (1158) ;  THEORY of OPERATION or PROCEDURE:
                                        (1159) ;     Read the status and control register.
                                        (1160) ;
                                        (1161)  UART_bCmdCheck:
                                        (1162) _UART_bCmdCheck:
                                        (1163)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1164)    RAM_SETPAGE_CUR >UART_fStatus
08B3: 51 00    MOV   A,[0x0]            (1165)    mov A,  [UART_fStatus]
08B5: 21 01    AND   A,0x1              (1166)    and A, UART_RX_BUF_CMDTERM                    ; Mask off Command status
                                        (1167)    RAM_EPILOGUE RAM_USE_CLASS_4
08B7: 7F       RET                      (1168)    ret
08B8: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1169) .ENDSECTION
                                        (1170)     
                                        (1171) 
                                        (1172) .SECTION
                                        (1173) ;-----------------------------------------------------------------------------
                                        (1174) ;  FUNCTION NAME: UART_bErrCheck
                                        (1175) ;
                                        (1176) ;  DESCRIPTION:
                                        (1177) ;     Check to see if an error has occured since last CmdReset
                                        (1178) ;-----------------------------------------------------------------------------
                                        (1179) ;
                                        (1180) ;  ARGUMENTS:
                                        (1181) ;     none.
                                        (1182) ;
                                        (1183) ;  RETURNS:
                                        (1184) ;     BYTE  fStatus - Status of command receive buffer.
                                        (1185) ;                     Returns non-zero value in A if command is valid.
                                        (1186) ;           0x80 => Parity Error
                                        (1187) ;           0x40 => OverRun Error
                                        (1188) ;           0x20 => Framing Error
                                        (1189) ;           0x10 => Software Buffer OverRun
                                        (1190) ;
                                        (1191) ;  SIDE EFFECTS:
                                        (1192) ;    The A and X registers may be modified by this or future implementations
                                        (1193) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1194) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1195) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1196) ;    functions.
                                        (1197) ;          
                                        (1198) ;    Currently only the page pointer registers listed below are modified: 
                                        (1199) ;          CUR_PP
                                        (1200) ;     Error Status is clear when read.
                                        (1201) ;
                                        (1202) ;  THEORY of OPERATION or PROCEDURE:
                                        (1203) ;     Read RX buffer error status and clear status
                                        (1204) ;
                                        (1205)  UART_bErrCheck:
                                        (1206) _UART_bErrCheck:
                                        (1207)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1208)    RAM_SETPAGE_CUR >UART_fStatus
08BB: 51 00    MOV   A,[0x0]            (1209)    mov A,  [UART_fStatus]
08BD: 21 F0    AND   A,0xF0             (1210)    and A, UART_RX_BUF_ERROR                      ; Mask off Error status
08BF: 26 00 0F AND   [0x0],0xF          (1211)    and [UART_fStatus], ~UART_RX_BUF_ERROR
                                        (1212)    RAM_EPILOGUE RAM_USE_CLASS_4
08C2: 7F       RET                      (1213)    ret
08C3: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1214) .ENDSECTION
                                        (1215) 
                                        (1216) .SECTION
                                        (1217) ;-----------------------------------------------------------------------------
                                        (1218) ;  FUNCTION NAME: UART_bCmdLength
                                        (1219) ;
                                        (1220) ;  DESCRIPTION:
                                        (1221) ;     Get length of command string
                                        (1222) ;-----------------------------------------------------------------------------
                                        (1223) ;
                                        (1224) ;  ARGUMENTS:
                                        (1225) ;     none.
                                        (1226) ;
                                        (1227) ;  RETURNS:
                                        (1228) ;     BYTE  bRxCnt    Returns the command length in A.
                                        (1229) ;
                                        (1230) ;  SIDE EFFECTS:
                                        (1231) ;    The A and X registers may be modified by this or future implementations
                                        (1232) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1234) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1235) ;    functions.
                                        (1236) ;          
                                        (1237) ;    Currently only the page pointer registers listed below are modified: 
                                        (1238) ;          CUR_PP
                                        (1239) ;
                                        (1240)  UART_bCmdLength:
                                        (1241) _UART_bCmdLength:
                                        (1242)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1243)    RAM_SETPAGE_CUR >UART_bRxCnt
08C6: 51 01    MOV   A,[0x1]            (1244)    mov A,  [UART_bRxCnt]
                                        (1245)    RAM_EPILOGUE RAM_USE_CLASS_4
08C8: 7F       RET                      (1246)    ret
08C9: 70 BF    AND   F,0xBF             
08CB: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1247) .ENDSECTION
                                        (1248) 
                                        (1249) 
                                        (1250) .SECTION
                                        (1251) ;-----------------------------------------------------------------------------
                                        (1252) ;  FUNCTION NAME: UART_szGetParam
                                        (1253) ;
                                        (1254) ;  DESCRIPTION:
                                        (1255) ;      Return next parameter from UART Rx buffer
                                        (1256) ;-----------------------------------------------------------------------------
                                        (1257) ;
                                        (1258) ;  ARGUMENTS:  none
                                        (1259) ;
                                        (1260) ;  RETURNS:
                                        (1261) ;     A => MSB of parameter address
                                        (1262) ;     X => LSB of parameter address
                                        (1263) ;
                                        (1264) ;  SIDE EFFECTS:
                                        (1265) ;    The A and X registers may be modified by this or future implementations
                                        (1266) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1268) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1269) ;    functions.
                                        (1270) ;          
                                        (1271) ;    Currently only the page pointer registers listed below are modified: 
                                        (1272) ;          CUR_PP
                                        (1273) ;          IDX_PP
                                        (1274) ;
                                        (1275) ;     The receive string is modified by placing Null characters at the end
                                        (1276) ;     of each parameter as they are recovered.
                                        (1277) ;
                                        (1278) ;  THEORY OF OPERATION:
                                        (1279) ;     This function is a stateful generator of addresses to the "parameters"
                                        (1280) ;     of an input "Command". It scans the (optional) input buffer and breaks
                                        (1281) ;     each lexically distinct element into a null-terminated string by replacing
                                        (1282) ;     delimiters with nulls, as appropriate. The state of the generator is 
                                        (1283) ;     maintained by the private variable ptrParam, which is a buffer-relative
                                        (1284) ;     offset. The generator is initialized by a call to the function
                                        (1285) ;     UART_CmdReset which resets the entire buffer to the 'empty'
                                        (1286) ;     state. Typically this function, UART_szGetParam, is
                                        (1287) ;     not called until the buffer has been loaded with an entire command
                                        (1288) ;     (See UART_bCmdCheck).
                                        (1289) ;
                                        (1290) ;     Note, there is no special distinction between the "command" and the 
                                        (1291) ;     "parameters". The first non-delimiter character of the buffer---the first
                                        (1292) ;     character of the "command"---is also, for the purposes of this function,
                                        (1293) ;     the first "parameter" to which it returns an address.
                                        (1294) ;
                                        (1295) ;     The value of a delimiter (commonly an ascii space, 0x20 and decimal 32)
                                        (1296) ;     is determined at configuration time by a user module parameter.
                                        (1297) ;
                                        (1298)  UART_szGetParam:
                                        (1299) _UART_szGetParam:
                                        (1300)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1301)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (1302)     
                                        (1303)    RAM_SETPAGE_CUR >ptrParam
08CE: 50 02    MOV   A,0x2              (1304)    mov   A, <UART_aRxBuffer                 ; Get address to receive buffer
08D0: 02 26    ADD   A,[curPrt1+1]      (1305)    add   A, [ptrParam]                      ; Add string offset
08D2: 5C       MOV   X,A                (1306)    mov   X, A
08D3: 62 D3 00 MOV   REG[0xD3],0x0      
                                        (1307)    RAM_SETPAGE_IDX >UART_aRxBuffer
08D6: 52 00    MOV   A,[X+0]            (1308)    mov   A, [X]                             ; Get character pointed by X
08D8: B0 04    JNZ   0x08DD             (1309)    jnz   .SkipOverDelimitersLoop            ; Null? No,  continue...
08DA: 10       PUSH  X                  (1310)    push  X                                  ;       Yes, Save LSB of current pointer
08DB: 80 33    JMP   0x090F             (1311)    jmp   .End_GetNextParam
                                        (1312)                                             ; Check for delimiter and keep looping until
                                        (1313)                                             ; all leading delimiters have been found.
                                        (1314) .SkipOverDelimitersLoop:
08DD: 39 20    CMP   A,0x20             (1315)    cmp   A, UART_DELIMITER                  ; Do we have a delimiter?
08DF: B0 11    JNZ   0x08F1             (1316)    jnz   .ParamStartFound                   ;   No,  Bingo! found a parameter
08E1: 75       INC   X                  (1317)    inc   X                                  ;   Yes, Increment both index and...
08E2: 76 26    INC   [curPrt1+1]        (1318)    inc   [ptrParam]                         ;          the stored pointer.
08E4: 52 00    MOV   A,[X+0]            (1319)    mov   A, [X]                             ; Get character pointed by X
08E6: 3C 26 0F CMP   [curPrt1+1],0xF    (1320)    cmp   [ptrParam], (UART_RX_BUFFER_SIZE -1)   ; End of buffer?
08E9: BF F3    JNZ   0x08DD             (1321)    jnz   .SkipOverDelimitersLoop            ;   No,  continue the scan
                                        (1322) 
                                        (1323) .EndOfString:                               ;   Yes, end of string found...
08EB: 10       PUSH  X                  (1324)    push  X                                  ;        Save ptr
                                        (1325) .TerminateString:
08EC: 56 00 00 MOV   [X+0],0x0          (1326)    mov   [X], 0x00                          ; Make sure string is zero
08EF: 80 1F    JMP   0x090F             (1327)    jmp   .End_GetNextParam
                                        (1328) 
                                        (1329) .ParamStartFound:
08F1: 10       PUSH  X                  (1330)    push  X                                  ; Beginning of parameter found, save pointer
                                        (1331) 
                                        (1332) .ParamLoop:                                 ; Now loop until end of parameter found.
08F2: 75       INC   X                  (1333)    inc   X                                  ; Advance pointers.
08F3: 76 26    INC   [curPrt1+1]        (1334)    inc   [ptrParam]
08F5: 3C 26 0F CMP   [curPrt1+1],0xF    (1335)    cmp   [ptrParam], (UART_RX_BUFFER_SIZE -1)   ; Check if we are at the end of buffer
08F8: AF F3    JZ    0x08EC             (1336)    jz    .TerminateString
08FA: 52 00    MOV   A,[X+0]            (1337)    mov   A, [X]                             ; Get next character
08FC: A0 12    JZ    0x090F             (1338)    jz    .End_GetNextParam
08FE: 39 20    CMP   A,0x20             (1339)    cmp   A, UART_DELIMITER                  ; Check if we have a delimiter
0900: BF F1    JNZ   0x08F2             (1340)    jnz   .ParamLoop                         ; Still no delimiter, loop again
0902: 56 00 00 MOV   [X+0],0x0          (1341)    mov   [X], 0x00                          ; Replace delimiter with null for end of substring
0905: 76 26    INC   [curPrt1+1]        (1342)    inc   [ptrParam]
0907: 3C 26 0F CMP   [curPrt1+1],0xF    (1343)    cmp   [ptrParam], (UART_RX_BUFFER_SIZE -1)   ; Check if we are at the end of buffer
090A: B0 04    JNZ   0x090F             (1344)    jnz   .End_GetNextParam                  ; If not end of string leave
090C: 55 26 0F MOV   [curPrt1+1],0xF    (1345)    mov   [ptrParam], (UART_RX_BUFFER_SIZE -1)   ; Reset pointer to end of string.
                                        (1346) 
                                        (1347) .End_GetNextParam:
090F: 20       POP   X                  (1348)    pop   X
0910: 10       PUSH  X                  (1349)    push  X
0911: 3D 00 00 CMP   [X+0],0x0          (1350)    cmp   [X], 0x00
0914: B0 0A    JNZ   0x091F             (1351)    jnz   .NotNullString
0916: 20       POP   X                  (1352)    pop   X
0917: 57 00    MOV   X,0x0              (1353)    mov   X, 0x00
0919: 5B       MOV   A,X                (1354)    mov   A, X
091A: 70 3F    AND   F,0x3F             
091C: 71 C0    OR    F,0xC0             
                                        (1355)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (1356)    RAM_EPILOGUE RAM_USE_CLASS_4
091E: 7F       RET                      (1357)    ret
                                        (1358) 
                                        (1359) .NotNullString:
091F: 20       POP   X                  (1360)    pop  X
0920: 50 00    MOV   A,0x0              (1361)    mov  A, >UART_aRxBuffer                  ; Return pointer
0922: 70 3F    AND   F,0x3F             
0924: 71 C0    OR    F,0xC0             
                                        (1362)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (1363)    RAM_EPILOGUE RAM_USE_CLASS_4
0926: 7F       RET                      (1364)    ret
0927: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1365) .ENDSECTION
                                        (1366) 
                                        (1367) 
                                        (1368) .SECTION
                                        (1369) ;-----------------------------------------------------------------------------
                                        (1370) ;  FUNCTION NAME: UART_szGetRestOfParams
                                        (1371) ;
                                        (1372) ;  DESCRIPTION:
                                        (1373) ;      Returns a pointer to the rest of the UART RX buffer
                                        (1374) ;-----------------------------------------------------------------------------
                                        (1375) ;
                                        (1376) ;  ARGUMENTS:  none
                                        (1377) ;
                                        (1378) ;  RETURNS:
                                        (1379) ;     A => MSB of parameter
                                        (1380) ;     X => LSB of parameter
                                        (1381) ;
                                        (1382) ;  SIDE EFFECTS:
                                        (1383) ;    The A and X registers may be modified by this or future implementations
                                        (1384) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1385) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1386) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1387) ;    functions.
                                        (1388) ;          
                                        (1389) ;    Currently only the page pointer registers listed below are modified: 
                                        (1390) ;          CUR_PP
                                        (1391) ;
                                        (1392)  UART_szGetRestOfParams:
                                        (1393) _UART_szGetRestOfParams:
                                        (1394)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1395)    RAM_SETPAGE_CUR >ptrParam
092A: 50 02    MOV   A,0x2              (1396)    mov  A, <UART_aRxBuffer                  ; Get address to receive buffer
092C: 02 26    ADD   A,[curPrt1+1]      (1397)    add  A, [ptrParam]                       ; Add string offset
092E: 5C       MOV   X,A                (1398)    mov  X,A
092F: 50 00    MOV   A,0x0              (1399)    mov  A,>UART_aRxBuffer                   ; Return pointer
                                        (1400)    RAM_EPILOGUE RAM_USE_CLASS_4
0931: 7F       RET                      (1401)    ret
                                        (1402) .ENDSECTION
                                        (1403) 
                                        (1404) ENDIF
                                        (1405) 
                                        (1406) 
                                        (1407) ; End of File UART.asm
FILE: lib\servo1int.asm                 (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Servo1INT.asm
                                        (0004) ;;   Version: 2.5, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "Servo1.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _Servo1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _Servo1_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _Servo1_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
                                        (0081)    ;lcall _My_C_Function
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
0932: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file Servo1INT.asm
FILE: lib\servo1.asm                    (0001) ;;*****************************************************************************
0933: 43 DF 08 OR    REG[0xDF],0x8      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Servo1.asm
                                        (0004) ;;   Version: 2.5, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "Servo1.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  Servo1_EnableInt
                                        (0030) export _Servo1_EnableInt
                                        (0031) export  Servo1_DisableInt
                                        (0032) export _Servo1_DisableInt
                                        (0033) export  Servo1_Start
                                        (0034) export _Servo1_Start
                                        (0035) export  Servo1_Stop
                                        (0036) export _Servo1_Stop
                                        (0037) export  Servo1_WritePeriod
                                        (0038) export _Servo1_WritePeriod
                                        (0039) export  Servo1_WritePulseWidth
                                        (0040) export _Servo1_WritePulseWidth
                                        (0041) export  Servo1_wReadPulseWidth
                                        (0042) export _Servo1_wReadPulseWidth
                                        (0043) export  Servo1_wReadCounter
                                        (0044) export _Servo1_wReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  wServo1_ReadPulseWidth    ; deprecated
                                        (0049) export _wServo1_ReadPulseWidth    ; deprecated
                                        (0050) export  wServo1_ReadCounter       ; deprecated
                                        (0051) export _wServo1_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) 
                                        (0054) AREA kipr_2_RAM (RAM,REL)
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Constant Definitions
                                        (0058) ;-----------------------------------------------
                                        (0059) 
                                        (0060) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0061) 
                                        (0062) 
                                        (0063) ;-----------------------------------------------
                                        (0064) ; Variable Allocation
                                        (0065) ;-----------------------------------------------
                                        (0066) 
                                        (0067) 
                                        (0068) AREA UserModules (ROM, REL)
                                        (0069) 
                                        (0070) .SECTION
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;  FUNCTION NAME: Servo1_EnableInt
                                        (0073) ;
                                        (0074) ;  DESCRIPTION:
                                        (0075) ;     Enables this PWM's interrupt by setting the interrupt enable mask bit
                                        (0076) ;     associated with this User Module. This function has no effect until and
                                        (0077) ;     unless the global interrupts are enabled (for example by using the
                                        (0078) ;     macro M8C_EnableGInt).
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;
                                        (0081) ;  ARGUMENTS:    None.
                                        (0082) ;  RETURNS:      Nothing.
                                        (0083) ;  SIDE EFFECTS: 
                                        (0084) ;    The A and X registers may be modified by this or future implementations
                                        (0085) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0086) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0087) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0088) ;    functions.
                                        (0089) ;
                                        (0090)  Servo1_EnableInt:
                                        (0091) _Servo1_EnableInt:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0093)    Servo1_EnableInt_M
                                        (0094)    RAM_EPILOGUE RAM_USE_CLASS_1
0936: 7F       RET                      (0095)    ret
0937: 41 DF F7 AND   REG[0xDF],0xF7     
                                        (0096) 
                                        (0097) 
                                        (0098) .ENDSECTION
                                        (0099) 
                                        (0100) .SECTION
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;  FUNCTION NAME: Servo1_DisableInt
                                        (0103) ;
                                        (0104) ;  DESCRIPTION:
                                        (0105) ;     Disables this PWM's interrupt by clearing the interrupt enable
                                        (0106) ;     mask bit associated with this User Module.
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS:    None
                                        (0110) ;  RETURNS:      Nothing
                                        (0111) ;  SIDE EFFECTS:
                                        (0112) ;    The A and X registers may be modified by this or future implementations
                                        (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0116) ;    functions.
                                        (0117) ;
                                        (0118)  Servo1_DisableInt:
                                        (0119) _Servo1_DisableInt:
                                        (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0121)    Servo1_DisableInt_M
                                        (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
093A: 7F       RET                      (0123)    ret
093B: 43 4B 01 OR    REG[0x4B],0x1      
                                        (0124) 
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: Servo1_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit in the Control register of this user module.  The
                                        (0134) ;     PWM will begin counting on the next input clock as soon as the
                                        (0135) ;     enable input is asserted high.
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;
                                        (0138) ;  ARGUMENTS:    None
                                        (0139) ;  RETURNS:      Nothing
                                        (0140) ;  SIDE EFFECTS:
                                        (0141) ;    The A and X registers may be modified by this or future implementations
                                        (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0145) ;    functions.
                                        (0146) ;
                                        (0147)  Servo1_Start:
                                        (0148) _Servo1_Start:
                                        (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0150)    Servo1_Start_M
                                        (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
093E: 7F       RET                      (0152)    ret
093F: 41 4B FE AND   REG[0x4B],0xFE     
                                        (0153) 
                                        (0154) 
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: Servo1_Stop
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:
                                        (0162) ;     Disables PWM operation by clearing the start bit in the Control
                                        (0163) ;     register of the LSB block.
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;
                                        (0166) ;  ARGUMENTS:    None
                                        (0167) ;  RETURNS:      Nothing
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  Servo1_Stop:
                                        (0176) _Servo1_Stop:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0178)    Servo1_Stop_M
                                        (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
0942: 7F       RET                      (0180)    ret
                                        (0181) 
                                        (0182) 
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185) .SECTION
                                        (0186) ;-----------------------------------------------------------------------------
                                        (0187) ;  FUNCTION NAME: Servo1_WritePeriod
                                        (0188) ;
                                        (0189) ;  DESCRIPTION:
                                        (0190) ;     Write the 16-bit period value into the Period register (DR1).
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                        (0194) ;  RETURNS:   Nothing
                                        (0195) ;  SIDE EFFECTS:
                                        (0196) ;    If the PWM user module is stopped, then this value will also be
                                        (0197) ;    latched into the Count registers (DR0).
                                        (0198) ;    
                                        (0199) ;    The A and X registers may be modified by this or future implementations
                                        (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0203) ;    functions.
                                        (0204) ;
                                        (0205)  Servo1_WritePeriod:
                                        (0206) _Servo1_WritePeriod:
                                        (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
0943: 60 49    MOV   REG[0x49],A        (0208)    mov   reg[Servo1_PERIOD_LSB_REG], A
0945: 5B       MOV   A,X                (0209)    mov   A, X
0946: 60 4D    MOV   REG[0x4D],A        (0210)    mov   reg[Servo1_PERIOD_MSB_REG], A
                                        (0211)    RAM_EPILOGUE RAM_USE_CLASS_1
0948: 7F       RET                      (0212)    ret
                                        (0213) 
                                        (0214) 
                                        (0215) .ENDSECTION
                                        (0216) 
                                        (0217) .SECTION
                                        (0218) ;-----------------------------------------------------------------------------
                                        (0219) ;  FUNCTION NAME: Servo1_WritePulseWidth
                                        (0220) ;
                                        (0221) ;  DESCRIPTION:
                                        (0222) ;     Writes the pulse width value into the Compare register (DR2).
                                        (0223) ;-----------------------------------------------------------------------------
                                        (0224) ;
                                        (0225) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
                                        (0226) ;  RETURNS:      Nothing
                                        (0227) ;  SIDE EFFECTS:
                                        (0228) ;    The A and X registers may be modified by this or future implementations
                                        (0229) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0230) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0231) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0232) ;    functions.
                                        (0233) ;
                                        (0234)  Servo1_WritePulseWidth:
                                        (0235) _Servo1_WritePulseWidth:
                                        (0236)    RAM_PROLOGUE RAM_USE_CLASS_1
0949: 60 4A    MOV   REG[0x4A],A        (0237)    mov   reg[Servo1_COMPARE_LSB_REG], A
094B: 5B       MOV   A,X                (0238)    mov   A, X
094C: 60 4E    MOV   REG[0x4E],A        (0239)    mov   reg[Servo1_COMPARE_MSB_REG], A
                                        (0240)    RAM_EPILOGUE RAM_USE_CLASS_1
094E: 7F       RET                      (0241)    ret
                                        (0242) 
                                        (0243) 
                                        (0244) .ENDSECTION
                                        (0245) 
                                        (0246) .SECTION
                                        (0247) ;-----------------------------------------------------------------------------
                                        (0248) ;  FUNCTION NAME: Servo1_wReadPulseWidth
                                        (0249) ;
                                        (0250) ;  DESCRIPTION:
                                        (0251) ;     Reads the Compare register.
                                        (0252) ;-----------------------------------------------------------------------------
                                        (0253) ;
                                        (0254) ;  ARGUMENTS:    None
                                        (0255) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                        (0256) ;  SIDE EFFECTS:
                                        (0257) ;    The A and X registers may be modified by this or future implementations
                                        (0258) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0259) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0260) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0261) ;    functions.
                                        (0262) ;
                                        (0263)  Servo1_wReadPulseWidth:
                                        (0264) _Servo1_wReadPulseWidth:
                                        (0265)  wServo1_ReadPulseWidth:                         ; this name deprecated
                                        (0266) _wServo1_ReadPulseWidth:                         ; this name deprecated
                                        (0267)    RAM_PROLOGUE RAM_USE_CLASS_1
094F: 5D 4E    MOV   A,REG[0x4E]        (0268)    mov   A, reg[Servo1_COMPARE_MSB_REG]
0951: 5C       MOV   X,A                (0269)    mov   X, A
0952: 5D 4A    MOV   A,REG[0x4A]        (0270)    mov   A, reg[Servo1_COMPARE_LSB_REG]
                                        (0271)    RAM_EPILOGUE RAM_USE_CLASS_1
0954: 7F       RET                      (0272)    ret
                                        (0273) 
                                        (0274) 
                                        (0275) .ENDSECTION
                                        (0276) 
                                        (0277) .SECTION
                                        (0278) ;-----------------------------------------------------------------------------
                                        (0279) ;  FUNCTION NAME: Servo1_wReadCounter
                                        (0280) ;
                                        (0281) ;  DESCRIPTION:
                                        (0282) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0283) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0284) ;     from the Count to the Compare register by holding the clock low in
                                        (0285) ;     the MSB PSoC block.
                                        (0286) ;-----------------------------------------------------------------------------
                                        (0287) ;
                                        (0288) ;  ARGUMENTS: None
                                        (0289) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                        (0290) ;  SIDE EFFECTS:
                                        (0291) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0292) ;     2) The A and X registers may be modified by this or future implementations
                                        (0293) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0294) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0295) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0296) ;        functions.
                                        (0297) ;
                                        (0298)  Servo1_wReadCounter:
                                        (0299) _Servo1_wReadCounter:
                                        (0300)  wServo1_ReadCounter:                            ; this name deprecated
                                        (0301) _wServo1_ReadCounter:                            ; this name deprecated
                                        (0302) 
                                        (0303)    bOrigCompareValue:      EQU   0                  ; Frame offset to temp Compare store
                                        (0304)    bOrigClockSetting:      EQU   2                  ; Frame offset to temp Input   store
                                        (0305)    wCounter:               EQU   3                  ; Frame offset to temp Count   store
                                        (0306)    STACK_FRAME_SIZE:       EQU   5                  ; max stack frame size is 5 bytes
                                        (0307) 
                                        (0308)    RAM_PROLOGUE RAM_USE_CLASS_2
0955: 4F       MOV   X,SP               (0309)    mov   X, SP                                      ; X <-  stack frame pointer
0956: 5D 4E    MOV   A,REG[0x4E]        (0310)    mov   A, reg[Servo1_COMPARE_MSB_REG]          ; Save the Compare register on the stack
0958: 08       PUSH  A                  (0311)    push  A                                          ;
0959: 5D 4A    MOV   A,REG[0x4A]        (0312)    mov   A, reg[Servo1_COMPARE_LSB_REG]          ;
095B: 08       PUSH  A                  (0313)    push  A                                          ;  -stack frame now 2 bytes-
095C: 41 4B FE AND   REG[0x4B],0xFE     
095F: 71 10    OR    F,0x10             
                                        (0314)    Servo1_Stop_M                                 ; Disable the PWM function
                                        (0315)    M8C_SetBank1                                     ;
0961: 5D 49    MOV   A,REG[0x49]        (0316)    mov   A, reg[Servo1_INPUT_LSB_REG]            ; save the LSB clock input setting
0963: 08       PUSH  A                  (0317)    push  A                                          ;   on the stack (now 3 bytes) and ...
                                        (0318)                                                     ;   hold the clock low:
0964: 62 49 00 MOV   REG[0x49],0x0      (0319)    mov   reg[Servo1_INPUT_LSB_REG], INPUT_REG_NULL
0967: 70 EF    AND   F,0xEF             
                                        (0320)    M8C_SetBank0                                     ; Extract the Count via DR2 register
0969: 5D 4C    MOV   A,REG[0x4C]        (0321)    mov   A, reg[Servo1_COUNTER_MSB_REG]          ; DR2 <- DR0 (in the MSB block)
096B: 5D 4E    MOV   A,REG[0x4E]        (0322)    mov   A, reg[Servo1_COMPARE_MSB_REG]          ; Stash the Count MSB on the stack
096D: 08       PUSH  A                  (0323)    push  A                                          ;  -stack frame is now 4 bytes
096E: 5D 48    MOV   A,REG[0x48]        (0324)    mov   A, reg[Servo1_COUNTER_LSB_REG]          ; DR2 <- DR0 (in the LSB block)
0970: 5D 4A    MOV   A,REG[0x4A]        (0325)    mov   A, reg[Servo1_COMPARE_LSB_REG]          ; Stash the Count LSB on the stack
0972: 08       PUSH  A                  (0326)    push  A                                          ;   -stack frame is now 5 bytes-
0973: 52 00    MOV   A,[X+0]            (0327)    mov   A, [X+bOrigCompareValue]                   ; Restore the Compare MSB register
0975: 60 4E    MOV   REG[0x4E],A        (0328)    mov   reg[Servo1_COMPARE_MSB_REG], A          ;
0977: 52 01    MOV   A,[X+1]            (0329)    mov   A, [X+bOrigCompareValue+1]                 ; Restore the Compare LSB register
0979: 60 4A    MOV   REG[0x4A],A        (0330)    mov   reg[Servo1_COMPARE_LSB_REG], A          ;
097B: 71 10    OR    F,0x10             
                                        (0331)    M8C_SetBank1                                     ; ---Restore the PWM operation
097D: 52 02    MOV   A,[X+2]            (0332)    mov   A, [X+bOrigClockSetting]                   ; Grab the LSB clock setting...
097F: 60 49    MOV   REG[0x49],A        (0333)    mov   reg[Servo1_INPUT_LSB_REG], A            ;    and restore it
0981: 70 EF    AND   F,0xEF             
0983: 43 4B 01 OR    REG[0x4B],0x1      
                                        (0334)    M8C_SetBank0                                     ;
                                        (0335)    Servo1_Start_M                                ; Now re-enable the PWM function
0986: 18       POP   A                  (0336)    pop   A                                          ; Setup the return value
0987: 20       POP   X                  (0337)    pop   X                                          ;
0988: 38 FD    ADD   SP,0xFD            (0338)    ADD   SP, -(STACK_FRAME_SIZE-2)                  ; Zap remainder of stack frame
098A: 70 3F    AND   F,0x3F             
098C: 71 C0    OR    F,0xC0             
                                        (0339)    RAM_EPILOGUE RAM_USE_CLASS_2
098E: 7F       RET                      (0340)    ret
                                        (0341) 
                                        (0342) .ENDSECTION
                                        (0343) 
                                        (0344) ; End of File Servo1.asm
FILE: lib\servo0int.asm                 (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Servo0INT.asm
                                        (0004) ;;   Version: 2.5, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "Servo0.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _Servo0_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _Servo0_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _Servo0_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
                                        (0081)    ;lcall _My_C_Function
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
098F: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file Servo0INT.asm
FILE: lib\servo0.asm                    (0001) ;;*****************************************************************************
0990: 43 E1 04 OR    REG[0xE1],0x4      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Servo0.asm
                                        (0004) ;;   Version: 2.5, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "Servo0.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  Servo0_EnableInt
                                        (0030) export _Servo0_EnableInt
                                        (0031) export  Servo0_DisableInt
                                        (0032) export _Servo0_DisableInt
                                        (0033) export  Servo0_Start
                                        (0034) export _Servo0_Start
                                        (0035) export  Servo0_Stop
                                        (0036) export _Servo0_Stop
                                        (0037) export  Servo0_WritePeriod
                                        (0038) export _Servo0_WritePeriod
                                        (0039) export  Servo0_WritePulseWidth
                                        (0040) export _Servo0_WritePulseWidth
                                        (0041) export  Servo0_wReadPulseWidth
                                        (0042) export _Servo0_wReadPulseWidth
                                        (0043) export  Servo0_wReadCounter
                                        (0044) export _Servo0_wReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  wServo0_ReadPulseWidth    ; deprecated
                                        (0049) export _wServo0_ReadPulseWidth    ; deprecated
                                        (0050) export  wServo0_ReadCounter       ; deprecated
                                        (0051) export _wServo0_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) 
                                        (0054) AREA kipr_2_RAM (RAM,REL)
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Constant Definitions
                                        (0058) ;-----------------------------------------------
                                        (0059) 
                                        (0060) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0061) 
                                        (0062) 
                                        (0063) ;-----------------------------------------------
                                        (0064) ; Variable Allocation
                                        (0065) ;-----------------------------------------------
                                        (0066) 
                                        (0067) 
                                        (0068) AREA UserModules (ROM, REL)
                                        (0069) 
                                        (0070) .SECTION
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;  FUNCTION NAME: Servo0_EnableInt
                                        (0073) ;
                                        (0074) ;  DESCRIPTION:
                                        (0075) ;     Enables this PWM's interrupt by setting the interrupt enable mask bit
                                        (0076) ;     associated with this User Module. This function has no effect until and
                                        (0077) ;     unless the global interrupts are enabled (for example by using the
                                        (0078) ;     macro M8C_EnableGInt).
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;
                                        (0081) ;  ARGUMENTS:    None.
                                        (0082) ;  RETURNS:      Nothing.
                                        (0083) ;  SIDE EFFECTS: 
                                        (0084) ;    The A and X registers may be modified by this or future implementations
                                        (0085) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0086) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0087) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0088) ;    functions.
                                        (0089) ;
                                        (0090)  Servo0_EnableInt:
                                        (0091) _Servo0_EnableInt:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0093)    Servo0_EnableInt_M
                                        (0094)    RAM_EPILOGUE RAM_USE_CLASS_1
0993: 7F       RET                      (0095)    ret
0994: 41 E1 FB AND   REG[0xE1],0xFB     
                                        (0096) 
                                        (0097) 
                                        (0098) .ENDSECTION
                                        (0099) 
                                        (0100) .SECTION
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;  FUNCTION NAME: Servo0_DisableInt
                                        (0103) ;
                                        (0104) ;  DESCRIPTION:
                                        (0105) ;     Disables this PWM's interrupt by clearing the interrupt enable
                                        (0106) ;     mask bit associated with this User Module.
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS:    None
                                        (0110) ;  RETURNS:      Nothing
                                        (0111) ;  SIDE EFFECTS:
                                        (0112) ;    The A and X registers may be modified by this or future implementations
                                        (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0116) ;    functions.
                                        (0117) ;
                                        (0118)  Servo0_DisableInt:
                                        (0119) _Servo0_DisableInt:
                                        (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0121)    Servo0_DisableInt_M
                                        (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
0997: 7F       RET                      (0123)    ret
0998: 43 27 01 OR    REG[0x27],0x1      
                                        (0124) 
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: Servo0_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit in the Control register of this user module.  The
                                        (0134) ;     PWM will begin counting on the next input clock as soon as the
                                        (0135) ;     enable input is asserted high.
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;
                                        (0138) ;  ARGUMENTS:    None
                                        (0139) ;  RETURNS:      Nothing
                                        (0140) ;  SIDE EFFECTS:
                                        (0141) ;    The A and X registers may be modified by this or future implementations
                                        (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0145) ;    functions.
                                        (0146) ;
                                        (0147)  Servo0_Start:
                                        (0148) _Servo0_Start:
                                        (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0150)    Servo0_Start_M
                                        (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
099B: 7F       RET                      (0152)    ret
099C: 41 27 FE AND   REG[0x27],0xFE     
                                        (0153) 
                                        (0154) 
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: Servo0_Stop
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:
                                        (0162) ;     Disables PWM operation by clearing the start bit in the Control
                                        (0163) ;     register of the LSB block.
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;
                                        (0166) ;  ARGUMENTS:    None
                                        (0167) ;  RETURNS:      Nothing
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  Servo0_Stop:
                                        (0176) _Servo0_Stop:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0178)    Servo0_Stop_M
                                        (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
099F: 7F       RET                      (0180)    ret
                                        (0181) 
                                        (0182) 
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185) .SECTION
                                        (0186) ;-----------------------------------------------------------------------------
                                        (0187) ;  FUNCTION NAME: Servo0_WritePeriod
                                        (0188) ;
                                        (0189) ;  DESCRIPTION:
                                        (0190) ;     Write the 16-bit period value into the Period register (DR1).
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                        (0194) ;  RETURNS:   Nothing
                                        (0195) ;  SIDE EFFECTS:
                                        (0196) ;    If the PWM user module is stopped, then this value will also be
                                        (0197) ;    latched into the Count registers (DR0).
                                        (0198) ;    
                                        (0199) ;    The A and X registers may be modified by this or future implementations
                                        (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0203) ;    functions.
                                        (0204) ;
                                        (0205)  Servo0_WritePeriod:
                                        (0206) _Servo0_WritePeriod:
                                        (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
09A0: 60 25    MOV   REG[0x25],A        (0208)    mov   reg[Servo0_PERIOD_LSB_REG], A
09A2: 5B       MOV   A,X                (0209)    mov   A, X
09A3: 60 29    MOV   REG[0x29],A        (0210)    mov   reg[Servo0_PERIOD_MSB_REG], A
                                        (0211)    RAM_EPILOGUE RAM_USE_CLASS_1
09A5: 7F       RET                      (0212)    ret
                                        (0213) 
                                        (0214) 
                                        (0215) .ENDSECTION
                                        (0216) 
                                        (0217) .SECTION
                                        (0218) ;-----------------------------------------------------------------------------
                                        (0219) ;  FUNCTION NAME: Servo0_WritePulseWidth
                                        (0220) ;
                                        (0221) ;  DESCRIPTION:
                                        (0222) ;     Writes the pulse width value into the Compare register (DR2).
                                        (0223) ;-----------------------------------------------------------------------------
                                        (0224) ;
                                        (0225) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
                                        (0226) ;  RETURNS:      Nothing
                                        (0227) ;  SIDE EFFECTS:
                                        (0228) ;    The A and X registers may be modified by this or future implementations
                                        (0229) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0230) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0231) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0232) ;    functions.
                                        (0233) ;
                                        (0234)  Servo0_WritePulseWidth:
                                        (0235) _Servo0_WritePulseWidth:
                                        (0236)    RAM_PROLOGUE RAM_USE_CLASS_1
09A6: 60 26    MOV   REG[0x26],A        (0237)    mov   reg[Servo0_COMPARE_LSB_REG], A
09A8: 5B       MOV   A,X                (0238)    mov   A, X
09A9: 60 2A    MOV   REG[0x2A],A        (0239)    mov   reg[Servo0_COMPARE_MSB_REG], A
                                        (0240)    RAM_EPILOGUE RAM_USE_CLASS_1
09AB: 7F       RET                      (0241)    ret
                                        (0242) 
                                        (0243) 
                                        (0244) .ENDSECTION
                                        (0245) 
                                        (0246) .SECTION
                                        (0247) ;-----------------------------------------------------------------------------
                                        (0248) ;  FUNCTION NAME: Servo0_wReadPulseWidth
                                        (0249) ;
                                        (0250) ;  DESCRIPTION:
                                        (0251) ;     Reads the Compare register.
                                        (0252) ;-----------------------------------------------------------------------------
                                        (0253) ;
                                        (0254) ;  ARGUMENTS:    None
                                        (0255) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                        (0256) ;  SIDE EFFECTS:
                                        (0257) ;    The A and X registers may be modified by this or future implementations
                                        (0258) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0259) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0260) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0261) ;    functions.
                                        (0262) ;
                                        (0263)  Servo0_wReadPulseWidth:
                                        (0264) _Servo0_wReadPulseWidth:
                                        (0265)  wServo0_ReadPulseWidth:                         ; this name deprecated
                                        (0266) _wServo0_ReadPulseWidth:                         ; this name deprecated
                                        (0267)    RAM_PROLOGUE RAM_USE_CLASS_1
09AC: 5D 2A    MOV   A,REG[0x2A]        (0268)    mov   A, reg[Servo0_COMPARE_MSB_REG]
09AE: 5C       MOV   X,A                (0269)    mov   X, A
09AF: 5D 26    MOV   A,REG[0x26]        (0270)    mov   A, reg[Servo0_COMPARE_LSB_REG]
                                        (0271)    RAM_EPILOGUE RAM_USE_CLASS_1
09B1: 7F       RET                      (0272)    ret
                                        (0273) 
                                        (0274) 
                                        (0275) .ENDSECTION
                                        (0276) 
                                        (0277) .SECTION
                                        (0278) ;-----------------------------------------------------------------------------
                                        (0279) ;  FUNCTION NAME: Servo0_wReadCounter
                                        (0280) ;
                                        (0281) ;  DESCRIPTION:
                                        (0282) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0283) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0284) ;     from the Count to the Compare register by holding the clock low in
                                        (0285) ;     the MSB PSoC block.
                                        (0286) ;-----------------------------------------------------------------------------
                                        (0287) ;
                                        (0288) ;  ARGUMENTS: None
                                        (0289) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                        (0290) ;  SIDE EFFECTS:
                                        (0291) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0292) ;     2) The A and X registers may be modified by this or future implementations
                                        (0293) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0294) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0295) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0296) ;        functions.
                                        (0297) ;
                                        (0298)  Servo0_wReadCounter:
                                        (0299) _Servo0_wReadCounter:
                                        (0300)  wServo0_ReadCounter:                            ; this name deprecated
                                        (0301) _wServo0_ReadCounter:                            ; this name deprecated
                                        (0302) 
                                        (0303)    bOrigCompareValue:      EQU   0                  ; Frame offset to temp Compare store
                                        (0304)    bOrigClockSetting:      EQU   2                  ; Frame offset to temp Input   store
                                        (0305)    wCounter:               EQU   3                  ; Frame offset to temp Count   store
                                        (0306)    STACK_FRAME_SIZE:       EQU   5                  ; max stack frame size is 5 bytes
                                        (0307) 
                                        (0308)    RAM_PROLOGUE RAM_USE_CLASS_2
09B2: 4F       MOV   X,SP               (0309)    mov   X, SP                                      ; X <-  stack frame pointer
09B3: 5D 2A    MOV   A,REG[0x2A]        (0310)    mov   A, reg[Servo0_COMPARE_MSB_REG]          ; Save the Compare register on the stack
09B5: 08       PUSH  A                  (0311)    push  A                                          ;
09B6: 5D 26    MOV   A,REG[0x26]        (0312)    mov   A, reg[Servo0_COMPARE_LSB_REG]          ;
09B8: 08       PUSH  A                  (0313)    push  A                                          ;  -stack frame now 2 bytes-
09B9: 41 27 FE AND   REG[0x27],0xFE     
09BC: 71 10    OR    F,0x10             
                                        (0314)    Servo0_Stop_M                                 ; Disable the PWM function
                                        (0315)    M8C_SetBank1                                     ;
09BE: 5D 25    MOV   A,REG[0x25]        (0316)    mov   A, reg[Servo0_INPUT_LSB_REG]            ; save the LSB clock input setting
09C0: 08       PUSH  A                  (0317)    push  A                                          ;   on the stack (now 3 bytes) and ...
                                        (0318)                                                     ;   hold the clock low:
09C1: 62 25 00 MOV   REG[0x25],0x0      (0319)    mov   reg[Servo0_INPUT_LSB_REG], INPUT_REG_NULL
09C4: 70 EF    AND   F,0xEF             
                                        (0320)    M8C_SetBank0                                     ; Extract the Count via DR2 register
09C6: 5D 28    MOV   A,REG[0x28]        (0321)    mov   A, reg[Servo0_COUNTER_MSB_REG]          ; DR2 <- DR0 (in the MSB block)
09C8: 5D 2A    MOV   A,REG[0x2A]        (0322)    mov   A, reg[Servo0_COMPARE_MSB_REG]          ; Stash the Count MSB on the stack
09CA: 08       PUSH  A                  (0323)    push  A                                          ;  -stack frame is now 4 bytes
09CB: 5D 24    MOV   A,REG[0x24]        (0324)    mov   A, reg[Servo0_COUNTER_LSB_REG]          ; DR2 <- DR0 (in the LSB block)
09CD: 5D 26    MOV   A,REG[0x26]        (0325)    mov   A, reg[Servo0_COMPARE_LSB_REG]          ; Stash the Count LSB on the stack
09CF: 08       PUSH  A                  (0326)    push  A                                          ;   -stack frame is now 5 bytes-
09D0: 52 00    MOV   A,[X+0]            (0327)    mov   A, [X+bOrigCompareValue]                   ; Restore the Compare MSB register
09D2: 60 2A    MOV   REG[0x2A],A        (0328)    mov   reg[Servo0_COMPARE_MSB_REG], A          ;
09D4: 52 01    MOV   A,[X+1]            (0329)    mov   A, [X+bOrigCompareValue+1]                 ; Restore the Compare LSB register
09D6: 60 26    MOV   REG[0x26],A        (0330)    mov   reg[Servo0_COMPARE_LSB_REG], A          ;
09D8: 71 10    OR    F,0x10             
                                        (0331)    M8C_SetBank1                                     ; ---Restore the PWM operation
09DA: 52 02    MOV   A,[X+2]            (0332)    mov   A, [X+bOrigClockSetting]                   ; Grab the LSB clock setting...
09DC: 60 25    MOV   REG[0x25],A        (0333)    mov   reg[Servo0_INPUT_LSB_REG], A            ;    and restore it
09DE: 70 EF    AND   F,0xEF             
09E0: 43 27 01 OR    REG[0x27],0x1      
                                        (0334)    M8C_SetBank0                                     ;
                                        (0335)    Servo0_Start_M                                ; Now re-enable the PWM function
09E3: 18       POP   A                  (0336)    pop   A                                          ; Setup the return value
09E4: 20       POP   X                  (0337)    pop   X                                          ;
09E5: 38 FD    ADD   SP,0xFD            (0338)    ADD   SP, -(STACK_FRAME_SIZE-2)                  ; Zap remainder of stack frame
09E7: 70 3F    AND   F,0x3F             
09E9: 71 C0    OR    F,0xC0             
                                        (0339)    RAM_EPILOGUE RAM_USE_CLASS_2
09EB: 7F       RET                      (0340)    ret
                                        (0341) 
                                        (0342) .ENDSECTION
                                        (0343) 
                                        (0344) ; End of File Servo0.asm
FILE: lib\pwmbint.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWMBINT.asm
                                        (0004) ;;   Version: 2.60, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM8 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "PWMB.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _PWMB_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _PWMB_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _PWMB_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
                                        (0081)    ;lcall _My_C_Function
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
09EC: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file PWMBINT.asm
FILE: lib\pwmb.asm                      (0001) ;;*****************************************************************************
09ED: 43 DF 01 OR    REG[0xDF],0x1      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWMB.asm
                                        (0004) ;;   Version: 2.60, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM8 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "PWMB.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  PWMB_EnableInt
                                        (0030) export _PWMB_EnableInt
                                        (0031) export  PWMB_DisableInt
                                        (0032) export _PWMB_DisableInt
                                        (0033) export  PWMB_Start
                                        (0034) export _PWMB_Start
                                        (0035) export  PWMB_Stop
                                        (0036) export _PWMB_Stop
                                        (0037) export  PWMB_WritePeriod
                                        (0038) export _PWMB_WritePeriod
                                        (0039) export  PWMB_WritePulseWidth
                                        (0040) export _PWMB_WritePulseWidth
                                        (0041) export  PWMB_bReadPulseWidth
                                        (0042) export _PWMB_bReadPulseWidth
                                        (0043) export  PWMB_bReadCounter
                                        (0044) export _PWMB_bReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  bPWMB_ReadPulseWidth    ; deprecated
                                        (0049) export _bPWMB_ReadPulseWidth    ; deprecated
                                        (0050) export  bPWMB_ReadCounter       ; deprecated
                                        (0051) export _bPWMB_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) 
                                        (0054) AREA kipr_2_RAM (RAM,REL)
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Constant Definitions
                                        (0058) ;-----------------------------------------------
                                        (0059) 
                                        (0060) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0061) 
                                        (0062) 
                                        (0063) ;-----------------------------------------------
                                        (0064) ; Variable Allocation
                                        (0065) ;-----------------------------------------------
                                        (0066) 
                                        (0067) 
                                        (0068) AREA UserModules (ROM, REL)
                                        (0069) 
                                        (0070) .SECTION
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;  FUNCTION NAME: PWMB_EnableInt
                                        (0073) ;
                                        (0074) ;  DESCRIPTION:
                                        (0075) ;     Enables this PWM's interrupt by setting the interrupt enable mask bit
                                        (0076) ;     associated with this User Module. This function has no effect until and
                                        (0077) ;     unless the global interrupts are enabled (for example by using the
                                        (0078) ;     macro M8C_EnableGInt).
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;
                                        (0081) ;  ARGUMENTS:    None.
                                        (0082) ;  RETURNS:      Nothing.
                                        (0083) ;  SIDE EFFECTS:
                                        (0084) ;    The A and X registers may be modified by this or future implementations
                                        (0085) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0086) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0087) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0088) ;    functions.
                                        (0089) ;
                                        (0090)  PWMB_EnableInt:
                                        (0091) _PWMB_EnableInt:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0093)    PWMB_EnableInt_M
                                        (0094)    RAM_EPILOGUE RAM_USE_CLASS_1
09F0: 7F       RET                      (0095)    ret
09F1: 41 DF FE AND   REG[0xDF],0xFE     
                                        (0096) 
                                        (0097) 
                                        (0098) .ENDSECTION
                                        (0099) 
                                        (0100) .SECTION
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;  FUNCTION NAME: PWMB_DisableInt
                                        (0103) ;
                                        (0104) ;  DESCRIPTION:
                                        (0105) ;     Disables this PWM's interrupt by clearing the interrupt enable
                                        (0106) ;     mask bit associated with this User Module.
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS:    None
                                        (0110) ;  RETURNS:      Nothing
                                        (0111) ;  SIDE EFFECTS:
                                        (0112) ;    The A and X registers may be modified by this or future implementations
                                        (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0116) ;    functions.
                                        (0117) ;
                                        (0118)  PWMB_DisableInt:
                                        (0119) _PWMB_DisableInt:
                                        (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0121)    PWMB_DisableInt_M
                                        (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
09F4: 7F       RET                      (0123)    ret
09F5: 43 43 01 OR    REG[0x43],0x1      
                                        (0124) 
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: PWMB_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit in the Control register of this user module.  The
                                        (0134) ;     PWM will begin counting on the next input clock as soon as the
                                        (0135) ;     enable input is asserted high.
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;
                                        (0138) ;  ARGUMENTS:    None
                                        (0139) ;  RETURNS:      Nothing
                                        (0140) ;  SIDE EFFECTS:
                                        (0141) ;    The A and X registers may be modified by this or future implementations
                                        (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0145) ;    functions.
                                        (0146) ;
                                        (0147)  PWMB_Start:
                                        (0148) _PWMB_Start:
                                        (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0150)    PWMB_Start_M
                                        (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
09F8: 7F       RET                      (0152)    ret
09F9: 41 43 FE AND   REG[0x43],0xFE     
                                        (0153) 
                                        (0154) 
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: PWMB_Stop
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:
                                        (0162) ;     Disables PWM operation by clearing the start bit in the Control
                                        (0163) ;     register.
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;
                                        (0166) ;  ARGUMENTS:    None
                                        (0167) ;  RETURNS:      Nothing
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  PWMB_Stop:
                                        (0176) _PWMB_Stop:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0178)    PWMB_Stop_M
                                        (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
09FC: 7F       RET                      (0180)    ret
                                        (0181) 
                                        (0182) 
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185) .SECTION
                                        (0186) ;-----------------------------------------------------------------------------
                                        (0187) ;  FUNCTION NAME: PWMB_WritePeriod
                                        (0188) ;
                                        (0189) ;  DESCRIPTION:
                                        (0190) ;     Write the 8-bit period value into the Period register (DR1).
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: fastcall16 BYTE bPeriodValue (passed in A)
                                        (0194) ;  RETURNS:   Nothing
                                        (0195) ;  SIDE EFFECTS:
                                        (0196) ;    If the PWM user module is stopped, then this value will also be
                                        (0197) ;    latched into the Count register (DR0).
                                        (0198) ;    
                                        (0199) ;    The A and X registers may be modified by this or future implementations
                                        (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0203) ;    functions.
                                        (0204) ;
                                        (0205)  PWMB_WritePeriod:
                                        (0206) _PWMB_WritePeriod:
                                        (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
09FD: 60 41    MOV   REG[0x41],A        (0208)    mov   reg[PWMB_PERIOD_REG], A
                                        (0209)    RAM_EPILOGUE RAM_USE_CLASS_1
09FF: 7F       RET                      (0210)    ret
                                        (0211) 
                                        (0212) 
                                        (0213) .ENDSECTION
                                        (0214) 
                                        (0215) .SECTION
                                        (0216) ;-----------------------------------------------------------------------------
                                        (0217) ;  FUNCTION NAME: PWMB_WritePulseWidth
                                        (0218) ;
                                        (0219) ;  DESCRIPTION:
                                        (0220) ;     Writes compare value into the Compare register (DR2).
                                        (0221) ;-----------------------------------------------------------------------------
                                        (0222) ;
                                        (0223) ;  ARGUMENTS:    fastcall16 BYTE bCompareValue (passed in A)
                                        (0224) ;  RETURNS:      Nothing
                                        (0225) ;  SIDE EFFECTS:
                                        (0226) ;    The A and X registers may be modified by this or future implementations
                                        (0227) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0228) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0229) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0230) ;    functions.
                                        (0231) ;
                                        (0232)  PWMB_WritePulseWidth:
                                        (0233) _PWMB_WritePulseWidth:
                                        (0234)    RAM_PROLOGUE RAM_USE_CLASS_1
0A00: 60 42    MOV   REG[0x42],A        (0235)    mov   reg[PWMB_COMPARE_REG], A
                                        (0236)    RAM_EPILOGUE RAM_USE_CLASS_1
0A02: 7F       RET                      (0237)    ret
                                        (0238) 
                                        (0239) 
                                        (0240) .ENDSECTION
                                        (0241) 
                                        (0242) .SECTION
                                        (0243) ;-----------------------------------------------------------------------------
                                        (0244) ;  FUNCTION NAME: PWMB_bReadPulseWidth
                                        (0245) ;
                                        (0246) ;  DESCRIPTION:
                                        (0247) ;     Reads the Compare register.
                                        (0248) ;-----------------------------------------------------------------------------
                                        (0249) ;
                                        (0250) ;  ARGUMENTS:    None
                                        (0251) ;  RETURNS:      fastcall16 BYTE bCompareValue (value of DR2 in the A register)
                                        (0252) ;  SIDE EFFECTS:
                                        (0253) ;    The A and X registers may be modified by this or future implementations
                                        (0254) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0255) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0256) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0257) ;    functions.
                                        (0258) ;
                                        (0259)  PWMB_bReadPulseWidth:
                                        (0260) _PWMB_bReadPulseWidth:
                                        (0261)  bPWMB_ReadPulseWidth:                           ; this name deprecated
                                        (0262) _bPWMB_ReadPulseWidth:                           ; this name deprecated
                                        (0263)    RAM_PROLOGUE RAM_USE_CLASS_1
0A03: 5D 42    MOV   A,REG[0x42]        (0264)    mov   A, reg[PWMB_COMPARE_REG]
                                        (0265)    RAM_EPILOGUE RAM_USE_CLASS_1
0A05: 7F       RET                      (0266)    ret
                                        (0267) 
                                        (0268) 
                                        (0269) .ENDSECTION
                                        (0270) 
                                        (0271) .SECTION
                                        (0272) ;-----------------------------------------------------------------------------
                                        (0273) ;  FUNCTION NAME: PWMB_bReadCounter
                                        (0274) ;
                                        (0275) ;  DESCRIPTION:
                                        (0276) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0277) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0278) ;     from the Count to the Compare registers by holding the clock low in
                                        (0279) ;     the PSoC block.
                                        (0280) ;-----------------------------------------------------------------------------
                                        (0281) ;
                                        (0282) ;  ARGUMENTS: None
                                        (0283) ;  RETURNS:   fastcall16 BYTE bCount (value of DR0 in the A register)
                                        (0284) ;  SIDE EFFECTS:
                                        (0285) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0286) ;     2) The A and X registers may be modified by this or future implementations
                                        (0287) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0288) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0289) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0290) ;        functions.
                                        (0291) ;
                                        (0292)  PWMB_bReadCounter:
                                        (0293) _PWMB_bReadCounter:
                                        (0294)  bPWMB_ReadCounter:                              ; this name deprecated
                                        (0295) _bPWMB_ReadCounter:                              ; this name deprecated
                                        (0296) 
                                        (0297)    bOrigCompareValue:      EQU   0               ; Frame offset to temp Compare store
                                        (0298)    bOrigClockSetting:      EQU   1               ; Frame offset to temp Input   store
                                        (0299)    wCounter:               EQU   2               ; Frame offset to temp Count   store
                                        (0300)    STACK_FRAME_SIZE:       EQU   3               ; max stack frame size is 3 bytes
                                        (0301) 
                                        (0302)    RAM_PROLOGUE RAM_USE_CLASS_2
0A06: 4F       MOV   X,SP               (0303)    mov   X, SP                                   ; X <- stack frame pointer
0A07: 5D 42    MOV   A,REG[0x42]        (0304)    mov   A, reg[PWMB_COMPARE_REG]                ; Save the Compare register on the stack
0A09: 08       PUSH  A                  (0305)    push  A                                       ;
0A0A: 41 43 FE AND   REG[0x43],0xFE     
0A0D: 71 10    OR    F,0x10             
                                        (0306)    PWMB_Stop_M                                   ; Disable (stop) the PWM
                                        (0307)    M8C_SetBank1                                  ;
0A0F: 5D 41    MOV   A,REG[0x41]        (0308)    mov   A, reg[PWMB_INPUT_REG]                  ; save the clock input setting
0A11: 08       PUSH  A                  (0309)    push  A                                       ;   on the stack (now 2 bytes) and ...
                                        (0310)                                                  ;   hold the clock low:
0A12: 62 41 00 MOV   REG[0x41],0x0      (0311)    mov   reg[PWMB_INPUT_REG], INPUT_REG_NULL
0A15: 70 EF    AND   F,0xEF             
                                        (0312)    M8C_SetBank0
                                        (0313)                                                  ; Extract the Count via DR2 register
0A17: 5D 40    MOV   A,REG[0x40]        (0314)    mov   A, reg[PWMB_COUNTER_REG]                ; DR2 <- DR0
0A19: 5D 42    MOV   A,REG[0x42]        (0315)    mov   A, reg[PWMB_COMPARE_REG]                ; Stash the Count on the stack
0A1B: 08       PUSH  A                  (0316)    push  A                                       ;  -stack frame is now 3 bytes
0A1C: 52 00    MOV   A,[X+0]            (0317)    mov   A, [X+bOrigCompareValue]                ; Restore the Compare register
0A1E: 60 42    MOV   REG[0x42],A        (0318)    mov   reg[PWMB_COMPARE_REG], A
0A20: 71 10    OR    F,0x10             
                                        (0319)    M8C_SetBank1                                  ; Restore the PWM operation:
0A22: 52 01    MOV   A,[X+1]            (0320)    mov   A, [X+bOrigClockSetting]                ;   First, the clock setting...
0A24: 60 41    MOV   REG[0x41],A        (0321)    mov   reg[PWMB_INPUT_REG], A                  ;
0A26: 70 EF    AND   F,0xEF             
0A28: 43 43 01 OR    REG[0x43],0x1      
                                        (0322)    M8C_SetBank0                                  ;
                                        (0323)    PWMB_Start_M                                  ;   then re-enable the PWM.
0A2B: 18       POP   A                  (0324)    pop   A                                       ; Setup the return value
0A2C: 38 FE    ADD   SP,0xFE            (0325)    ADD   SP, -(STACK_FRAME_SIZE-1)               ; Zap remainder of stack frame
0A2E: 70 3F    AND   F,0x3F             
0A30: 71 C0    OR    F,0xC0             
                                        (0326)    RAM_EPILOGUE RAM_USE_CLASS_2
0A32: 7F       RET                      (0327)    ret
                                        (0328) 
                                        (0329) .ENDSECTION
                                        (0330) 
                                        (0331) ; End of File PWMB.asm
FILE: lib\pwmaint.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWMAINT.asm
                                        (0004) ;;   Version: 2.60, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM8 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "PWMA.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _PWMA_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _PWMA_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _PWMA_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
                                        (0081)    ;lcall _My_C_Function
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
0A33: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file PWMAINT.asm
FILE: lib\pwma.asm                      (0001) ;;*****************************************************************************
0A34: 43 E1 08 OR    REG[0xE1],0x8      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWMA.asm
                                        (0004) ;;   Version: 2.60, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM8 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "PWMA.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  PWMA_EnableInt
                                        (0030) export _PWMA_EnableInt
                                        (0031) export  PWMA_DisableInt
                                        (0032) export _PWMA_DisableInt
                                        (0033) export  PWMA_Start
                                        (0034) export _PWMA_Start
                                        (0035) export  PWMA_Stop
                                        (0036) export _PWMA_Stop
                                        (0037) export  PWMA_WritePeriod
                                        (0038) export _PWMA_WritePeriod
                                        (0039) export  PWMA_WritePulseWidth
                                        (0040) export _PWMA_WritePulseWidth
                                        (0041) export  PWMA_bReadPulseWidth
                                        (0042) export _PWMA_bReadPulseWidth
                                        (0043) export  PWMA_bReadCounter
                                        (0044) export _PWMA_bReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  bPWMA_ReadPulseWidth    ; deprecated
                                        (0049) export _bPWMA_ReadPulseWidth    ; deprecated
                                        (0050) export  bPWMA_ReadCounter       ; deprecated
                                        (0051) export _bPWMA_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) 
                                        (0054) AREA kipr_2_RAM (RAM,REL)
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Constant Definitions
                                        (0058) ;-----------------------------------------------
                                        (0059) 
                                        (0060) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0061) 
                                        (0062) 
                                        (0063) ;-----------------------------------------------
                                        (0064) ; Variable Allocation
                                        (0065) ;-----------------------------------------------
                                        (0066) 
                                        (0067) 
                                        (0068) AREA UserModules (ROM, REL)
                                        (0069) 
                                        (0070) .SECTION
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;  FUNCTION NAME: PWMA_EnableInt
                                        (0073) ;
                                        (0074) ;  DESCRIPTION:
                                        (0075) ;     Enables this PWM's interrupt by setting the interrupt enable mask bit
                                        (0076) ;     associated with this User Module. This function has no effect until and
                                        (0077) ;     unless the global interrupts are enabled (for example by using the
                                        (0078) ;     macro M8C_EnableGInt).
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;
                                        (0081) ;  ARGUMENTS:    None.
                                        (0082) ;  RETURNS:      Nothing.
                                        (0083) ;  SIDE EFFECTS:
                                        (0084) ;    The A and X registers may be modified by this or future implementations
                                        (0085) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0086) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0087) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0088) ;    functions.
                                        (0089) ;
                                        (0090)  PWMA_EnableInt:
                                        (0091) _PWMA_EnableInt:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0093)    PWMA_EnableInt_M
                                        (0094)    RAM_EPILOGUE RAM_USE_CLASS_1
0A37: 7F       RET                      (0095)    ret
0A38: 41 E1 F7 AND   REG[0xE1],0xF7     
                                        (0096) 
                                        (0097) 
                                        (0098) .ENDSECTION
                                        (0099) 
                                        (0100) .SECTION
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;  FUNCTION NAME: PWMA_DisableInt
                                        (0103) ;
                                        (0104) ;  DESCRIPTION:
                                        (0105) ;     Disables this PWM's interrupt by clearing the interrupt enable
                                        (0106) ;     mask bit associated with this User Module.
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS:    None
                                        (0110) ;  RETURNS:      Nothing
                                        (0111) ;  SIDE EFFECTS:
                                        (0112) ;    The A and X registers may be modified by this or future implementations
                                        (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0116) ;    functions.
                                        (0117) ;
                                        (0118)  PWMA_DisableInt:
                                        (0119) _PWMA_DisableInt:
                                        (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0121)    PWMA_DisableInt_M
                                        (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
0A3B: 7F       RET                      (0123)    ret
0A3C: 43 2F 01 OR    REG[0x2F],0x1      
                                        (0124) 
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: PWMA_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit in the Control register of this user module.  The
                                        (0134) ;     PWM will begin counting on the next input clock as soon as the
                                        (0135) ;     enable input is asserted high.
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;
                                        (0138) ;  ARGUMENTS:    None
                                        (0139) ;  RETURNS:      Nothing
                                        (0140) ;  SIDE EFFECTS:
                                        (0141) ;    The A and X registers may be modified by this or future implementations
                                        (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0145) ;    functions.
                                        (0146) ;
                                        (0147)  PWMA_Start:
                                        (0148) _PWMA_Start:
                                        (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0150)    PWMA_Start_M
                                        (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
0A3F: 7F       RET                      (0152)    ret
0A40: 41 2F FE AND   REG[0x2F],0xFE     
                                        (0153) 
                                        (0154) 
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: PWMA_Stop
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:
                                        (0162) ;     Disables PWM operation by clearing the start bit in the Control
                                        (0163) ;     register.
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;
                                        (0166) ;  ARGUMENTS:    None
                                        (0167) ;  RETURNS:      Nothing
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  PWMA_Stop:
                                        (0176) _PWMA_Stop:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0178)    PWMA_Stop_M
                                        (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
0A43: 7F       RET                      (0180)    ret
                                        (0181) 
                                        (0182) 
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185) .SECTION
                                        (0186) ;-----------------------------------------------------------------------------
                                        (0187) ;  FUNCTION NAME: PWMA_WritePeriod
                                        (0188) ;
                                        (0189) ;  DESCRIPTION:
                                        (0190) ;     Write the 8-bit period value into the Period register (DR1).
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: fastcall16 BYTE bPeriodValue (passed in A)
                                        (0194) ;  RETURNS:   Nothing
                                        (0195) ;  SIDE EFFECTS:
                                        (0196) ;    If the PWM user module is stopped, then this value will also be
                                        (0197) ;    latched into the Count register (DR0).
                                        (0198) ;    
                                        (0199) ;    The A and X registers may be modified by this or future implementations
                                        (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0203) ;    functions.
                                        (0204) ;
                                        (0205)  PWMA_WritePeriod:
                                        (0206) _PWMA_WritePeriod:
                                        (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
0A44: 60 2D    MOV   REG[0x2D],A        (0208)    mov   reg[PWMA_PERIOD_REG], A
                                        (0209)    RAM_EPILOGUE RAM_USE_CLASS_1
0A46: 7F       RET                      (0210)    ret
                                        (0211) 
                                        (0212) 
                                        (0213) .ENDSECTION
                                        (0214) 
                                        (0215) .SECTION
                                        (0216) ;-----------------------------------------------------------------------------
                                        (0217) ;  FUNCTION NAME: PWMA_WritePulseWidth
                                        (0218) ;
                                        (0219) ;  DESCRIPTION:
                                        (0220) ;     Writes compare value into the Compare register (DR2).
                                        (0221) ;-----------------------------------------------------------------------------
                                        (0222) ;
                                        (0223) ;  ARGUMENTS:    fastcall16 BYTE bCompareValue (passed in A)
                                        (0224) ;  RETURNS:      Nothing
                                        (0225) ;  SIDE EFFECTS:
                                        (0226) ;    The A and X registers may be modified by this or future implementations
                                        (0227) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0228) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0229) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0230) ;    functions.
                                        (0231) ;
                                        (0232)  PWMA_WritePulseWidth:
                                        (0233) _PWMA_WritePulseWidth:
                                        (0234)    RAM_PROLOGUE RAM_USE_CLASS_1
0A47: 60 2E    MOV   REG[0x2E],A        (0235)    mov   reg[PWMA_COMPARE_REG], A
                                        (0236)    RAM_EPILOGUE RAM_USE_CLASS_1
0A49: 7F       RET                      (0237)    ret
                                        (0238) 
                                        (0239) 
                                        (0240) .ENDSECTION
                                        (0241) 
                                        (0242) .SECTION
                                        (0243) ;-----------------------------------------------------------------------------
                                        (0244) ;  FUNCTION NAME: PWMA_bReadPulseWidth
                                        (0245) ;
                                        (0246) ;  DESCRIPTION:
                                        (0247) ;     Reads the Compare register.
                                        (0248) ;-----------------------------------------------------------------------------
                                        (0249) ;
                                        (0250) ;  ARGUMENTS:    None
                                        (0251) ;  RETURNS:      fastcall16 BYTE bCompareValue (value of DR2 in the A register)
                                        (0252) ;  SIDE EFFECTS:
                                        (0253) ;    The A and X registers may be modified by this or future implementations
                                        (0254) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0255) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0256) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0257) ;    functions.
                                        (0258) ;
                                        (0259)  PWMA_bReadPulseWidth:
                                        (0260) _PWMA_bReadPulseWidth:
                                        (0261)  bPWMA_ReadPulseWidth:                           ; this name deprecated
                                        (0262) _bPWMA_ReadPulseWidth:                           ; this name deprecated
                                        (0263)    RAM_PROLOGUE RAM_USE_CLASS_1
0A4A: 5D 2E    MOV   A,REG[0x2E]        (0264)    mov   A, reg[PWMA_COMPARE_REG]
                                        (0265)    RAM_EPILOGUE RAM_USE_CLASS_1
0A4C: 7F       RET                      (0266)    ret
                                        (0267) 
                                        (0268) 
                                        (0269) .ENDSECTION
                                        (0270) 
                                        (0271) .SECTION
                                        (0272) ;-----------------------------------------------------------------------------
                                        (0273) ;  FUNCTION NAME: PWMA_bReadCounter
                                        (0274) ;
                                        (0275) ;  DESCRIPTION:
                                        (0276) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0277) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0278) ;     from the Count to the Compare registers by holding the clock low in
                                        (0279) ;     the PSoC block.
                                        (0280) ;-----------------------------------------------------------------------------
                                        (0281) ;
                                        (0282) ;  ARGUMENTS: None
                                        (0283) ;  RETURNS:   fastcall16 BYTE bCount (value of DR0 in the A register)
                                        (0284) ;  SIDE EFFECTS:
                                        (0285) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0286) ;     2) The A and X registers may be modified by this or future implementations
                                        (0287) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0288) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0289) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0290) ;        functions.
                                        (0291) ;
                                        (0292)  PWMA_bReadCounter:
                                        (0293) _PWMA_bReadCounter:
                                        (0294)  bPWMA_ReadCounter:                              ; this name deprecated
                                        (0295) _bPWMA_ReadCounter:                              ; this name deprecated
                                        (0296) 
                                        (0297)    bOrigCompareValue:      EQU   0               ; Frame offset to temp Compare store
                                        (0298)    bOrigClockSetting:      EQU   1               ; Frame offset to temp Input   store
                                        (0299)    wCounter:               EQU   2               ; Frame offset to temp Count   store
                                        (0300)    STACK_FRAME_SIZE:       EQU   3               ; max stack frame size is 3 bytes
                                        (0301) 
                                        (0302)    RAM_PROLOGUE RAM_USE_CLASS_2
0A4D: 4F       MOV   X,SP               (0303)    mov   X, SP                                   ; X <- stack frame pointer
0A4E: 5D 2E    MOV   A,REG[0x2E]        (0304)    mov   A, reg[PWMA_COMPARE_REG]                ; Save the Compare register on the stack
0A50: 08       PUSH  A                  (0305)    push  A                                       ;
0A51: 41 2F FE AND   REG[0x2F],0xFE     
0A54: 71 10    OR    F,0x10             
                                        (0306)    PWMA_Stop_M                                   ; Disable (stop) the PWM
                                        (0307)    M8C_SetBank1                                  ;
0A56: 5D 2D    MOV   A,REG[0x2D]        (0308)    mov   A, reg[PWMA_INPUT_REG]                  ; save the clock input setting
0A58: 08       PUSH  A                  (0309)    push  A                                       ;   on the stack (now 2 bytes) and ...
                                        (0310)                                                  ;   hold the clock low:
0A59: 62 2D 00 MOV   REG[0x2D],0x0      (0311)    mov   reg[PWMA_INPUT_REG], INPUT_REG_NULL
0A5C: 70 EF    AND   F,0xEF             
                                        (0312)    M8C_SetBank0
                                        (0313)                                                  ; Extract the Count via DR2 register
0A5E: 5D 2C    MOV   A,REG[0x2C]        (0314)    mov   A, reg[PWMA_COUNTER_REG]                ; DR2 <- DR0
0A60: 5D 2E    MOV   A,REG[0x2E]        (0315)    mov   A, reg[PWMA_COMPARE_REG]                ; Stash the Count on the stack
0A62: 08       PUSH  A                  (0316)    push  A                                       ;  -stack frame is now 3 bytes
0A63: 52 00    MOV   A,[X+0]            (0317)    mov   A, [X+bOrigCompareValue]                ; Restore the Compare register
0A65: 60 2E    MOV   REG[0x2E],A        (0318)    mov   reg[PWMA_COMPARE_REG], A
0A67: 71 10    OR    F,0x10             
                                        (0319)    M8C_SetBank1                                  ; Restore the PWM operation:
0A69: 52 01    MOV   A,[X+1]            (0320)    mov   A, [X+bOrigClockSetting]                ;   First, the clock setting...
0A6B: 60 2D    MOV   REG[0x2D],A        (0321)    mov   reg[PWMA_INPUT_REG], A                  ;
0A6D: 70 EF    AND   F,0xEF             
0A6F: 43 2F 01 OR    REG[0x2F],0x1      
                                        (0322)    M8C_SetBank0                                  ;
                                        (0323)    PWMA_Start_M                                  ;   then re-enable the PWM.
0A72: 18       POP   A                  (0324)    pop   A                                       ; Setup the return value
0A73: 38 FE    ADD   SP,0xFE            (0325)    ADD   SP, -(STACK_FRAME_SIZE-1)               ; Zap remainder of stack frame
0A75: 70 3F    AND   F,0x3F             
0A77: 71 C0    OR    F,0xC0             
                                        (0326)    RAM_EPILOGUE RAM_USE_CLASS_2
0A79: 7F       RET                      (0327)    ret
                                        (0328) 
                                        (0329) .ENDSECTION
                                        (0330) 
                                        (0331) ; End of File PWMA.asm
FILE: lib\enc1b_pedge.asm               (0001) ;;*****************************************************************************
0A7A: 43 E1 20 OR    REG[0xE1],0x20     (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: ENC1B_PEDGE.asm
                                        (0004) ;;  Version: 1.3, Updated on 2014/7/14 at 8:13:28
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: DigitalBuffers User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "ENC1B_PEDGE.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  ENC1B_PEDGE_EnableInt
                                        (0030) export _ENC1B_PEDGE_EnableInt
                                        (0031) export  ENC1B_PEDGE_DisableInt
                                        (0032) export _ENC1B_PEDGE_DisableInt
                                        (0033) export  ENC1B_PEDGE_Start
                                        (0034) export _ENC1B_PEDGE_Start
                                        (0035) export  ENC1B_PEDGE_Stop
                                        (0036) export _ENC1B_PEDGE_Stop
                                        (0037) 
                                        (0038) AREA bss (RAM,REL)
                                        (0039) 
                                        (0040) ;-----------------------------------------------
                                        (0041) ;  Constant Definitions
                                        (0042) ;-----------------------------------------------
                                        (0043) 
                                        (0044) 
                                        (0045) ;-----------------------------------------------
                                        (0046) ; Variable Allocation
                                        (0047) ;-----------------------------------------------
                                        (0048) 
                                        (0049) 
                                        (0050) AREA UserModules (ROM, REL)
                                        (0051) 
                                        (0052) .SECTION
                                        (0053) ;-----------------------------------------------------------------------------
                                        (0054) ;  FUNCTION NAME: ENC1B_PEDGE_EnableInt
                                        (0055) ;
                                        (0056) ;  DESCRIPTION:
                                        (0057) ;     Enables the DigBuf's interrupt by setting the interrupt enable mask bit
                                        (0058) ;     associated with this User Module. This function has no effect until and
                                        (0059) ;     unless the global interrupts are enabled (for example by using the
                                        (0060) ;     macro M8C_EnableGInt).
                                        (0061) ;-----------------------------------------------------------------------------
                                        (0062) ;
                                        (0063) ;  ARGUMENTS:    None.
                                        (0064) ;  RETURNS:      Nothing.
                                        (0065) ;  SIDE EFFECTS:
                                        (0066) ;    The A and X registers may be modified by this or future implementations
                                        (0067) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0068) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0069) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0070) ;    functions.
                                        (0071) ;
                                        (0072)  ENC1B_PEDGE_EnableInt:
                                        (0073) _ENC1B_PEDGE_EnableInt:
                                        (0074)    RAM_PROLOGUE RAM_USE_CLASS_1   
                                        (0075)    ENC1B_PEDGE_EnableInt_M
                                        (0076)    RAM_EPILOGUE RAM_USE_CLASS_1
0A7D: 7F       RET                      (0077)    ret
0A7E: 41 E1 DF AND   REG[0xE1],0xDF     
                                        (0078) 
                                        (0079) .ENDSECTION
                                        (0080) 
                                        (0081) .SECTION
                                        (0082) ;-----------------------------------------------------------------------------
                                        (0083) ;  FUNCTION NAME: ENC1B_PEDGE_DisableInt
                                        (0084) ;
                                        (0085) ;  DESCRIPTION:
                                        (0086) ;     Disables the DigBuf's interrupt by clearing the interrupt enable mask bit
                                        (0087) ;     associated with this User Module. 
                                        (0088) ;-----------------------------------------------------------------------------
                                        (0089) ;
                                        (0090) ;  ARGUMENTS:    None.
                                        (0091) ;  RETURNS:      Nothing.
                                        (0092) ;  SIDE EFFECTS:
                                        (0093) ;    The A and X registers may be modified by this or future implementations
                                        (0094) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0095) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0096) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0097) ;    functions.
                                        (0098) ;
                                        (0099)  ENC1B_PEDGE_DisableInt:
                                        (0100) _ENC1B_PEDGE_DisableInt:
                                        (0101)    RAM_PROLOGUE RAM_USE_CLASS_1   
                                        (0102)    ENC1B_PEDGE_DisableInt_M
                                        (0103)    RAM_EPILOGUE RAM_USE_CLASS_1
0A81: 7F       RET                      (0104)    ret
0A82: 43 37 01 OR    REG[0x37],0x1      
                                        (0105) 
                                        (0106) .ENDSECTION
                                        (0107) 
                                        (0108) .SECTION
                                        (0109) ;-----------------------------------------------------------------------------
                                        (0110) ;  FUNCTION NAME: ENC1B_PEDGE_Start
                                        (0111) ;
                                        (0112) ;  DESCRIPTION:
                                        (0113) ;     Starts the Digital Buffers within the block.
                                        (0114) ;-----------------------------------------------------------------------------
                                        (0115) ;
                                        (0116) ;  ARGUMENTS:    None
                                        (0117) ;  RETURNS:      Nothing
                                        (0118) ;  SIDE EFFECTS:
                                        (0119) ;    The A and X registers may be modified by this or future implementations
                                        (0120) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0121) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0122) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0123) ;    functions.
                                        (0124) ;
                                        (0125)  ENC1B_PEDGE_Start:
                                        (0126) _ENC1B_PEDGE_Start:
                                        (0127)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0128)    ENC1B_PEDGE_Start_M
                                        (0129)    RAM_EPILOGUE RAM_USE_CLASS_1
0A85: 7F       RET                      (0130)    ret
0A86: 41 37 FE AND   REG[0x37],0xFE     
                                        (0131) 
                                        (0132) .ENDSECTION
                                        (0133) 
                                        (0134) .SECTION
                                        (0135) ;-----------------------------------------------------------------------------
                                        (0136) ;  FUNCTION NAME: ENC1B_PEDGE_Stop
                                        (0137) ;
                                        (0138) ;  DESCRIPTION:
                                        (0139) ;     Stops the Digital Buffers within the block. The outputs are driven low.
                                        (0140) ;-----------------------------------------------------------------------------
                                        (0141) ;
                                        (0142) ;  ARGUMENTS:    None
                                        (0143) ;  RETURNS:      Nothing
                                        (0144) ;  SIDE EFFECTS:
                                        (0145) ;    The A and X registers may be modified by this or future implementations
                                        (0146) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0147) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0148) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0149) ;    functions.
                                        (0150) ;
                                        (0151)  ENC1B_PEDGE_Stop:
                                        (0152) _ENC1B_PEDGE_Stop:
                                        (0153)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0154)    ENC1B_PEDGE_Stop_M
                                        (0155)    RAM_EPILOGUE RAM_USE_CLASS_1
0A89: 7F       RET                      (0156)    ret
                                        (0157) 
                                        (0158) .ENDSECTION
                                        (0159) 
                                        (0160) 
                                        (0161) ; End of File ENC1B_PEDGE.asm
                                        (0162) 
                                        (0163) 
FILE: lib\enc1b_nedgeint.asm            (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: ENC1B_NEDGEINT.asm
                                        (0004) ;;   Version: Version: 1.60, Updated on 2014/7/14 at 8:13:31
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Counter8 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "ENC1B_NEDGE.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _ENC1B_NEDGE_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _ENC1B_NEDGE_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _ENC1B_NEDGE_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
                                        (0081)    ;lcall _My_C_Function
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
0A8A: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file ENC1B_NEDGEINT.asm
FILE: lib\enc1b_nedge.asm               (0001) ;;*****************************************************************************
0A8B: 43 DF 02 OR    REG[0xDF],0x2      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: ENC1B_NEDGE.asm
                                        (0004) ;;   Version: 1.60, Updated on 2014/7/14 at 8:13:31
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: DigInv User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "ENC1B_NEDGE.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) 
                                        (0027) ;-----------------------------------------------
                                        (0028) ;  Global Symbols
                                        (0029) ;-----------------------------------------------
                                        (0030) export   ENC1B_NEDGE_EnableInt
                                        (0031) export  _ENC1B_NEDGE_EnableInt
                                        (0032) export   ENC1B_NEDGE_DisableInt
                                        (0033) export  _ENC1B_NEDGE_DisableInt
                                        (0034) export   ENC1B_NEDGE_Start
                                        (0035) export  _ENC1B_NEDGE_Start
                                        (0036) export   ENC1B_NEDGE_Stop
                                        (0037) export  _ENC1B_NEDGE_Stop
                                        (0038) 
                                        (0039) ;-----------------------------------------------
                                        (0040) ;  EQUATES
                                        (0041) ;-----------------------------------------------
                                        (0042) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                        (0043) 
                                        (0044) area UserModules (ROM, REL)
                                        (0045) 
                                        (0046) .SECTION
                                        (0047) ;-----------------------------------------------------------------------------
                                        (0048) ;  FUNCTION NAME: ENC1B_NEDGE_EnableInt
                                        (0049) ;
                                        (0050) ;  DESCRIPTION:
                                        (0051) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                        (0052) ;     bit associated with this User Module. Remember to call the global interrupt
                                        (0053) ;     enable function by using the macro: M8C_EnableGInt.
                                        (0054) ;
                                        (0055) ;-----------------------------------------------------------------------------
                                        (0056) ;
                                        (0057) ;  ARGUMENTS: none
                                        (0058) ;
                                        (0059) ;  RETURNS: none
                                        (0060) ;
                                        (0061) ;  SIDE EFFECTS:
                                        (0062) ;    The A and X registers may be modified by this or future implementations
                                        (0063) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0064) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0065) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0066) ;    functions.
                                        (0067) ;
                                        (0068)  ENC1B_NEDGE_EnableInt:
                                        (0069) _ENC1B_NEDGE_EnableInt:
                                        (0070)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0071)    M8C_EnableIntMask ENC1B_NEDGE_INT_REG, ENC1B_NEDGE_bINT_MASK
                                        (0072)    RAM_EPILOGUE RAM_USE_CLASS_1
0A8E: 7F       RET                      (0073)    ret
0A8F: 41 DF FD AND   REG[0xDF],0xFD     
                                        (0074) .ENDSECTION
                                        (0075) 
                                        (0076) .SECTION
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) ;  FUNCTION NAME: ENC1B_NEDGE_DisableInt
                                        (0079) ;
                                        (0080) ;  DESCRIPTION:
                                        (0081) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                        (0082) ;     associated with this User Module.
                                        (0083) ;
                                        (0084) ;-----------------------------------------------------------------------------
                                        (0085) ;
                                        (0086) ;  ARGUMENTS:  none
                                        (0087) ;
                                        (0088) ;  RETURNS:  none
                                        (0089) ;
                                        (0090) ;  SIDE EFFECTS:
                                        (0091) ;    The A and X registers may be modified by this or future implementations
                                        (0092) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0093) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0094) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0095) ;    functions.
                                        (0096) ;
                                        (0097)  ENC1B_NEDGE_DisableInt:
                                        (0098) _ENC1B_NEDGE_DisableInt:
                                        (0099)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0100)    M8C_DisableIntMask ENC1B_NEDGE_INT_REG, ENC1B_NEDGE_bINT_MASK
                                        (0101)    RAM_EPILOGUE RAM_USE_CLASS_1
0A92: 7F       RET                      (0102)    ret
                                        (0103) .ENDSECTION
                                        (0104) 
                                        (0105) .SECTION
                                        (0106) ;-----------------------------------------------------------------------------
                                        (0107) ;  FUNCTION NAME: ENC1B_NEDGE_Start
                                        (0108) ;
                                        (0109) ;  DESCRIPTION:
                                        (0110) ;     Sets the start bit in the Control register of this user module.
                                        (0111) ;
                                        (0112) ;-----------------------------------------------------------------------------
                                        (0113) ;
                                        (0114) ;  ARGUMENTS: none
                                        (0115) ;
                                        (0116) ;  RETURNS: none
                                        (0117) ;
                                        (0118) ;  SIDE EFFECTS:
                                        (0119) ;    The A and X registers may be modified by this or future implementations
                                        (0120) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0121) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0122) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0123) ;    functions.
                                        (0124) ;
                                        (0125) ;  THEORY of OPERATION or PROCEDURE:
                                        (0126) ;
                                        (0127) ;     1) Save the Interrupt register
                                        (0128) ;     2) Save the Output register
                                        (0129) ;     3) Save the input register
                                        (0130) ;     4) Switch the output to Disabled - LOW
                                        (0131) ;     5) Disable Interrupt
                                        (0132) ;     6) Start the DigInv
                                        (0133) ;     7) Re-instate the input source
                                        (0134) ;     8) Re-instate the output
                                        (0135) ;     9) Re-instate the Interrupt register
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137)  ENC1B_NEDGE_Start:
                                        (0138) _ENC1B_NEDGE_Start:
                                        (0139)    RAM_PROLOGUE RAM_USE_CLASS_1
0A93: 08       PUSH  A                  (0140)    push  A
                                        (0141) 
                                        (0142)    ; The DigInv must see a positive clock edge in order to "start" itself
                                        (0143)    ; in the correct state.  Once it sees a clock edge, it will follow its
                                        (0144)    ; input source.  To do this, we disable outputs, switch the input source
                                        (0145)    ; to the 48MHz clock, start the DigInv, re-instate the user's input source
                                        (0146)    ; and then re-instate the output.
                                        (0147) 
                                        (0148)    ; disable the interrupt
0A94: 5D DF    MOV   A,REG[0xDF]        (0149)    mov   A, REG[ENC1B_NEDGE_INT_REG]
0A96: 08       PUSH  A                  (0150)    push  A
0A97: 41 DF FD AND   REG[0xDF],0xFD     
0A9A: 71 10    OR    F,0x10             
                                        (0151) 
                                        (0152)    M8C_DisableIntMask ENC1B_NEDGE_INT_REG, ENC1B_NEDGE_bINT_MASK
                                        (0153) 
                                        (0154)    M8C_SetBank1
                                        (0155)    ; set the output to disable - will remain low!
0A9C: 5D 46    MOV   A,REG[0x46]        (0156)    mov   A, REG[ENC1B_NEDGE_OUTPUT_REG]
0A9E: 08       PUSH  A                  (0157)    push  A
                                        (0158) 
0A9F: 62 46 00 MOV   REG[0x46],0x0      (0159)    mov   REG[ENC1B_NEDGE_OUTPUT_REG], 0
                                        (0160) 
                                        (0161)    ; set the input to the 48MHz clock
0AA2: 5D 45    MOV   A,REG[0x45]        (0162)    mov   A, REG[ENC1B_NEDGE_INPUT_REG]
0AA4: 08       PUSH  A                  (0163)    push  A
                                        (0164) 
0AA5: 62 45 04 MOV   REG[0x45],0x4      (0165)    mov   REG[ENC1B_NEDGE_INPUT_REG], 04
0AA8: 70 EF    AND   F,0xEF             
                                        (0166) 
                                        (0167)    M8C_SetBank0
                                        (0168)    ; start the inverter
0AAA: 43 47 01 OR    REG[0x47],0x1      (0169)    or    REG[ENC1B_NEDGE_CONTROL_REG], bfCONTROL_REG_START_BIT
0AAD: 71 10    OR    F,0x10             
                                        (0170) 
                                        (0171)    ; Re-instate the input
                                        (0172)    M8C_SetBank1
0AAF: 18       POP   A                  (0173)    pop   A
0AB0: 60 45    MOV   REG[0x45],A        (0174)    mov   REG[ENC1B_NEDGE_INPUT_REG], A
                                        (0175) 
                                        (0176)    ; Re-instate the output
0AB2: 18       POP   A                  (0177)    pop   A
0AB3: 60 46    MOV   REG[0x46],A        (0178)    mov   REG[ENC1B_NEDGE_OUTPUT_REG], A
0AB5: 70 EF    AND   F,0xEF             
0AB7: 62 DB FD MOV   REG[0xDB],0xFD     
                                        (0179)    M8C_SetBank0
                                        (0180) 
                                        (0181)    ;clear interrupt
                                        (0182)    M8C_ClearIntFlag INT_CLR1, ENC1B_NEDGE_bINT_MASK
                                        (0183) 
                                        (0184)    ; Re-instate the interrupt state
0ABA: 18       POP   A                  (0185)    pop   A
0ABB: 60 DF    MOV   REG[0xDF],A        (0186)    mov   REG[ENC1B_NEDGE_INT_REG], A
                                        (0187) 
                                        (0188)    ;Done!
0ABD: 18       POP   A                  (0189)    pop   A
                                        (0190)    RAM_EPILOGUE RAM_USE_CLASS_1
0ABE: 7F       RET                      (0191)    ret
                                        (0192) 
                                        (0193) .ENDSECTION
                                        (0194) 
                                        (0195) .SECTION
                                        (0196) ;-----------------------------------------------------------------------------
                                        (0197) ;  FUNCTION NAME: ENC1B_NEDGE_Stop
                                        (0198) ;
                                        (0199) ;  DESCRIPTION:
                                        (0200) ;     Halts operation of the Digital Inverter.  Output is set LOW.
                                        (0201) ;
                                        (0202) ;-----------------------------------------------------------------------------
                                        (0203) ;
                                        (0204) ;  ARGUMENTS: none
                                        (0205) ;
                                        (0206) ;  RETURNS: none
                                        (0207) ;
                                        (0208) ;  SIDE EFFECTS:
                                        (0209) ;    The A and X registers may be modified by this or future implementations
                                        (0210) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0211) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0212) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0213) ;    functions.
                                        (0214) ;
                                        (0215)  ENC1B_NEDGE_Stop:
                                        (0216) _ENC1B_NEDGE_Stop:
                                        (0217) 
                                        (0218)    RAM_PROLOGUE RAM_USE_CLASS_1
0ABF: 41 47 FE AND   REG[0x47],0xFE     (0219)    and   REG[ENC1B_NEDGE_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                        (0220)    RAM_EPILOGUE RAM_USE_CLASS_1
0AC2: 7F       RET                      (0221)    ret
                                        (0222) 
                                        (0223) .ENDSECTION
                                        (0224) 
                                        (0225) ; End of File ENC1B_NEDGE.asm
                                        (0226) 
                                        (0227) 
                                        (0228) 
FILE: lib\enc1a_pedge.asm               (0001) ;;*****************************************************************************
0AC3: 43 E1 01 OR    REG[0xE1],0x1      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: ENC1A_PEDGE.asm
                                        (0004) ;;  Version: 1.3, Updated on 2014/7/14 at 8:13:28
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: DigitalBuffers User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "ENC1A_PEDGE.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  ENC1A_PEDGE_EnableInt
                                        (0030) export _ENC1A_PEDGE_EnableInt
                                        (0031) export  ENC1A_PEDGE_DisableInt
                                        (0032) export _ENC1A_PEDGE_DisableInt
                                        (0033) export  ENC1A_PEDGE_Start
                                        (0034) export _ENC1A_PEDGE_Start
                                        (0035) export  ENC1A_PEDGE_Stop
                                        (0036) export _ENC1A_PEDGE_Stop
                                        (0037) 
                                        (0038) AREA bss (RAM,REL)
                                        (0039) 
                                        (0040) ;-----------------------------------------------
                                        (0041) ;  Constant Definitions
                                        (0042) ;-----------------------------------------------
                                        (0043) 
                                        (0044) 
                                        (0045) ;-----------------------------------------------
                                        (0046) ; Variable Allocation
                                        (0047) ;-----------------------------------------------
                                        (0048) 
                                        (0049) 
                                        (0050) AREA UserModules (ROM, REL)
                                        (0051) 
                                        (0052) .SECTION
                                        (0053) ;-----------------------------------------------------------------------------
                                        (0054) ;  FUNCTION NAME: ENC1A_PEDGE_EnableInt
                                        (0055) ;
                                        (0056) ;  DESCRIPTION:
                                        (0057) ;     Enables the DigBuf's interrupt by setting the interrupt enable mask bit
                                        (0058) ;     associated with this User Module. This function has no effect until and
                                        (0059) ;     unless the global interrupts are enabled (for example by using the
                                        (0060) ;     macro M8C_EnableGInt).
                                        (0061) ;-----------------------------------------------------------------------------
                                        (0062) ;
                                        (0063) ;  ARGUMENTS:    None.
                                        (0064) ;  RETURNS:      Nothing.
                                        (0065) ;  SIDE EFFECTS:
                                        (0066) ;    The A and X registers may be modified by this or future implementations
                                        (0067) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0068) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0069) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0070) ;    functions.
                                        (0071) ;
                                        (0072)  ENC1A_PEDGE_EnableInt:
                                        (0073) _ENC1A_PEDGE_EnableInt:
                                        (0074)    RAM_PROLOGUE RAM_USE_CLASS_1   
                                        (0075)    ENC1A_PEDGE_EnableInt_M
                                        (0076)    RAM_EPILOGUE RAM_USE_CLASS_1
0AC6: 7F       RET                      (0077)    ret
0AC7: 41 E1 FE AND   REG[0xE1],0xFE     
                                        (0078) 
                                        (0079) .ENDSECTION
                                        (0080) 
                                        (0081) .SECTION
                                        (0082) ;-----------------------------------------------------------------------------
                                        (0083) ;  FUNCTION NAME: ENC1A_PEDGE_DisableInt
                                        (0084) ;
                                        (0085) ;  DESCRIPTION:
                                        (0086) ;     Disables the DigBuf's interrupt by clearing the interrupt enable mask bit
                                        (0087) ;     associated with this User Module. 
                                        (0088) ;-----------------------------------------------------------------------------
                                        (0089) ;
                                        (0090) ;  ARGUMENTS:    None.
                                        (0091) ;  RETURNS:      Nothing.
                                        (0092) ;  SIDE EFFECTS:
                                        (0093) ;    The A and X registers may be modified by this or future implementations
                                        (0094) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0095) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0096) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0097) ;    functions.
                                        (0098) ;
                                        (0099)  ENC1A_PEDGE_DisableInt:
                                        (0100) _ENC1A_PEDGE_DisableInt:
                                        (0101)    RAM_PROLOGUE RAM_USE_CLASS_1   
                                        (0102)    ENC1A_PEDGE_DisableInt_M
                                        (0103)    RAM_EPILOGUE RAM_USE_CLASS_1
0ACA: 7F       RET                      (0104)    ret
0ACB: 43 23 01 OR    REG[0x23],0x1      
                                        (0105) 
                                        (0106) .ENDSECTION
                                        (0107) 
                                        (0108) .SECTION
                                        (0109) ;-----------------------------------------------------------------------------
                                        (0110) ;  FUNCTION NAME: ENC1A_PEDGE_Start
                                        (0111) ;
                                        (0112) ;  DESCRIPTION:
                                        (0113) ;     Starts the Digital Buffers within the block.
                                        (0114) ;-----------------------------------------------------------------------------
                                        (0115) ;
                                        (0116) ;  ARGUMENTS:    None
                                        (0117) ;  RETURNS:      Nothing
                                        (0118) ;  SIDE EFFECTS:
                                        (0119) ;    The A and X registers may be modified by this or future implementations
                                        (0120) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0121) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0122) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0123) ;    functions.
                                        (0124) ;
                                        (0125)  ENC1A_PEDGE_Start:
                                        (0126) _ENC1A_PEDGE_Start:
                                        (0127)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0128)    ENC1A_PEDGE_Start_M
                                        (0129)    RAM_EPILOGUE RAM_USE_CLASS_1
0ACE: 7F       RET                      (0130)    ret
0ACF: 41 23 FE AND   REG[0x23],0xFE     
                                        (0131) 
                                        (0132) .ENDSECTION
                                        (0133) 
                                        (0134) .SECTION
                                        (0135) ;-----------------------------------------------------------------------------
                                        (0136) ;  FUNCTION NAME: ENC1A_PEDGE_Stop
                                        (0137) ;
                                        (0138) ;  DESCRIPTION:
                                        (0139) ;     Stops the Digital Buffers within the block. The outputs are driven low.
                                        (0140) ;-----------------------------------------------------------------------------
                                        (0141) ;
                                        (0142) ;  ARGUMENTS:    None
                                        (0143) ;  RETURNS:      Nothing
                                        (0144) ;  SIDE EFFECTS:
                                        (0145) ;    The A and X registers may be modified by this or future implementations
                                        (0146) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0147) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0148) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0149) ;    functions.
                                        (0150) ;
                                        (0151)  ENC1A_PEDGE_Stop:
                                        (0152) _ENC1A_PEDGE_Stop:
                                        (0153)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0154)    ENC1A_PEDGE_Stop_M
                                        (0155)    RAM_EPILOGUE RAM_USE_CLASS_1
0AD2: 7F       RET                      (0156)    ret
                                        (0157) 
                                        (0158) .ENDSECTION
                                        (0159) 
                                        (0160) 
                                        (0161) ; End of File ENC1A_PEDGE.asm
                                        (0162) 
                                        (0163) 
FILE: lib\enc1a_nedge.asm               (0001) ;;*****************************************************************************
0AD3: 43 E1 10 OR    REG[0xE1],0x10     (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: ENC1A_NEDGE.asm
                                        (0004) ;;   Version: 1.60, Updated on 2014/7/14 at 8:13:31
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: DigInv User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "ENC1A_NEDGE.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) 
                                        (0027) ;-----------------------------------------------
                                        (0028) ;  Global Symbols
                                        (0029) ;-----------------------------------------------
                                        (0030) export   ENC1A_NEDGE_EnableInt
                                        (0031) export  _ENC1A_NEDGE_EnableInt
                                        (0032) export   ENC1A_NEDGE_DisableInt
                                        (0033) export  _ENC1A_NEDGE_DisableInt
                                        (0034) export   ENC1A_NEDGE_Start
                                        (0035) export  _ENC1A_NEDGE_Start
                                        (0036) export   ENC1A_NEDGE_Stop
                                        (0037) export  _ENC1A_NEDGE_Stop
                                        (0038) 
                                        (0039) ;-----------------------------------------------
                                        (0040) ;  EQUATES
                                        (0041) ;-----------------------------------------------
                                        (0042) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                        (0043) 
                                        (0044) area UserModules (ROM, REL)
                                        (0045) 
                                        (0046) .SECTION
                                        (0047) ;-----------------------------------------------------------------------------
                                        (0048) ;  FUNCTION NAME: ENC1A_NEDGE_EnableInt
                                        (0049) ;
                                        (0050) ;  DESCRIPTION:
                                        (0051) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                        (0052) ;     bit associated with this User Module. Remember to call the global interrupt
                                        (0053) ;     enable function by using the macro: M8C_EnableGInt.
                                        (0054) ;
                                        (0055) ;-----------------------------------------------------------------------------
                                        (0056) ;
                                        (0057) ;  ARGUMENTS: none
                                        (0058) ;
                                        (0059) ;  RETURNS: none
                                        (0060) ;
                                        (0061) ;  SIDE EFFECTS:
                                        (0062) ;    The A and X registers may be modified by this or future implementations
                                        (0063) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0064) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0065) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0066) ;    functions.
                                        (0067) ;
                                        (0068)  ENC1A_NEDGE_EnableInt:
                                        (0069) _ENC1A_NEDGE_EnableInt:
                                        (0070)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0071)    M8C_EnableIntMask ENC1A_NEDGE_INT_REG, ENC1A_NEDGE_bINT_MASK
                                        (0072)    RAM_EPILOGUE RAM_USE_CLASS_1
0AD6: 7F       RET                      (0073)    ret
0AD7: 41 E1 EF AND   REG[0xE1],0xEF     
                                        (0074) .ENDSECTION
                                        (0075) 
                                        (0076) .SECTION
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) ;  FUNCTION NAME: ENC1A_NEDGE_DisableInt
                                        (0079) ;
                                        (0080) ;  DESCRIPTION:
                                        (0081) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                        (0082) ;     associated with this User Module.
                                        (0083) ;
                                        (0084) ;-----------------------------------------------------------------------------
                                        (0085) ;
                                        (0086) ;  ARGUMENTS:  none
                                        (0087) ;
                                        (0088) ;  RETURNS:  none
                                        (0089) ;
                                        (0090) ;  SIDE EFFECTS:
                                        (0091) ;    The A and X registers may be modified by this or future implementations
                                        (0092) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0093) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0094) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0095) ;    functions.
                                        (0096) ;
                                        (0097)  ENC1A_NEDGE_DisableInt:
                                        (0098) _ENC1A_NEDGE_DisableInt:
                                        (0099)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0100)    M8C_DisableIntMask ENC1A_NEDGE_INT_REG, ENC1A_NEDGE_bINT_MASK
                                        (0101)    RAM_EPILOGUE RAM_USE_CLASS_1
0ADA: 7F       RET                      (0102)    ret
                                        (0103) .ENDSECTION
                                        (0104) 
                                        (0105) .SECTION
                                        (0106) ;-----------------------------------------------------------------------------
                                        (0107) ;  FUNCTION NAME: ENC1A_NEDGE_Start
                                        (0108) ;
                                        (0109) ;  DESCRIPTION:
                                        (0110) ;     Sets the start bit in the Control register of this user module.
                                        (0111) ;
                                        (0112) ;-----------------------------------------------------------------------------
                                        (0113) ;
                                        (0114) ;  ARGUMENTS: none
                                        (0115) ;
                                        (0116) ;  RETURNS: none
                                        (0117) ;
                                        (0118) ;  SIDE EFFECTS:
                                        (0119) ;    The A and X registers may be modified by this or future implementations
                                        (0120) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0121) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0122) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0123) ;    functions.
                                        (0124) ;
                                        (0125) ;  THEORY of OPERATION or PROCEDURE:
                                        (0126) ;
                                        (0127) ;     1) Save the Interrupt register
                                        (0128) ;     2) Save the Output register
                                        (0129) ;     3) Save the input register
                                        (0130) ;     4) Switch the output to Disabled - LOW
                                        (0131) ;     5) Disable Interrupt
                                        (0132) ;     6) Start the DigInv
                                        (0133) ;     7) Re-instate the input source
                                        (0134) ;     8) Re-instate the output
                                        (0135) ;     9) Re-instate the Interrupt register
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137)  ENC1A_NEDGE_Start:
                                        (0138) _ENC1A_NEDGE_Start:
                                        (0139)    RAM_PROLOGUE RAM_USE_CLASS_1
0ADB: 08       PUSH  A                  (0140)    push  A
                                        (0141) 
                                        (0142)    ; The DigInv must see a positive clock edge in order to "start" itself
                                        (0143)    ; in the correct state.  Once it sees a clock edge, it will follow its
                                        (0144)    ; input source.  To do this, we disable outputs, switch the input source
                                        (0145)    ; to the 48MHz clock, start the DigInv, re-instate the user's input source
                                        (0146)    ; and then re-instate the output.
                                        (0147) 
                                        (0148)    ; disable the interrupt
0ADC: 5D E1    MOV   A,REG[0xE1]        (0149)    mov   A, REG[ENC1A_NEDGE_INT_REG]
0ADE: 08       PUSH  A                  (0150)    push  A
0ADF: 41 E1 EF AND   REG[0xE1],0xEF     
0AE2: 71 10    OR    F,0x10             
                                        (0151) 
                                        (0152)    M8C_DisableIntMask ENC1A_NEDGE_INT_REG, ENC1A_NEDGE_bINT_MASK
                                        (0153) 
                                        (0154)    M8C_SetBank1
                                        (0155)    ; set the output to disable - will remain low!
0AE4: 5D 32    MOV   A,REG[0x32]        (0156)    mov   A, REG[ENC1A_NEDGE_OUTPUT_REG]
0AE6: 08       PUSH  A                  (0157)    push  A
                                        (0158) 
0AE7: 62 32 00 MOV   REG[0x32],0x0      (0159)    mov   REG[ENC1A_NEDGE_OUTPUT_REG], 0
                                        (0160) 
                                        (0161)    ; set the input to the 48MHz clock
0AEA: 5D 31    MOV   A,REG[0x31]        (0162)    mov   A, REG[ENC1A_NEDGE_INPUT_REG]
0AEC: 08       PUSH  A                  (0163)    push  A
                                        (0164) 
0AED: 62 31 04 MOV   REG[0x31],0x4      (0165)    mov   REG[ENC1A_NEDGE_INPUT_REG], 04
0AF0: 70 EF    AND   F,0xEF             
                                        (0166) 
                                        (0167)    M8C_SetBank0
                                        (0168)    ; start the inverter
0AF2: 43 33 01 OR    REG[0x33],0x1      (0169)    or    REG[ENC1A_NEDGE_CONTROL_REG], bfCONTROL_REG_START_BIT
0AF5: 71 10    OR    F,0x10             
                                        (0170) 
                                        (0171)    ; Re-instate the input
                                        (0172)    M8C_SetBank1
0AF7: 18       POP   A                  (0173)    pop   A
0AF8: 60 31    MOV   REG[0x31],A        (0174)    mov   REG[ENC1A_NEDGE_INPUT_REG], A
                                        (0175) 
                                        (0176)    ; Re-instate the output
0AFA: 18       POP   A                  (0177)    pop   A
0AFB: 60 32    MOV   REG[0x32],A        (0178)    mov   REG[ENC1A_NEDGE_OUTPUT_REG], A
0AFD: 70 EF    AND   F,0xEF             
0AFF: 62 DB EF MOV   REG[0xDB],0xEF     
                                        (0179)    M8C_SetBank0
                                        (0180) 
                                        (0181)    ;clear interrupt
                                        (0182)    M8C_ClearIntFlag INT_CLR1, ENC1A_NEDGE_bINT_MASK
                                        (0183) 
                                        (0184)    ; Re-instate the interrupt state
0B02: 18       POP   A                  (0185)    pop   A
0B03: 60 E1    MOV   REG[0xE1],A        (0186)    mov   REG[ENC1A_NEDGE_INT_REG], A
                                        (0187) 
                                        (0188)    ;Done!
0B05: 18       POP   A                  (0189)    pop   A
                                        (0190)    RAM_EPILOGUE RAM_USE_CLASS_1
0B06: 7F       RET                      (0191)    ret
                                        (0192) 
                                        (0193) .ENDSECTION
                                        (0194) 
                                        (0195) .SECTION
                                        (0196) ;-----------------------------------------------------------------------------
                                        (0197) ;  FUNCTION NAME: ENC1A_NEDGE_Stop
                                        (0198) ;
                                        (0199) ;  DESCRIPTION:
                                        (0200) ;     Halts operation of the Digital Inverter.  Output is set LOW.
                                        (0201) ;
                                        (0202) ;-----------------------------------------------------------------------------
                                        (0203) ;
                                        (0204) ;  ARGUMENTS: none
                                        (0205) ;
                                        (0206) ;  RETURNS: none
                                        (0207) ;
                                        (0208) ;  SIDE EFFECTS:
                                        (0209) ;    The A and X registers may be modified by this or future implementations
                                        (0210) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0211) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0212) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0213) ;    functions.
                                        (0214) ;
                                        (0215)  ENC1A_NEDGE_Stop:
                                        (0216) _ENC1A_NEDGE_Stop:
                                        (0217) 
                                        (0218)    RAM_PROLOGUE RAM_USE_CLASS_1
0B07: 41 33 FE AND   REG[0x33],0xFE     (0219)    and   REG[ENC1A_NEDGE_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                        (0220)    RAM_EPILOGUE RAM_USE_CLASS_1
0B0A: 7F       RET                      (0221)    ret
                                        (0222) 
                                        (0223) .ENDSECTION
                                        (0224) 
                                        (0225) ; End of File ENC1A_NEDGE.asm
                                        (0226) 
                                        (0227) 
                                        (0228) 
FILE: C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
(0001) /**
(0002) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0003) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Table of commands^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0004) 
(0005) MAV 	 		'a' //Move at velocity
(0006) MOV 	 		'b' //move at duty cycle
(0007) GETV 	 		'c' //get velocity
(0008) SRV0_POS 	 	'd' //set servo positions for servo 0 (starts PWM)
(0009) SRV1_POS 	 	'e' //set servo positions for servo 1 (starts PWM)
(0010) SRV0_STP 		'f' //Turns a servo 0 off (stops PWM)
(0011) SRV1_STP 		'g' //Turns a servo 1 off (stops PWM)
(0012) GETC1	 		'h' //get encoder1 count
(0013) GETC2	 		'i' //get encoder2 count
(0014) RSTC1	 		'j' //reset encoder1 count
(0015) RSTC2	 		'k' //reset encoder2 count
(0016) STOP			'l' //stop motors
(0017) FORWARD			'm' //sets drive mode to forward
(0018) BACKWARD		'n' //sets drive mode to backward
(0019) TURNL			'o' //sets drive mode to left turn
(0020) TURNR			'p' //sets drive mode to right turn
(0021) 
(0022) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0023) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Serial Limitations^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0024) 
(0025) Baude rate			115200
(0026) RX Buffer size		16 bytes
(0027) 
(0028) UART RX 			P2[7]
(0029) UART TX				P0[1]
(0030) 
(0031) * Theoretically 115200 bytes can be sent in one second, at minimum, and 115216 at maximum before buffer overflow.
(0032) 
(0033) * All UART commands have either one or zero parameters. All commands must be terminated with an ACII BEL (0x07).
(0034)   Command parameters may be space delimited from the command or can be sent as just a single string. 
(0035) 
(0036) Examples:
(0037) 
(0038) "a25" - move at velcoity 25 RPM.
(0039) "a 25" - move at velocity 25 RPM
(0040) 
(0041) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0042) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Servo Information^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0043) 
(0044) Servo0		P0[3] (MISC0)
(0045) Servo1		P0[7] (MISC2)
(0046) 
(0047) 16 bit resoltion for each. Every tick = 1 us.
(0048) 
(0049) Servo accepts PWM range from ~700 us to ~2200 us for a 180* servo.
(0050) 
(0051) RPi will convert servo angle to pulse width and send to PSoC. Then the servo angle will be set by writing the
(0052) Pulse width to the PWM register.
(0053) 
(0054) **NOTE**
(0055) Higer resolution can be achieved by using a faster clock and allowing for more ticks but 1 Mhz clock 1 us tick
(0056) makes calculations a little easier.
(0057) 
(0058) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0059) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Drive Modes^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0060) 
(0061) The motor driver must be configured for each of our drive modes. The drive modes are defined as follows:
(0062) 
(0063) INPUT		1A		1B		2A		2B
(0064) =======================================
(0065) Forward		1		0		1		0
(0066) Backward	0		1		0		1
(0067) Left		1		0		0		1
(0068) Right		0		1		1		0
(0069) 
(0070) In general for one motor
(0071) 
(0072) INPUT		A		B
(0073) ======================
(0074) Drift		1		1 	(causes robot to coast)
(0075) CCW			0		1
(0076) CW			1		0
(0077) Stop		0		0
(0078) 
(0079) If STDBY is asserted (ie. pulled LOW) then all modes are treated as STOP.
(0080) 
(0081) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0082) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Debug Mode^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0083) 
(0084) A debug mode is provided for getting serial print statements to indicate useful data when passing commands
(0085) to the PSoC. To enable this mode assert MISC7 and MISC8 as high at power on. (ie, connect MISC7 and MISC8
(0086) to VCC before powering on).
(0087) 
(0088) After the init() function is called their states will be read and a flag will be set according to those states.
(0089) If debug mode is not desired merely leave those pins floating.
(0090) 
(0091) MISC7		P1[2]
(0092) MISC8		P1[3]
(0093) 
(0094) */
(0095) 
(0096) #include <stdlib.h>
(0097) #include <m8c.h>        // part specific constants and macros
(0098) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0099) 
(0100) #pragma interrupt_handler encoder1_ISR
(0101) #pragma interrupt_handler encoder2_ISR
(0102) 
(0103) #define 	stateA1 		0x20
(0104) #define 	stateB1 		0x08
(0105) #define 	stateA2 		0x10
(0106) #define 	stateB2 		0x04
(0107) 
(0108) const BYTE	debug_mask	=	MISC7_MASK | MISC8_MASK;
(0109) const char 	TERM		=	0x07;
(0110) 
(0111) BOOL command_flag 		=	FALSE;
(0112) BOOL debug				=	FALSE;
(0113) 
(0114) int i = 0; //loop var
(0115) 
(0116) BYTE curPrt1;
(0117) BYTE prevPrt1;
(0118) BYTE curPrt2;
(0119) BYTE prevPrt2;
(0120) 
(0121) signed long int count1 = 0;
(0122) signed long int count2 = 0;
(0123) 
(0124) void init(void);
(0125) void action(char command, char* param);
(0126) int getVelocity(void);
(0127) 
(0128) void main(void)
(0129) {
__UserModules_end|_main|__text_start|_main:
  param                --> X+2
  command              --> X+1
  data                 --> X+0
    0B0B: 10       PUSH  X
    0B0C: 4F       MOV   X,SP
    0B0D: 38 04    ADD   SP,0x4
(0130) 	char command;
(0131) 	char* param;
(0132) 	char data;
(0133) 	
(0134) 	init();
    0B0F: 90 D7    CALL  _init
    0B11: 80 CF    JMP   0x0BE1
(0135) 	
(0136) 	while(1)
(0137) 	{
(0138) 		//read the state of encoders. this will be needed if we interrupt.
(0139) 		prevPrt1 = (ENC1A_Data_ADDR & (ENC1A_MASK | ENC1B_MASK));
    0B13: 5D 08    MOV   A,REG[0x8]
    0B15: 21 50    AND   A,0x50
    0B17: 62 D0 00 MOV   REG[0xD0],0x0
    0B1A: 53 2B    MOV   [prevPrt1],A
(0140) 		prevPrt2 = (ENC2A_Data_ADDR & (ENC2A_MASK | ENC2B_MASK));
    0B1C: 5D 08    MOV   A,REG[0x8]
    0B1E: 21 28    AND   A,0x28
    0B20: 62 D0 00 MOV   REG[0xD0],0x0
    0B23: 53 29    MOV   [prevPrt2],A
(0141) 		
(0142) 		data = UART_cReadChar(); //check for data
    0B25: 10       PUSH  X
    0B26: 7C 07 EC LCALL _UART_cReadChar
    0B29: 20       POP   X
    0B2A: 54 00    MOV   [X+0],A
(0143) 		
(0144) 		if (!command_flag && data) //no command has been read and data is valid (not null)
    0B2C: 62 D0 00 MOV   REG[0xD0],0x0
    0B2F: 3C 27 00 CMP   [command_flag],0x0
    0B32: B0 22    JNZ   0x0B55
    0B34: 3D 00 00 CMP   [X+0],0x0
    0B37: A0 1D    JZ    0x0B55
(0145) 		{
(0146) 			if (debug)
    0B39: 62 D0 00 MOV   REG[0xD0],0x0
    0B3C: 3C 28 00 CMP   [debug],0x0
    0B3F: A0 08    JZ    0x0B48
(0147) 				UART_PutChar(data);
    0B41: 10       PUSH  X
    0B42: 52 00    MOV   A,[X+0]
    0B44: 7C 07 DC LCALL _UART_PutChar
    0B47: 20       POP   X
(0148) 			
(0149) 			command_flag = TRUE;
    0B48: 62 D0 00 MOV   REG[0xD0],0x0
    0B4B: 55 27 01 MOV   [command_flag],0x1
(0150) 			command = data;
    0B4E: 52 00    MOV   A,[X+0]
    0B50: 54 01    MOV   [X+1],A
(0151) 			data = '\0';
    0B52: 56 00 00 MOV   [X+0],0x0
(0152) 		}
(0153) 		if (data && command_flag)//command byte read and data is valid (not null)
    0B55: 3D 00 00 CMP   [X+0],0x0
    0B58: A0 88    JZ    0x0BE1
    0B5A: 62 D0 00 MOV   REG[0xD0],0x0
    0B5D: 3C 27 00 CMP   [command_flag],0x0
    0B60: A0 80    JZ    0x0BE1
(0154) 		{
(0155) 			if (data == TERM) //command terminator read
    0B62: 62 D0 00 MOV   REG[0xD0],0x0
    0B65: 50 01    MOV   A,0x1
    0B67: 10       PUSH  X
    0B68: 57 A1    MOV   X,0xA1
    0B6A: 28       ROMX  
    0B6B: 20       POP   X
    0B6C: 53 1A    MOV   [__r0],A
    0B6E: 52 00    MOV   A,[X+0]
    0B70: 3A 1A    CMP   A,[__r0]
    0B72: B0 3B    JNZ   0x0BAE
(0156) 			{
(0157) 				command_flag = FALSE;
    0B74: 62 D0 00 MOV   REG[0xD0],0x0
    0B77: 55 27 00 MOV   [command_flag],0x0
(0158) 				param[i] = '\0'; //null terminate parameter string
    0B7A: 62 D0 00 MOV   REG[0xD0],0x0
    0B7D: 51 24    MOV   A,[i+1]
    0B7F: 03 03    ADD   A,[X+3]
    0B81: 62 D0 00 MOV   REG[0xD0],0x0
    0B84: 53 19    MOV   [__r1],A
    0B86: 62 D0 00 MOV   REG[0xD0],0x0
    0B89: 51 23    MOV   A,[i]
    0B8B: 0B 02    ADC   A,[X+2]
    0B8D: 62 D0 00 MOV   REG[0xD0],0x0
    0B90: 60 D5    MOV   REG[0xD5],A
    0B92: 50 00    MOV   A,0x0
    0B94: 3F 19    MVI   [__r1],A
(0159) 				action(command, param);
    0B96: 52 02    MOV   A,[X+2]
    0B98: 08       PUSH  A
    0B99: 52 03    MOV   A,[X+3]
    0B9B: 08       PUSH  A
    0B9C: 52 01    MOV   A,[X+1]
    0B9E: 08       PUSH  A
    0B9F: 91 2E    CALL  _action
    0BA1: 38 FD    ADD   SP,0xFD
(0160) 				i = 0; //reset counter
    0BA3: 62 D0 00 MOV   REG[0xD0],0x0
    0BA6: 55 24 00 MOV   [i+1],0x0
    0BA9: 55 23 00 MOV   [i],0x0
(0161) 			}
    0BAC: 80 34    JMP   0x0BE1
(0162) 			else //read parameter byte 
(0163) 			{
(0164) 				if (debug)
    0BAE: 62 D0 00 MOV   REG[0xD0],0x0
    0BB1: 3C 28 00 CMP   [debug],0x0
    0BB4: A0 08    JZ    0x0BBD
(0165) 					UART_PutChar(data);
    0BB6: 10       PUSH  X
    0BB7: 52 00    MOV   A,[X+0]
    0BB9: 7C 07 DC LCALL _UART_PutChar
    0BBC: 20       POP   X
(0166) 				
(0167) 				param[i] = data;
    0BBD: 62 D0 00 MOV   REG[0xD0],0x0
    0BC0: 51 24    MOV   A,[i+1]
    0BC2: 03 03    ADD   A,[X+3]
    0BC4: 62 D0 00 MOV   REG[0xD0],0x0
    0BC7: 53 19    MOV   [__r1],A
    0BC9: 62 D0 00 MOV   REG[0xD0],0x0
    0BCC: 51 23    MOV   A,[i]
    0BCE: 0B 02    ADC   A,[X+2]
    0BD0: 62 D0 00 MOV   REG[0xD0],0x0
    0BD3: 60 D5    MOV   REG[0xD5],A
    0BD5: 52 00    MOV   A,[X+0]
    0BD7: 3F 19    MVI   [__r1],A
(0168) 				i++;
    0BD9: 62 D0 00 MOV   REG[0xD0],0x0
    0BDC: 76 24    INC   [i+1]
    0BDE: 0E 23 00 ADC   [i],0x0
(0169) 			}
(0170) 		}
(0171) 	}
    0BE1: 8F 31    JMP   0x0B13
    0BE3: 38 FC    ADD   SP,0xFC
    0BE5: 20       POP   X
    0BE6: 8F FF    JMP   0x0BE6
(0172) }
(0173) 
(0174) void init(void)
(0175) {
_init:
  debug_conf           --> X+0
    0BE8: 10       PUSH  X
    0BE9: 4F       MOV   X,SP
    0BEA: 38 01    ADD   SP,0x1
(0176) 	BYTE debug_conf;
(0177) 	
(0178) 	//enable the positive edge and falling edge paramers
(0179) 	ENC1A_PEDGE_Start();
    0BEC: 10       PUSH  X
    0BED: 7C 0A CB LCALL _ENC1A_PEDGE_Start
(0180) 	ENC1B_PEDGE_Start();
    0BF0: 7C 0A 82 LCALL _ENC1B_PEDGE_Start
(0181) 	ENC1A_NEDGE_Start();
    0BF3: 7C 0A DB LCALL _ENC1A_NEDGE_Start
(0182) 	ENC1B_NEDGE_Start();
    0BF6: 7C 0A 93 LCALL _ENC1B_NEDGE_Start
(0183) 	
(0184) 	//enable the falling edge and positive edge interrupts for Encoder 1
(0185) 	ENC1A_PEDGE_EnableInt();
    0BF9: 7C 0A C3 LCALL _ENC1A_PEDGE_EnableInt
(0186) 	ENC1B_PEDGE_EnableInt();
    0BFC: 7C 0A 7A LCALL _ENC1B_PEDGE_EnableInt
(0187) 	ENC1A_NEDGE_EnableInt();
    0BFF: 7C 0A D3 LCALL _ENC1A_NEDGE_EnableInt
(0188) 	ENC1B_NEDGE_EnableInt();
    0C02: 7C 0A 8B LCALL _ENC1B_NEDGE_EnableInt
(0189) 	
(0190) 	//Start motor speed PWMs
(0191) 	PWMA_Start();
    0C05: 7C 0A 3C LCALL _PWMA_Start
(0192) 	PWMB_Start();
    0C08: 7C 09 F5 LCALL _PWMB_Start
(0193) 	
(0194) 	//Start servos
(0195) 	Servo0_Start();
    0C0B: 7C 09 98 LCALL _Servo0_Start
(0196) 	Servo1_Start();
    0C0E: 7C 09 3B LCALL _Servo1_Start
(0197) 	
(0198) 	//start the UART
(0199) 	UART_Start(UART_PARITY_NONE);
    0C11: 50 00    MOV   A,0x0
    0C13: 7C 07 68 LCALL _UART_Start
    0C16: 20       POP   X
(0200) 	
(0201) 	//enable appropriate interrupts
(0202) 	M8C_EnableIntMask(INT_MSK0, INT_MSK0_GPIO);
    0C17: 43 E0 20 OR    REG[0xE0],0x20
(0203) 	M8C_EnableIntMask(INT_MSK1, INT_MSK1_DBB00);
    0C1A: 43 E1 01 OR    REG[0xE1],0x1
(0204) 	M8C_EnableIntMask(INT_MSK1, INT_MSK1_DBB11);
    0C1D: 43 E1 20 OR    REG[0xE1],0x20
(0205) 	M8C_EnableGInt;
    0C20: 71 01    OR    F,0x1
(0206) 	
(0207) 	UART_PutCRLF();
    0C22: 10       PUSH  X
    0C23: 7C 08 91 LCALL _UART_PutCRLF
(0208) 	UART_CPutString("KIPR bots roll out!");
    0C26: 50 03    MOV   A,0x3
    0C28: 08       PUSH  A
    0C29: 50 31    MOV   A,0x31
    0C2B: 5C       MOV   X,A
    0C2C: 18       POP   A
    0C2D: 7C 08 7F LCALL _UART_CPutString
(0209) 	UART_PutCRLF();	
    0C30: 7C 08 91 LCALL _UART_PutCRLF
    0C33: 20       POP   X
(0210) 		
(0211) 	//clear drive mode settings for MISC7
(0212) 	MISC7_DriveMode_0_ADDR &= ~MISC7_MASK;
    0C34: 71 10    OR    F,0x10
    0C36: 41 04 FB AND   REG[0x4],0xFB
(0213) 	MISC7_DriveMode_1_ADDR &= ~MISC7_MASK;
    0C39: 41 05 FB AND   REG[0x5],0xFB
(0214) 	MISC7_DriveMode_2_ADDR &= ~MISC7_MASK;
    0C3C: 70 CF    AND   F,0xCF
    0C3E: 41 07 FB AND   REG[0x7],0xFB
(0215) 	
(0216) 	//clear drive mode settings for MISC8
(0217) 	MISC8_DriveMode_0_ADDR &= ~MISC8_MASK;
    0C41: 71 10    OR    F,0x10
    0C43: 41 04 F7 AND   REG[0x4],0xF7
(0218) 	MISC8_DriveMode_1_ADDR &= ~MISC8_MASK;
    0C46: 41 05 F7 AND   REG[0x5],0xF7
(0219) 	MISC8_DriveMode_2_ADDR &= ~MISC8_MASK;
    0C49: 70 CF    AND   F,0xCF
    0C4B: 41 07 F7 AND   REG[0x7],0xF7
(0220) 	
(0221) 	//now that their settings are cleared set their mode to
(0222) 	//HIGH-Z to use them as debug point inputs.
(0223) 	MISC7_DriveMode_1_ADDR |= MISC7_MASK;
    0C4E: 71 10    OR    F,0x10
    0C50: 43 05 04 OR    REG[0x5],0x4
(0224) 	
(0225) 	MISC8_DriveMode_1_ADDR |= MISC8_MASK;
    0C53: 43 05 08 OR    REG[0x5],0x8
(0226) 	
(0227) 	//read the debug inputs, if they are high then they are
(0228) 	//being purposefully asserted to enter debug mode.
(0229) 	debug_conf = (MISC7_Data_ADDR & MISC7_MASK) | (MISC8_Data_ADDR & MISC8_MASK);
    0C56: 70 CF    AND   F,0xCF
    0C58: 5D 04    MOV   A,REG[0x4]
    0C5A: 62 D0 00 MOV   REG[0xD0],0x0
    0C5D: 53 1A    MOV   [__r0],A
    0C5F: 26 1A 08 AND   [__r0],0x8
    0C62: 5D 04    MOV   A,REG[0x4]
    0C64: 53 18    MOV   [__r2],A
    0C66: 26 18 04 AND   [__r2],0x4
    0C69: 51 18    MOV   A,[__r2]
    0C6B: 2A 1A    OR    A,[__r0]
    0C6D: 54 00    MOV   [X+0],A
(0230) 	
(0231) 	if (debug_conf == debug_mask)
    0C6F: 50 01    MOV   A,0x1
    0C71: 10       PUSH  X
    0C72: 57 A0    MOV   X,0xA0
    0C74: 28       ROMX  
    0C75: 20       POP   X
    0C76: 53 1A    MOV   [__r0],A
    0C78: 52 00    MOV   A,[X+0]
    0C7A: 3A 1A    CMP   A,[__r0]
    0C7C: B0 07    JNZ   0x0C84
(0232) 		debug = TRUE;
    0C7E: 62 D0 00 MOV   REG[0xD0],0x0
    0C81: 55 28 01 MOV   [debug],0x1
(0233) 	
(0234) 	//afterwards reset MISC pins to their intended state
(0235) 	MISC7_DriveMode_0_ADDR &= ~MISC7_MASK;
    0C84: 71 10    OR    F,0x10
    0C86: 41 04 FB AND   REG[0x4],0xFB
(0236) 	MISC7_DriveMode_1_ADDR &= ~MISC7_MASK;
    0C89: 41 05 FB AND   REG[0x5],0xFB
(0237) 	MISC7_DriveMode_2_ADDR &= ~MISC7_MASK;
    0C8C: 70 CF    AND   F,0xCF
    0C8E: 41 07 FB AND   REG[0x7],0xFB
(0238) 	
(0239) 	MISC8_DriveMode_0_ADDR &= ~MISC8_MASK;
    0C91: 71 10    OR    F,0x10
    0C93: 41 04 F7 AND   REG[0x4],0xF7
(0240) 	MISC8_DriveMode_1_ADDR &= ~MISC8_MASK;
    0C96: 41 05 F7 AND   REG[0x5],0xF7
(0241) 	MISC8_DriveMode_2_ADDR &= ~MISC8_MASK;
    0C99: 70 CF    AND   F,0xCF
    0C9B: 41 07 F7 AND   REG[0x7],0xF7
(0242) 	
(0243) 	//set MISC7 and MISC8 to HIGH-Z Analog
(0244) 	MISC7_DriveMode_2_ADDR |= MISC7_MASK;
    0C9E: 43 07 04 OR    REG[0x7],0x4
(0245) 	MISC7_DriveMode_1_ADDR |= MISC7_MASK;
    0CA1: 71 10    OR    F,0x10
    0CA3: 43 05 04 OR    REG[0x5],0x4
(0246) 	
(0247) 	MISC8_DriveMode_2_ADDR |= MISC8_MASK;
    0CA6: 70 CF    AND   F,0xCF
    0CA8: 43 07 08 OR    REG[0x7],0x8
(0248) 	MISC8_DriveMode_1_ADDR |= MISC8_MASK;
    0CAB: 71 10    OR    F,0x10
    0CAD: 43 05 08 OR    REG[0x5],0x8
    0CB0: 70 CF    AND   F,0xCF
    0CB2: 38 FF    ADD   SP,0xFF
    0CB4: 20       POP   X
    0CB5: 7F       RET   
(0249) }
(0250) 
(0251) /* Calculates the velocity in RPMs and returns the value */
(0252) int getVelocity(void)
(0253) {
_getVelocity:
  vel                  --> X+0
    0CB6: 10       PUSH  X
    0CB7: 4F       MOV   X,SP
    0CB8: 38 02    ADD   SP,0x2
(0254) 	int vel = 0;
    0CBA: 56 01 00 MOV   [X+1],0x0
    0CBD: 56 00 00 MOV   [X+0],0x0
(0255) 	return vel;	
    0CC0: 62 D0 00 MOV   REG[0xD0],0x0
    0CC3: 52 01    MOV   A,[X+1]
    0CC5: 53 19    MOV   [__r1],A
    0CC7: 52 00    MOV   A,[X+0]
    0CC9: 53 1A    MOV   [__r0],A
    0CCB: 38 FE    ADD   SP,0xFE
    0CCD: 20       POP   X
    0CCE: 7F       RET   
(0256) }
(0257) 
(0258) /* Action lookup. Takes the appropriate action for the given command and param.
(0259)  * command: the command read from the UART.
(0260)  * param: the data (if any) associated with the command.
(0261)  */
(0262) void action(char command, char* param)
(0263) {	
_action:
  param                --> X-6
  command              --> X-4
    0CCF: 10       PUSH  X
    0CD0: 4F       MOV   X,SP
    0CD1: 38 02    ADD   SP,0x2
(0264) 	if(debug)
    0CD3: 62 D0 00 MOV   REG[0xD0],0x0
    0CD6: 3C 28 00 CMP   [debug],0x0
    0CD9: A0 33    JZ    0x0D0D
(0265) 	{
(0266) 		UART_PutCRLF();
    0CDB: 10       PUSH  X
    0CDC: 7C 08 91 LCALL _UART_PutCRLF
(0267) 		UART_CPutString("Command: ");
    0CDF: 50 03    MOV   A,0x3
    0CE1: 08       PUSH  A
    0CE2: 50 27    MOV   A,0x27
    0CE4: 5C       MOV   X,A
    0CE5: 18       POP   A
    0CE6: 7C 08 7F LCALL _UART_CPutString
    0CE9: 20       POP   X
(0268) 		UART_PutChar(command);
    0CEA: 10       PUSH  X
    0CEB: 52 FC    MOV   A,[X-4]
    0CED: 7C 07 DC LCALL _UART_PutChar
(0269) 		UART_PutCRLF();
    0CF0: 7C 08 91 LCALL _UART_PutCRLF
(0270) 		UART_CPutString("Param: ");
    0CF3: 50 03    MOV   A,0x3
    0CF5: 08       PUSH  A
    0CF6: 50 1F    MOV   A,0x1F
    0CF8: 5C       MOV   X,A
    0CF9: 18       POP   A
    0CFA: 7C 08 7F LCALL _UART_CPutString
    0CFD: 20       POP   X
(0271) 		UART_PutString(param);
    0CFE: 10       PUSH  X
    0CFF: 52 FA    MOV   A,[X-6]
    0D01: 08       PUSH  A
    0D02: 52 FB    MOV   A,[X-5]
    0D04: 5C       MOV   X,A
    0D05: 18       POP   A
    0D06: 7C 08 19 LCALL _UART_PutString
(0272) 		UART_PutCRLF();
    0D09: 7C 08 91 LCALL _UART_PutCRLF
    0D0C: 20       POP   X
(0273) 	}
(0274) 	
(0275) 	switch (command)
    0D0D: 52 FC    MOV   A,[X-4]
    0D0F: 54 01    MOV   [X+1],A
    0D11: 56 00 00 MOV   [X+0],0x0
    0D14: 52 01    MOV   A,[X+1]
    0D16: 11 61    SUB   A,0x61
    0D18: 52 00    MOV   A,[X+0]
    0D1A: 31 80    XOR   A,0x80
    0D1C: 19 80    SBB   A,0x80
    0D1E: C3 99    JC    0x10B8
    0D20: 50 70    MOV   A,0x70
    0D22: 13 01    SUB   A,[X+1]
    0D24: 52 00    MOV   A,[X+0]
    0D26: 31 80    XOR   A,0x80
    0D28: 62 D0 00 MOV   REG[0xD0],0x0
    0D2B: 53 14    MOV   [__rX],A
    0D2D: 50 80    MOV   A,0x80
    0D2F: 1A 14    SBB   A,[__rX]
    0D31: C3 86    JC    0x10B8
    0D33: 62 D0 00 MOV   REG[0xD0],0x0
    0D36: 52 01    MOV   A,[X+1]
    0D38: 11 61    SUB   A,0x61
    0D3A: 53 19    MOV   [__r1],A
    0D3C: 52 00    MOV   A,[X+0]
    0D3E: 19 00    SBB   A,0x0
    0D40: 53 1A    MOV   [__r0],A
    0D42: 65 19    ASL   [__r1]
    0D44: 6B 1A    RLC   [__r0]
    0D46: 06 19 4C ADD   [__r1],0x4C
    0D49: 0E 1A 05 ADC   [__r0],0x5
    0D4C: 51 1A    MOV   A,[__r0]
    0D4E: 10       PUSH  X
    0D4F: 58 19    MOV   X,[__r1]
    0D51: 08       PUSH  A
    0D52: 28       ROMX  
    0D53: 53 1A    MOV   [__r0],A
    0D55: 18       POP   A
    0D56: 75       INC   X
    0D57: 09 00    ADC   A,0x0
    0D59: 28       ROMX  
    0D5A: 53 19    MOV   [__r1],A
    0D5C: 20       POP   X
    0D5D: 51 1A    MOV   A,[__r0]
    0D5F: 08       PUSH  A
    0D60: 51 19    MOV   A,[__r1]
    0D62: 08       PUSH  A
    0D63: 7F       RET   
(0276) 	{
(0277) 		case 'a': //MAV
(0278) 			if (debug)
    0D64: 62 D0 00 MOV   REG[0xD0],0x0
    0D67: 3C 28 00 CMP   [debug],0x0
    0D6A: A3 73    JZ    0x10DE
(0279) 			{
(0280) 				UART_PutCRLF();
    0D6C: 10       PUSH  X
    0D6D: 7C 08 91 LCALL _UART_PutCRLF
(0281) 				UART_CPutString("Setting velocity to: ");
    0D70: 50 03    MOV   A,0x3
    0D72: 08       PUSH  A
    0D73: 50 09    MOV   A,0x9
    0D75: 5C       MOV   X,A
    0D76: 18       POP   A
    0D77: 7C 08 7F LCALL _UART_CPutString
    0D7A: 20       POP   X
(0282) 				UART_PutSHexInt(atoi(param));
    0D7B: 52 FA    MOV   A,[X-6]
    0D7D: 08       PUSH  A
    0D7E: 52 FB    MOV   A,[X-5]
    0D80: 08       PUSH  A
    0D81: 7C 11 CE LCALL _atoi
    0D84: 38 FE    ADD   SP,0xFE
    0D86: 10       PUSH  X
    0D87: 62 D0 00 MOV   REG[0xD0],0x0
    0D8A: 51 1A    MOV   A,[__r0]
    0D8C: 08       PUSH  A
    0D8D: 51 19    MOV   A,[__r1]
    0D8F: 20       POP   X
    0D90: 7C 07 D5 LCALL _UART_PutSHexInt
(0283) 				UART_PutCRLF();
    0D93: 7C 08 91 LCALL _UART_PutCRLF
    0D96: 20       POP   X
(0284) 			}
(0285) 			
(0286) 			break;
    0D97: 83 46    JMP   0x10DE
(0287) 		case 'b': //MOV
(0288) 			if (debug)
    0D99: 62 D0 00 MOV   REG[0xD0],0x0
    0D9C: 3C 28 00 CMP   [debug],0x0
    0D9F: A3 3E    JZ    0x10DE
(0289) 			{
(0290) 				UART_PutCRLF();
    0DA1: 10       PUSH  X
    0DA2: 7C 08 91 LCALL _UART_PutCRLF
(0291) 				UART_CPutString("Setting PWM duty cycle to: ");
    0DA5: 50 02    MOV   A,0x2
    0DA7: 08       PUSH  A
    0DA8: 50 ED    MOV   A,0xED
    0DAA: 5C       MOV   X,A
    0DAB: 18       POP   A
    0DAC: 7C 08 7F LCALL _UART_CPutString
    0DAF: 20       POP   X
(0292) 				UART_PutSHexInt(atoi(param));
    0DB0: 52 FA    MOV   A,[X-6]
    0DB2: 08       PUSH  A
    0DB3: 52 FB    MOV   A,[X-5]
    0DB5: 08       PUSH  A
    0DB6: 7C 11 CE LCALL _atoi
    0DB9: 38 FE    ADD   SP,0xFE
    0DBB: 10       PUSH  X
    0DBC: 62 D0 00 MOV   REG[0xD0],0x0
    0DBF: 51 1A    MOV   A,[__r0]
    0DC1: 08       PUSH  A
    0DC2: 51 19    MOV   A,[__r1]
    0DC4: 20       POP   X
    0DC5: 7C 07 D5 LCALL _UART_PutSHexInt
(0293) 				UART_PutCRLF();
    0DC8: 7C 08 91 LCALL _UART_PutCRLF
    0DCB: 20       POP   X
(0294) 			}
(0295) 			break;
    0DCC: 83 11    JMP   0x10DE
(0296) 		case 'c': //GETV
(0297) 			*param = 0;
    0DCE: 62 D0 00 MOV   REG[0xD0],0x0
    0DD1: 52 FB    MOV   A,[X-5]
    0DD3: 53 19    MOV   [__r1],A
    0DD5: 52 FA    MOV   A,[X-6]
    0DD7: 60 D5    MOV   REG[0xD5],A
    0DD9: 50 00    MOV   A,0x0
    0DDB: 3F 19    MVI   [__r1],A
(0298) 			UART_PutCRLF();
    0DDD: 10       PUSH  X
    0DDE: 7C 08 91 LCALL _UART_PutCRLF
    0DE1: 20       POP   X
(0299) 			UART_PutString(itoa(param, getVelocity(), 10));
    0DE2: 9E D2    CALL  _getVelocity
    0DE4: 50 00    MOV   A,0x0
    0DE6: 08       PUSH  A
    0DE7: 50 0A    MOV   A,0xA
    0DE9: 08       PUSH  A
    0DEA: 62 D0 00 MOV   REG[0xD0],0x0
    0DED: 51 1A    MOV   A,[__r0]
    0DEF: 08       PUSH  A
    0DF0: 51 19    MOV   A,[__r1]
    0DF2: 08       PUSH  A
    0DF3: 52 FA    MOV   A,[X-6]
    0DF5: 08       PUSH  A
    0DF6: 52 FB    MOV   A,[X-5]
    0DF8: 08       PUSH  A
    0DF9: 7C 13 0F LCALL _itoa
    0DFC: 38 FA    ADD   SP,0xFA
    0DFE: 10       PUSH  X
    0DFF: 62 D0 00 MOV   REG[0xD0],0x0
    0E02: 51 1A    MOV   A,[__r0]
    0E04: 08       PUSH  A
    0E05: 51 19    MOV   A,[__r1]
    0E07: 5C       MOV   X,A
    0E08: 18       POP   A
    0E09: 7C 08 19 LCALL _UART_PutString
(0300) 			UART_PutCRLF();
    0E0C: 7C 08 91 LCALL _UART_PutCRLF
    0E0F: 20       POP   X
(0301) 			break;
    0E10: 82 CD    JMP   0x10DE
(0302) 		case 'd': //SRV0_POS
(0303) 			if (debug)
    0E12: 62 D0 00 MOV   REG[0xD0],0x0
    0E15: 3C 28 00 CMP   [debug],0x0
    0E18: A0 2C    JZ    0x0E45
(0304) 			{
(0305) 				UART_PutCRLF();
    0E1A: 10       PUSH  X
    0E1B: 7C 08 91 LCALL _UART_PutCRLF
(0306) 				UART_CPutString("Setting servo 0 pulse width to: ");
    0E1E: 50 02    MOV   A,0x2
    0E20: 08       PUSH  A
    0E21: 50 CC    MOV   A,0xCC
    0E23: 5C       MOV   X,A
    0E24: 18       POP   A
    0E25: 7C 08 7F LCALL _UART_CPutString
    0E28: 20       POP   X
(0307) 				UART_PutSHexInt(atoi(param));
    0E29: 52 FA    MOV   A,[X-6]
    0E2B: 08       PUSH  A
    0E2C: 52 FB    MOV   A,[X-5]
    0E2E: 08       PUSH  A
    0E2F: 7C 11 CE LCALL _atoi
    0E32: 38 FE    ADD   SP,0xFE
    0E34: 10       PUSH  X
    0E35: 62 D0 00 MOV   REG[0xD0],0x0
    0E38: 51 1A    MOV   A,[__r0]
    0E3A: 08       PUSH  A
    0E3B: 51 19    MOV   A,[__r1]
    0E3D: 20       POP   X
    0E3E: 7C 07 D5 LCALL _UART_PutSHexInt
(0308) 				UART_PutCRLF();
    0E41: 7C 08 91 LCALL _UART_PutCRLF
    0E44: 20       POP   X
(0309) 			}
(0310) 			
(0311) 			if ((Servo0_CONTROL_LSB_REG & Servo0_CONTROL_REG_START_BIT) == 0x00) //servo has not been started
    0E45: 5D 27    MOV   A,REG[0x27]
    0E47: 62 D0 00 MOV   REG[0xD0],0x0
    0E4A: 53 1A    MOV   [__r0],A
    0E4C: 47 1A 01 TST   [__r0],0x1
    0E4F: B0 06    JNZ   0x0E56
(0312) 				Servo0_Start();
    0E51: 10       PUSH  X
    0E52: 7C 09 98 LCALL _Servo0_Start
    0E55: 20       POP   X
(0313) 			
(0314) 			Servo0_WritePulseWidth(atoi(param));
    0E56: 52 FA    MOV   A,[X-6]
    0E58: 08       PUSH  A
    0E59: 52 FB    MOV   A,[X-5]
    0E5B: 08       PUSH  A
    0E5C: 7C 11 CE LCALL _atoi
    0E5F: 38 FE    ADD   SP,0xFE
    0E61: 10       PUSH  X
    0E62: 62 D0 00 MOV   REG[0xD0],0x0
    0E65: 51 1A    MOV   A,[__r0]
    0E67: 08       PUSH  A
    0E68: 51 19    MOV   A,[__r1]
    0E6A: 20       POP   X
    0E6B: 7C 09 A6 LCALL _Servo0_WritePulseWidth
    0E6E: 20       POP   X
(0315) 			break;
    0E6F: 82 6E    JMP   0x10DE
(0316) 		case 'e': //SRV1_POS
(0317) 			if (debug)
    0E71: 62 D0 00 MOV   REG[0xD0],0x0
    0E74: 3C 28 00 CMP   [debug],0x0
    0E77: A0 2C    JZ    0x0EA4
(0318) 			{
(0319) 				UART_PutCRLF();
    0E79: 10       PUSH  X
    0E7A: 7C 08 91 LCALL _UART_PutCRLF
(0320) 				UART_CPutString("Setting servo 1 pulse width to: ");
    0E7D: 50 02    MOV   A,0x2
    0E7F: 08       PUSH  A
    0E80: 50 AB    MOV   A,0xAB
    0E82: 5C       MOV   X,A
    0E83: 18       POP   A
    0E84: 7C 08 7F LCALL _UART_CPutString
    0E87: 20       POP   X
(0321) 				UART_PutSHexInt(atoi(param));
    0E88: 52 FA    MOV   A,[X-6]
    0E8A: 08       PUSH  A
    0E8B: 52 FB    MOV   A,[X-5]
    0E8D: 08       PUSH  A
    0E8E: 7C 11 CE LCALL _atoi
    0E91: 38 FE    ADD   SP,0xFE
    0E93: 10       PUSH  X
    0E94: 62 D0 00 MOV   REG[0xD0],0x0
    0E97: 51 1A    MOV   A,[__r0]
    0E99: 08       PUSH  A
    0E9A: 51 19    MOV   A,[__r1]
    0E9C: 20       POP   X
    0E9D: 7C 07 D5 LCALL _UART_PutSHexInt
(0322) 				UART_PutCRLF();
    0EA0: 7C 08 91 LCALL _UART_PutCRLF
    0EA3: 20       POP   X
(0323) 			}
(0324) 			
(0325) 			if ((Servo1_CONTROL_LSB_REG & Servo1_CONTROL_REG_START_BIT) == 0x00) //servo has not been started
    0EA4: 5D 4B    MOV   A,REG[0x4B]
    0EA6: 62 D0 00 MOV   REG[0xD0],0x0
    0EA9: 53 1A    MOV   [__r0],A
    0EAB: 47 1A 01 TST   [__r0],0x1
    0EAE: B0 06    JNZ   0x0EB5
(0326) 				Servo1_Start();
    0EB0: 10       PUSH  X
    0EB1: 7C 09 3B LCALL _Servo1_Start
    0EB4: 20       POP   X
(0327) 			
(0328) 			Servo1_WritePulseWidth(atoi(param));
    0EB5: 52 FA    MOV   A,[X-6]
    0EB7: 08       PUSH  A
    0EB8: 52 FB    MOV   A,[X-5]
    0EBA: 08       PUSH  A
    0EBB: 7C 11 CE LCALL _atoi
    0EBE: 38 FE    ADD   SP,0xFE
    0EC0: 10       PUSH  X
    0EC1: 62 D0 00 MOV   REG[0xD0],0x0
    0EC4: 51 1A    MOV   A,[__r0]
    0EC6: 08       PUSH  A
    0EC7: 51 19    MOV   A,[__r1]
    0EC9: 20       POP   X
    0ECA: 7C 09 49 LCALL _Servo1_WritePulseWidth
    0ECD: 20       POP   X
(0329) 			break;
    0ECE: 82 0F    JMP   0x10DE
(0330) 		case 'f': //SRV0_STP
(0331) 			if (debug)
    0ED0: 62 D0 00 MOV   REG[0xD0],0x0
    0ED3: 3C 28 00 CMP   [debug],0x0
    0ED6: A0 13    JZ    0x0EEA
(0332) 			{
(0333) 				UART_PutCRLF();
    0ED8: 10       PUSH  X
    0ED9: 7C 08 91 LCALL _UART_PutCRLF
(0334) 				UART_CPutString("Stopping PWM for servo 0.");
    0EDC: 50 02    MOV   A,0x2
    0EDE: 08       PUSH  A
    0EDF: 50 91    MOV   A,0x91
    0EE1: 5C       MOV   X,A
    0EE2: 18       POP   A
    0EE3: 7C 08 7F LCALL _UART_CPutString
(0335) 				UART_PutCRLF();
    0EE6: 7C 08 91 LCALL _UART_PutCRLF
    0EE9: 20       POP   X
(0336) 			}
(0337) 			
(0338) 			Servo0_Stop();;
    0EEA: 10       PUSH  X
    0EEB: 7C 09 9C LCALL _Servo0_Stop
    0EEE: 20       POP   X
(0339) 			break;
    0EEF: 81 EE    JMP   0x10DE
(0340) 		case 'g': //SRV1_STP
(0341) 			if (debug)
    0EF1: 62 D0 00 MOV   REG[0xD0],0x0
    0EF4: 3C 28 00 CMP   [debug],0x0
    0EF7: A0 13    JZ    0x0F0B
(0342) 			{
(0343) 				UART_PutCRLF();
    0EF9: 10       PUSH  X
    0EFA: 7C 08 91 LCALL _UART_PutCRLF
(0344) 				UART_CPutString("Stopping PWM for servo 1.");
    0EFD: 50 02    MOV   A,0x2
    0EFF: 08       PUSH  A
    0F00: 50 77    MOV   A,0x77
    0F02: 5C       MOV   X,A
    0F03: 18       POP   A
    0F04: 7C 08 7F LCALL _UART_CPutString
(0345) 				UART_PutCRLF();
    0F07: 7C 08 91 LCALL _UART_PutCRLF
    0F0A: 20       POP   X
(0346) 			}
(0347) 			
(0348) 			Servo1_Stop();
    0F0B: 10       PUSH  X
    0F0C: 7C 09 3F LCALL _Servo1_Stop
    0F0F: 20       POP   X
(0349) 			break;
    0F10: 81 CD    JMP   0x10DE
(0350) 		case 'h': //GETC1
(0351) 			if (debug)
    0F12: 62 D0 00 MOV   REG[0xD0],0x0
    0F15: 3C 28 00 CMP   [debug],0x0
    0F18: A0 10    JZ    0x0F29
(0352) 			{
(0353) 				UART_PutCRLF();
    0F1A: 10       PUSH  X
    0F1B: 7C 08 91 LCALL _UART_PutCRLF
(0354) 				UART_CPutString("Encoder 1 count: ");
    0F1E: 50 02    MOV   A,0x2
    0F20: 08       PUSH  A
    0F21: 50 65    MOV   A,0x65
    0F23: 5C       MOV   X,A
    0F24: 18       POP   A
    0F25: 7C 08 7F LCALL _UART_CPutString
    0F28: 20       POP   X
(0355) 			}
(0356) 			
(0357) 			UART_PutSHexInt(count1);
    0F29: 62 D0 00 MOV   REG[0xD0],0x0
    0F2C: 51 1E    MOV   A,[count1+3]
    0F2E: 62 D0 00 MOV   REG[0xD0],0x0
    0F31: 53 19    MOV   [__r1],A
    0F33: 62 D0 00 MOV   REG[0xD0],0x0
    0F36: 51 1D    MOV   A,[count1+2]
    0F38: 62 D0 00 MOV   REG[0xD0],0x0
    0F3B: 10       PUSH  X
    0F3C: 08       PUSH  A
    0F3D: 51 19    MOV   A,[__r1]
    0F3F: 20       POP   X
    0F40: 7C 07 D5 LCALL _UART_PutSHexInt
    0F43: 20       POP   X
(0358) 			
(0359) 			if (debug)
    0F44: 62 D0 00 MOV   REG[0xD0],0x0
    0F47: 3C 28 00 CMP   [debug],0x0
    0F4A: A1 93    JZ    0x10DE
(0360) 				UART_PutCRLF();
    0F4C: 10       PUSH  X
    0F4D: 7C 08 91 LCALL _UART_PutCRLF
    0F50: 20       POP   X
(0361) 			break;
    0F51: 81 8C    JMP   0x10DE
(0362) 		case 'i': //GETC2
(0363) 			if (debug)
    0F53: 62 D0 00 MOV   REG[0xD0],0x0
    0F56: 3C 28 00 CMP   [debug],0x0
    0F59: A0 10    JZ    0x0F6A
(0364) 			{
(0365) 				UART_PutCRLF();
    0F5B: 10       PUSH  X
    0F5C: 7C 08 91 LCALL _UART_PutCRLF
(0366) 				UART_CPutString("Encoder 2 count: ");
    0F5F: 50 02    MOV   A,0x2
    0F61: 08       PUSH  A
    0F62: 50 53    MOV   A,0x53
    0F64: 5C       MOV   X,A
    0F65: 18       POP   A
    0F66: 7C 08 7F LCALL _UART_CPutString
    0F69: 20       POP   X
(0367) 			}
(0368) 			UART_PutSHexInt(count2);
    0F6A: 62 D0 00 MOV   REG[0xD0],0x0
    0F6D: 51 22    MOV   A,[count2+3]
    0F6F: 62 D0 00 MOV   REG[0xD0],0x0
    0F72: 53 19    MOV   [__r1],A
    0F74: 62 D0 00 MOV   REG[0xD0],0x0
    0F77: 51 21    MOV   A,[count2+2]
    0F79: 62 D0 00 MOV   REG[0xD0],0x0
    0F7C: 10       PUSH  X
    0F7D: 08       PUSH  A
    0F7E: 51 19    MOV   A,[__r1]
    0F80: 20       POP   X
    0F81: 7C 07 D5 LCALL _UART_PutSHexInt
    0F84: 20       POP   X
(0369) 			
(0370) 			if(debug)
    0F85: 62 D0 00 MOV   REG[0xD0],0x0
    0F88: 3C 28 00 CMP   [debug],0x0
    0F8B: A1 52    JZ    0x10DE
(0371) 				UART_PutCRLF();
    0F8D: 10       PUSH  X
    0F8E: 7C 08 91 LCALL _UART_PutCRLF
    0F91: 20       POP   X
(0372) 			break;
    0F92: 81 4B    JMP   0x10DE
(0373) 		case 'j': //RSTC1
(0374) 			if(debug)
    0F94: 62 D0 00 MOV   REG[0xD0],0x0
    0F97: 3C 28 00 CMP   [debug],0x0
    0F9A: A0 13    JZ    0x0FAE
(0375) 			{
(0376) 				UART_PutCRLF();
    0F9C: 10       PUSH  X
    0F9D: 7C 08 91 LCALL _UART_PutCRLF
(0377) 				UART_CPutString("Resetting count1");
    0FA0: 50 02    MOV   A,0x2
    0FA2: 08       PUSH  A
    0FA3: 50 42    MOV   A,0x42
    0FA5: 5C       MOV   X,A
    0FA6: 18       POP   A
    0FA7: 7C 08 7F LCALL _UART_CPutString
(0378) 				UART_PutCRLF();
    0FAA: 7C 08 91 LCALL _UART_PutCRLF
    0FAD: 20       POP   X
(0379) 			}
(0380) 			
(0381) 			count1 = 0;
    0FAE: 62 D0 00 MOV   REG[0xD0],0x0
    0FB1: 55 1B 00 MOV   [count1],0x0
    0FB4: 55 1C 00 MOV   [count1+1],0x0
    0FB7: 55 1D 00 MOV   [count1+2],0x0
    0FBA: 55 1E 00 MOV   [count1+3],0x0
(0382) 			break;
    0FBD: 81 20    JMP   0x10DE
(0383) 		case 'k': //RSTC2
(0384) 			if(debug)
    0FBF: 62 D0 00 MOV   REG[0xD0],0x0
    0FC2: 3C 28 00 CMP   [debug],0x0
    0FC5: A0 13    JZ    0x0FD9
(0385) 			{
(0386) 				UART_PutCRLF();
    0FC7: 10       PUSH  X
    0FC8: 7C 08 91 LCALL _UART_PutCRLF
(0387) 				UART_CPutString("Resetting count2");
    0FCB: 50 02    MOV   A,0x2
    0FCD: 08       PUSH  A
    0FCE: 50 31    MOV   A,0x31
    0FD0: 5C       MOV   X,A
    0FD1: 18       POP   A
    0FD2: 7C 08 7F LCALL _UART_CPutString
(0388) 				UART_PutCRLF();
    0FD5: 7C 08 91 LCALL _UART_PutCRLF
    0FD8: 20       POP   X
(0389) 			}
(0390) 			
(0391) 			count2 = 0;
    0FD9: 62 D0 00 MOV   REG[0xD0],0x0
    0FDC: 55 1F 00 MOV   [count2],0x0
    0FDF: 55 20 00 MOV   [count2+1],0x0
    0FE2: 55 21 00 MOV   [count2+2],0x0
    0FE5: 55 22 00 MOV   [count2+3],0x0
(0392) 			break;
    0FE8: 80 F5    JMP   0x10DE
(0393) 		case 'l': //STOP
(0394) 			if(debug)
    0FEA: 62 D0 00 MOV   REG[0xD0],0x0
    0FED: 3C 28 00 CMP   [debug],0x0
    0FF0: A0 13    JZ    0x1004
(0395) 			{
(0396) 				UART_PutCRLF();
    0FF2: 10       PUSH  X
    0FF3: 7C 08 91 LCALL _UART_PutCRLF
(0397) 				UART_CPutString("Stopping motors");
    0FF6: 50 02    MOV   A,0x2
    0FF8: 08       PUSH  A
    0FF9: 50 21    MOV   A,0x21
    0FFB: 5C       MOV   X,A
    0FFC: 18       POP   A
    0FFD: 7C 08 7F LCALL _UART_CPutString
(0398) 				UART_PutCRLF();
    1000: 7C 08 91 LCALL _UART_PutCRLF
    1003: 20       POP   X
(0399) 			}
(0400) 			
(0401) 			PWMA_WritePulseWidth(0);
    1004: 10       PUSH  X
    1005: 50 00    MOV   A,0x0
    1007: 7C 0A 47 LCALL _PWMA_WritePulseWidth
(0402) 			PWMB_WritePulseWidth(0);
    100A: 50 00    MOV   A,0x0
    100C: 7C 0A 00 LCALL _PWMB_WritePulseWidth
(0403) 			PWMA_Stop();
    100F: 7C 0A 40 LCALL _PWMA_Stop
(0404) 			PWMB_Stop();
    1012: 7C 09 F9 LCALL _PWMB_Stop
    1015: 20       POP   X
(0405) 			break;
    1016: 80 C7    JMP   0x10DE
(0406) 		case 'm': //FORWARD
(0407) 			if (debug)
    1018: 62 D0 00 MOV   REG[0xD0],0x0
    101B: 3C 28 00 CMP   [debug],0x0
    101E: A0 13    JZ    0x1032
(0408) 			{
(0409) 				UART_PutCRLF();
    1020: 10       PUSH  X
    1021: 7C 08 91 LCALL _UART_PutCRLF
(0410) 				UART_CPutString("Setting drive mode to forward.");
    1024: 50 02    MOV   A,0x2
    1026: 08       PUSH  A
    1027: 50 02    MOV   A,0x2
    1029: 5C       MOV   X,A
    102A: 18       POP   A
    102B: 7C 08 7F LCALL _UART_CPutString
(0411) 				UART_PutCRLF();
    102E: 7C 08 91 LCALL _UART_PutCRLF
    1031: 20       POP   X
(0412) 			}
(0413) 			
(0414) 			AIN1_Data_ADDR |= AIN1_MASK;
    1032: 43 04 10 OR    REG[0x4],0x10
(0415) 			AIN2_Data_ADDR |= AIN2_MASK;
    1035: 43 04 40 OR    REG[0x4],0x40
(0416) 			BIN1_Data_ADDR &= ~BIN1_MASK;
    1038: 41 08 FD AND   REG[0x8],0xFD
(0417) 			BIN2_Data_ADDR &= ~BIN2_MASK;
    103B: 41 04 7F AND   REG[0x4],0x7F
(0418) 			break;
    103E: 80 9F    JMP   0x10DE
(0419) 		case 'n': //BACKWARD
(0420) 			if (debug)
    1040: 62 D0 00 MOV   REG[0xD0],0x0
    1043: 3C 28 00 CMP   [debug],0x0
    1046: A0 13    JZ    0x105A
(0421) 			{
(0422) 				UART_PutCRLF();
    1048: 10       PUSH  X
    1049: 7C 08 91 LCALL _UART_PutCRLF
(0423) 				UART_CPutString("Setting drive mode to backward.");
    104C: 50 01    MOV   A,0x1
    104E: 08       PUSH  A
    104F: 50 E2    MOV   A,0xE2
    1051: 5C       MOV   X,A
    1052: 18       POP   A
    1053: 7C 08 7F LCALL _UART_CPutString
(0424) 				UART_PutCRLF();
    1056: 7C 08 91 LCALL _UART_PutCRLF
    1059: 20       POP   X
(0425) 			}
(0426) 			
(0427) 			AIN1_Data_ADDR &= ~AIN1_MASK;
    105A: 41 04 EF AND   REG[0x4],0xEF
(0428) 			AIN2_Data_ADDR &= ~AIN2_MASK;
    105D: 41 04 BF AND   REG[0x4],0xBF
(0429) 			BIN1_Data_ADDR |= BIN1_MASK;
    1060: 43 08 02 OR    REG[0x8],0x2
(0430) 			BIN2_Data_ADDR |= BIN2_MASK;
    1063: 43 04 80 OR    REG[0x4],0x80
(0431) 			break;
    1066: 80 77    JMP   0x10DE
(0432) 		case 'o': //TURNL
(0433) 			if (debug)
    1068: 62 D0 00 MOV   REG[0xD0],0x0
    106B: 3C 28 00 CMP   [debug],0x0
    106E: A0 13    JZ    0x1082
(0434) 			{
(0435) 				UART_PutCRLF();
    1070: 10       PUSH  X
    1071: 7C 08 91 LCALL _UART_PutCRLF
(0436) 				UART_CPutString("Setting drive mode to left.");
    1074: 50 01    MOV   A,0x1
    1076: 08       PUSH  A
    1077: 50 C6    MOV   A,0xC6
    1079: 5C       MOV   X,A
    107A: 18       POP   A
    107B: 7C 08 7F LCALL _UART_CPutString
(0437) 				UART_PutCRLF();
    107E: 7C 08 91 LCALL _UART_PutCRLF
    1081: 20       POP   X
(0438) 			}
(0439) 			
(0440) 			AIN1_Data_ADDR |= AIN1_MASK;
    1082: 43 04 10 OR    REG[0x4],0x10
(0441) 			AIN2_Data_ADDR &= ~AIN2_MASK;
    1085: 41 04 BF AND   REG[0x4],0xBF
(0442) 			BIN1_Data_ADDR &= ~BIN1_MASK;
    1088: 41 08 FD AND   REG[0x8],0xFD
(0443) 			BIN2_Data_ADDR |= BIN2_MASK;
    108B: 43 04 80 OR    REG[0x4],0x80
(0444) 			break;
    108E: 80 4F    JMP   0x10DE
(0445) 		case 'p': //TURNR
(0446) 			if (debug)
    1090: 62 D0 00 MOV   REG[0xD0],0x0
    1093: 3C 28 00 CMP   [debug],0x0
    1096: A0 13    JZ    0x10AA
(0447) 			{
(0448) 				UART_PutCRLF();
    1098: 10       PUSH  X
    1099: 7C 08 91 LCALL _UART_PutCRLF
(0449) 				UART_CPutString("Setting drive mode to right.");
    109C: 50 01    MOV   A,0x1
    109E: 08       PUSH  A
    109F: 50 A9    MOV   A,0xA9
    10A1: 5C       MOV   X,A
    10A2: 18       POP   A
    10A3: 7C 08 7F LCALL _UART_CPutString
(0450) 				UART_PutCRLF();
    10A6: 7C 08 91 LCALL _UART_PutCRLF
    10A9: 20       POP   X
(0451) 			}
(0452) 			
(0453) 			AIN1_Data_ADDR &= ~AIN1_MASK;
    10AA: 41 04 EF AND   REG[0x4],0xEF
(0454) 			AIN2_Data_ADDR |= AIN2_MASK;
    10AD: 43 04 40 OR    REG[0x4],0x40
(0455) 			BIN1_Data_ADDR |= BIN1_MASK;
    10B0: 43 08 02 OR    REG[0x8],0x2
(0456) 			BIN2_Data_ADDR &= ~BIN2_MASK;
    10B3: 41 04 7F AND   REG[0x4],0x7F
(0457) 			break;
    10B6: 80 27    JMP   0x10DE
(0458) 		default : //ERROR
(0459) 			if (debug)
    10B8: 62 D0 00 MOV   REG[0xD0],0x0
    10BB: 3C 28 00 CMP   [debug],0x0
    10BE: A0 06    JZ    0x10C5
(0460) 				UART_PutCRLF();
    10C0: 10       PUSH  X
    10C1: 7C 08 91 LCALL _UART_PutCRLF
    10C4: 20       POP   X
(0461) 			
(0462) 			UART_CPutString("fu1337"); //error code
    10C5: 10       PUSH  X
    10C6: 50 01    MOV   A,0x1
    10C8: 08       PUSH  A
    10C9: 50 A2    MOV   A,0xA2
    10CB: 5C       MOV   X,A
    10CC: 18       POP   A
    10CD: 7C 08 7F LCALL _UART_CPutString
    10D0: 20       POP   X
(0463) 			
(0464) 			if (debug)
    10D1: 62 D0 00 MOV   REG[0xD0],0x0
    10D4: 3C 28 00 CMP   [debug],0x0
    10D7: A0 06    JZ    0x10DE
(0465) 				UART_PutCRLF();
    10D9: 10       PUSH  X
    10DA: 7C 08 91 LCALL _UART_PutCRLF
    10DD: 20       POP   X
(0466) 			break;
    10DE: 38 FE    ADD   SP,0xFE
    10E0: 20       POP   X
    10E1: 7F       RET   
(0467) 	}
(0468) }
(0469) 
(0470) //Encoder 1 interrupts are generated by the falling edge and positive edge paramers.
(0471) void encoder1_ISR(void)
(0472) {
_encoder1_ISR:
    10E2: 71 C0    OR    F,0xC0
    10E4: 08       PUSH  A
    10E5: 5D D0    MOV   A,REG[0xD0]
    10E7: 08       PUSH  A
(0473) 	//grab the new state of the encoder register.
(0474) 	curPrt1 = (ENC1A_Data_ADDR & (ENC1A_MASK | ENC1B_MASK));
    10E8: 5D 08    MOV   A,REG[0x8]
    10EA: 21 50    AND   A,0x50
    10EC: 62 D0 00 MOV   REG[0xD0],0x0
    10EF: 53 25    MOV   [curPrt1],A
(0475) 		
(0476) 	//check which state transitioned.
(0477) 	if ((prevPrt1 == 0x00) && (curPrt1 == stateA1)) //A low to high
    10F1: 62 D0 00 MOV   REG[0xD0],0x0
    10F4: 3C 2B 00 CMP   [prevPrt1],0x0
    10F7: B0 1A    JNZ   0x1112
    10F9: 62 D0 00 MOV   REG[0xD0],0x0
    10FC: 3C 25 20 CMP   [curPrt1],0x20
    10FF: B0 12    JNZ   0x1112
(0478) 	{
(0479) 		count1++;
    1101: 62 D0 00 MOV   REG[0xD0],0x0
    1104: 06 1E 01 ADD   [count1+3],0x1
    1107: 0E 1D 00 ADC   [count1+2],0x0
    110A: 0E 1C 00 ADC   [count1+1],0x0
    110D: 0E 1B 00 ADC   [count1],0x0
(0480) 	}
    1110: 80 20    JMP   0x1131
(0481) 	else if ((prevPrt1 == 0x00) && (curPrt1 == stateB1)) //B low to high
    1112: 62 D0 00 MOV   REG[0xD0],0x0
    1115: 3C 2B 00 CMP   [prevPrt1],0x0
    1118: B0 18    JNZ   0x1131
    111A: 62 D0 00 MOV   REG[0xD0],0x0
    111D: 3C 25 08 CMP   [curPrt1],0x8
    1120: B0 10    JNZ   0x1131
(0482) 	{
(0483) 		count1--;
    1122: 62 D0 00 MOV   REG[0xD0],0x0
    1125: 16 1E 01 SUB   [count1+3],0x1
    1128: 1E 1D 00 SBB   [count1+2],0x0
    112B: 1E 1C 00 SBB   [count1+1],0x0
    112E: 1E 1B 00 SBB   [count1],0x0
(0484) 	}
    1131: 18       POP   A
    1132: 60 D0    MOV   REG[0xD0],A
    1134: 18       POP   A
    1135: 7E       RETI  
(0485) }
(0486) 
(0487) //Encoder 2 interrupts are generated directly by the GPIO interrupt. Logically equivalent
(0488) //to the encoder1_ISR
(0489) void encoder2_ISR(void)
(0490) {
_encoder2_ISR:
    1136: 71 C0    OR    F,0xC0
    1138: 08       PUSH  A
    1139: 5D D0    MOV   A,REG[0xD0]
    113B: 08       PUSH  A
(0491) 	curPrt2 = (ENC2A_Data_ADDR & (ENC2A_MASK | ENC2B_MASK));	
    113C: 5D 08    MOV   A,REG[0x8]
    113E: 21 28    AND   A,0x28
    1140: 62 D0 00 MOV   REG[0xD0],0x0
    1143: 53 2A    MOV   [curPrt2],A
(0492) 		
(0493) 	if ((prevPrt2 == 0x00) && (curPrt2 == stateA2))	
    1145: 62 D0 00 MOV   REG[0xD0],0x0
    1148: 3C 29 00 CMP   [prevPrt2],0x0
    114B: B0 1A    JNZ   0x1166
    114D: 62 D0 00 MOV   REG[0xD0],0x0
    1150: 3C 2A 10 CMP   [curPrt2],0x10
    1153: B0 12    JNZ   0x1166
(0494) 	{
(0495) 		count2++;
    1155: 62 D0 00 MOV   REG[0xD0],0x0
    1158: 06 22 01 ADD   [count2+3],0x1
    115B: 0E 21 00 ADC   [count2+2],0x0
    115E: 0E 20 00 ADC   [count2+1],0x0
    1161: 0E 1F 00 ADC   [count2],0x0
(0496) 	}
    1164: 80 20    JMP   0x1185
(0497) 	else if ((prevPrt2 == 0x00) && (curPrt2 == stateB2))
    1166: 62 D0 00 MOV   REG[0xD0],0x0
    1169: 3C 29 00 CMP   [prevPrt2],0x0
    116C: B0 18    JNZ   0x1185
    116E: 62 D0 00 MOV   REG[0xD0],0x0
    1171: 3C 2A 04 CMP   [curPrt2],0x4
    1174: B0 10    JNZ   0x1185
(0498) 	{
(0499) 		count2--;
    1176: 62 D0 00 MOV   REG[0xD0],0x0
    1179: 16 22 01 SUB   [count2+3],0x1
    117C: 1E 21 00 SBB   [count2+2],0x0
    117F: 1E 20 00 SBB   [count2+1],0x0
    1182: 1E 1F 00 SBB   [count2],0x0
(0500) 	}
    1185: 18       POP   A
    1186: 60 D0    MOV   REG[0xD0],A
    1188: 18       POP   A
    1189: 7E       RETI  
