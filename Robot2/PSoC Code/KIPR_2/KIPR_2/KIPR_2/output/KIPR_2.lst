FILE: .\boot.asm                        (0001) ;  Generated by PSoC Designer 5.4.2946
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#903 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.30
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY8C29xxx microcontroller family.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; The following equate is required for proper operation. Reseting its value
                                        (0068) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                        (0069) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                        (0070) ; and PLL_Lock must take place within user code. See the family data sheet for
                                        (0071) ; the requirements of starting the ECO and PLL lock mode.
                                        (0072) ;
                                        (0073) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                        (0074) ;                invoking main
                                        (0075) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
                                        (0076) ;               the time code in main starts executing.
                                        (0077) ;
                                        (0078) WAIT_FOR_32K:                    equ 1
                                        (0079) 
                                        (0080) 
                                        (0081) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0082) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0083) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0084) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0085) ; bytes on the stack which are otherwise required for the return address. If
                                        (0086) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0087) ; release, the C compiler automatically places an infinite loop at the end
                                        (0088) ; of main, rather than a return instruction.)
                                        (0089) ;
                                        (0090) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0091) 
                                        (0092) 
                                        (0093) ;-----------------------------------------------------------------------------
                                        (0094) ; Interrupt Vector Table
                                        (0095) ;-----------------------------------------------------------------------------
                                        (0096) ;
                                        (0097) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0098) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0099) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0100) ; vector jump targets are modified automatically according to the user
                                        (0101) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0102) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0103) ; configuration files. If you need to hard code a vector, update the
                                        (0104) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0105) ; of this file.
                                        (0106) ;-----------------------------------------------------------------------------
                                        (0107) 
                                        (0108)     AREA TOP (ROM, ABS, CON)
                                        (0109) 
                                        (0110)     org   0                        ;Reset Interrupt Vector
                                        (0111) IF	(TOOLCHAIN & HITECH)
                                        (0112) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0113) ELSE
0000: 80 67    JMP   0x0068             (0114)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0115) ENDIF
                                        (0116)     ;@PSoC_BOOT_ISR_UserCode_START@
                                        (0117)     ;---------------------------------------------------
                                        (0118)     ; Insert your custom code below this banner
                                        (0119)     ;---------------------------------------------------
                                        (0120) 
                                        (0121)     org   04h                      ;Low Voltage Detect (LVD) Interrupt Vector
0004: 30       HALT                     (0122)     halt                           ;Stop execution if power falls too low
                                        (0123) 
                                        (0124)     org   08h                      ;Analog Column 0 Interrupt Vector
                                        (0125)     // call	void_handler
0008: 7E       RETI                     (0126)     reti
                                        (0127) 
                                        (0128)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                        (0129)     // call	void_handler
000C: 7E       RETI                     (0130)     reti
                                        (0131) 
                                        (0132)     org   10h                      ;Analog Column 2 Interrupt Vector
                                        (0133)     // call	void_handler
0010: 7E       RETI                     (0134)     reti
                                        (0135) 
                                        (0136)     org   14h                      ;Analog Column 3 Interrupt Vector
                                        (0137)     // call	void_handler
0014: 7E       RETI                     (0138)     reti
                                        (0139) 
                                        (0140)     org   18h                      ;VC3 Interrupt Vector
                                        (0141)     // call	void_handler
0018: 7E       RETI                     (0142)     reti
                                        (0143) 
                                        (0144)     org   1Ch                      ;GPIO Interrupt Vector
001C: 7D 15 7B LJMP  _encoder2_ISR      (0145)     ljmp _encoder2_ISR
001F: 7E       RETI                     (0146)     reti
                                        (0147) 
                                        (0148)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
0020: 7D 15 27 LJMP  _encoder1_ISR      (0149)     ljmp _encoder1_ISR
0023: 7E       RETI                     (0150)     reti
                                        (0151) 
                                        (0152)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                        (0153)     // call	void_handler
0024: 7E       RETI                     (0154)     reti
                                        (0155) 
                                        (0156)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
0028: 7D 0A 81 LJMP  _Servo0_ISR        (0157)     ljmp	_Servo0_ISR
002B: 7E       RETI                     (0158)     reti
                                        (0159) 
                                        (0160)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
002C: 7D 0B 25 LJMP  _PWMA_ISR          (0161)     ljmp	_PWMA_ISR
002F: 7E       RETI                     (0162)     reti
                                        (0163) 
                                        (0164)     org   30h                      ;PSoC Block DBB10 Interrupt Vector
0030: 7D 15 27 LJMP  _encoder1_ISR      (0165)     ljmp _encoder1_ISR
0033: 7E       RETI                     (0166)     reti
                                        (0167) 
                                        (0168)     org   34h                      ;PSoC Block DBB11 Interrupt Vector
0034: 7D 15 27 LJMP  _encoder1_ISR      (0169)     ljmp _encoder1_ISR
0037: 7E       RETI                     (0170)     reti
                                        (0171) 
                                        (0172)     org   38h                      ;PSoC Block DCB12 Interrupt Vector
0038: 7D 07 C5 LJMP  _UART_TX_ISR       (0173)     ljmp	_UART_TX_ISR
003B: 7E       RETI                     (0174)     reti
                                        (0175) 
                                        (0176)     org   3Ch                      ;PSoC Block DCB13 Interrupt Vector
003C: 7D 07 C6 LJMP  _UART_RX_ISR       (0177)     ljmp	_UART_RX_ISR
003F: 7E       RETI                     (0178)     reti
                                        (0179) 
                                        (0180)     org   40h                      ;PSoC Block DBB20 Interrupt Vector
0040: 7D 0A DE LJMP  _PWMB_ISR          (0181)     ljmp	_PWMB_ISR
0043: 7E       RETI                     (0182)     reti
                                        (0183) 
                                        (0184)     org   44h                      ;PSoC Block DBB21 Interrupt Vector
0044: 7D 0B 7C LJMP  _ENC1B_NEDGE_ISR   (0185)     ljmp	_ENC1B_NEDGE_ISR
0047: 7E       RETI                     (0186)     reti
                                        (0187) 
                                        (0188)     org   48h                      ;PSoC Block DCB22 Interrupt Vector
                                        (0189)     // call	void_handler
0048: 7E       RETI                     (0190)     reti
                                        (0191) 
                                        (0192)     org   4Ch                      ;PSoC Block DCB23 Interrupt Vector
004C: 7D 0A 24 LJMP  _Servo1_ISR        (0193)     ljmp	_Servo1_ISR
004F: 7E       RETI                     (0194)     reti
                                        (0195) 
                                        (0196)     org   50h                      ;PSoC Block DBB30 Interrupt Vector
                                        (0197)     // call	void_handler
0050: 7E       RETI                     (0198)     reti
                                        (0199) 
                                        (0200)     org   54h                      ;PSoC Block DBB31 Interrupt Vector
0054: 7D 15 27 LJMP  _encoder1_ISR      (0201)     ljmp _encoder1_ISR
0057: 7E       RETI                     (0202)     reti
                                        (0203) 
                                        (0204)     org   58h                      ;PSoC Block DCB32 Interrupt Vector
                                        (0205)     // call	void_handler
0058: 7E       RETI                     (0206)     reti
                                        (0207) 
                                        (0208)     org   5Ch                      ;PSoC Block DCB33 Interrupt Vector
005C: 7D 07 0B LJMP  _VelTimer_ISR      (0209)     ljmp	_VelTimer_ISR
005F: 7E       RETI                     (0210)     reti
                                        (0211) 
                                        (0212)     org   60h                      ;PSoC I2C Interrupt Vector
                                        (0213)     // call	void_handler
0060: 7E       RETI                     (0214)     reti
                                        (0215) 
                                        (0216)     org   64h                      ;Sleep Timer Interrupt Vector
                                        (0217)     // call	void_handler
0064: 7E       RETI                     (0218)     reti
0068: 71 10    OR    F,0x10             
                                        (0219)     ;---------------------------------------------------
                                        (0220)     ; Insert your custom code above this banner
                                        (0221)     ;---------------------------------------------------
                                        (0222)     ;@PSoC_BOOT_ISR_UserCode_END@
                                        (0223) 
                                        (0224) ;-----------------------------------------------------------------------------
                                        (0225) ;  Start of Execution.
                                        (0226) ;-----------------------------------------------------------------------------
                                        (0227) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0228) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0229) ;
                                        (0230) 
                                        (0231) IF	(TOOLCHAIN & HITECH)
                                        (0232)  	AREA PD_startup(CODE, REL, CON)
                                        (0233) ELSE
                                        (0234)     org 68h
                                        (0235) ENDIF
                                        (0236) __Start:
                                        (0237) 
                                        (0238)     ; initialize SMP values for voltage stabilization, if required,
                                        (0239)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0240)     ; least for now. 
                                        (0241)     ;
                                        (0242)     M8C_SetBank1
006A: 62 FA 00 MOV   REG[0xFA],0x0      (0243)     mov reg[0FAh], 0				;Reset flash location
006D: 62 E3 87 MOV   REG[0xE3],0x87     (0244)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
0070: 70 EF    AND   F,0xEF             
                                        (0245)     M8C_SetBank0
                                        (0246) 
                                        (0247)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
0072: 50 20    MOV   A,0x20             (0248)     mov   A, 20h
0074: 28       ROMX                     (0249)     romx
0075: 50 40    MOV   A,0x40             (0250)     mov   A, 40h
0077: 28       ROMX                     (0251)     romx
0078: 50 60    MOV   A,0x60             (0252)     mov   A, 60h
007A: 28       ROMX                     (0253)     romx
007B: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0254)     ; %45%20%46%46% End workaround
                                        (0255) 
                                        (0256) M8C_ClearWDTAndSleep			   ; Clear WDT before enabling it.
                                        (0257) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0258)     M8C_EnableWatchDog
                                        (0259) ENDIF
                                        (0260) 
                                        (0261) IF ( SELECT_32K )
                                        (0262)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                        (0263) ELSE
007E: 41 FE FB AND   REG[0xFE],0xFB     (0264)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0265) ENDIF
                                        (0266) 
                                        (0267)     ;---------------------------
                                        (0268)     ; Set up the Temporary stack
                                        (0269)     ;---------------------------
                                        (0270)     ; A temporary stack is set up for the SSC instructions.
                                        (0271)     ; The real stack start will be assigned later.
                                        (0272)     ;
                                        (0273) _stack_start:          equ 80h
0081: 50 80    MOV   A,0x80             (0274)     mov   A, _stack_start          ; Set top of stack to end of used RAM
0083: 4E       SWAP  SP,A               (0275)     swap  SP, A                    ; This is only temporary if going to LMM
0084: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0276) 
                                        (0277)     ;-----------------------------------------------
                                        (0278)     ; Set Power-related Trim & the AGND Bypass bit.
                                        (0279)     ;-----------------------------------------------
                                        (0280) M8C_ClearWDTAndSleep ; Clear WDT before enabling it.
                                        (0281) 
                                        (0282) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                        (0283)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0284)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0285)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0286)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0287)   IF ( AGND_BYPASS )
                                        (0288)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0289)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                        (0290)     ; bit in the write-only BDG_TR register. Recalculate the register
                                        (0291)     ; value using the proper trim values.
                                        (0292)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0293)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0294)   ENDIF
                                        (0295)  ENDIF
                                        (0296) ENDIF ; 5.0 V Operation
                                        (0297) 
                                        (0298) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                        (0299)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0300)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0301)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0302)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0303)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0304)  ENDIF
                                        (0305) ENDIF ; 3.3 Volt Operation
                                        (0306) 
0087: 55 F8 00 MOV   [debug+199],0x0    (0307)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
008A: 55 F9 00 MOV   [debug+200],0x0    (0308)     mov  [bSSC_KEYSP], 0
008D: 71 10    OR    F,0x10             
                                        (0309) 
                                        (0310)     ;---------------------------------------
                                        (0311)     ; Initialize Crystal Oscillator and PLL
                                        (0312)     ;---------------------------------------
                                        (0313) 
                                        (0314) IF ( SELECT_32K & WAIT_FOR_32K )
                                        (0315)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                        (0316)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                        (0317)     ; is left off. Set the SleepTimer period is set to 1 sec to time the wait for
                                        (0318)     ; the ECO to stabilize.
                                        (0319)     ;
                                        (0320)     M8C_SetBank1
                                        (0321)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                        (0322)     M8C_SetBank0
                                        (0323)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                        (0324)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                        (0325)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                        (0326) .WaitFor1s:
                                        (0327)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                        (0328)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                        (0329)                                           ;   since interrupts are not globally enabled
                                        (0330) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                        (0331)     ; Either no ECO, or waiting for stable clock is to be done in main
                                        (0332)     M8C_SetBank1
008F: 62 E0 02 MOV   REG[0xE0],0x2      (0333)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
0092: 70 EF    AND   F,0xEF             
0094: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0334)     M8C_SetBank0
                                        (0335)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0336) 
                                        (0337) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                        (0338) 
                                        (0339) IF ( PLL_MODE )
                                        (0340)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
                                        (0341)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
                                        (0342)     ;
                                        (0343)     M8C_SetBank1
                                        (0344)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                        (0345)     M8C_SetBank0
                                        (0346)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                        (0347)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
                                        (0348) 
                                        (0349) .WaitFor16ms:
                                        (0350)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0351)     jz   .WaitFor16ms
                                        (0352)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
                                        (0353)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
                                        (0354)     M8C_SetBank0
                                        (0355) 
                                        (0356) IF      ( WAIT_FOR_32K )
                                        (0357) ELSE ; !( WAIT_FOR_32K )
                                        (0358)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
                                        (0359)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
                                        (0360) ENDIF ;(WAIT_FOR_32K)
                                        (0361) ENDIF ;(PLL_MODE)
                                        (0362) 
                                        (0363) 	;-------------------------------------------------------
                                        (0364)     ; Initialize Proper Drive Mode for External Clock Pin
                                        (0365)     ;-------------------------------------------------------
                                        (0366) 
                                        (0367)     ; Change EXTCLK pin from Hi-Z Analog (110b) drive mode to Hi-Z (010b) drive mode
                                        (0368) 
                                        (0369) IF (SYSCLK_SOURCE)
                                        (0370)     and reg[PRT1DM2],  ~0x10        ; Clear bit 4 of EXTCLK pin's DM2 register 
                                        (0371) ENDIF
                                        (0372)     ; EXTCLK pin is now in proper drive mode to input the external clock signal
                                        (0373) 
                                        (0374)     ;------------------------
                                        (0375)     ; Close CT leakage path.
                                        (0376)     ;------------------------
0097: 62 71 05 MOV   REG[0x71],0x5      (0377)     mov   reg[ACB00CR0], 05h
009A: 62 75 05 MOV   REG[0x75],0x5      (0378)     mov   reg[ACB01CR0], 05h
009D: 62 79 05 MOV   REG[0x79],0x5      (0379)     mov   reg[ACB02CR0], 05h
00A0: 62 7D 05 MOV   REG[0x7D],0x5      (0380)     mov   reg[ACB03CR0], 05h
00A3: 62 D1 07 MOV   REG[0xD1],0x7      
                                        (0381) 
                                        (0382) 
                                        (0383) IF	(TOOLCHAIN & HITECH)
                                        (0384)     ;---------------------------------------------
                                        (0385)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                        (0386)     ;---------------------------------------------
                                        (0387) 	global		__Lstackps
                                        (0388) 	mov     a,low __Lstackps
                                        (0389) 	swap    a,sp
                                        (0390) 
                                        (0391) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0392)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0393)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0394)     RAM_SETPAGE_CUR 0
                                        (0395)     RAM_SETPAGE_MVW 0
                                        (0396)     RAM_SETPAGE_MVR 0
                                        (0397)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0398)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0399)     ELSE
                                        (0400)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0401)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0402) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0403) ELSE
                                        (0404)     ;---------------------------------------------
                                        (0405)     ; ImageCraft Enter the Large Memory Model, if applicable
                                        (0406)     ;---------------------------------------------
                                        (0407) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0408)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00A6: 50 00    MOV   A,0x0              (0409)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00A8: 4E       SWAP  SP,A               (0410)     swap  A, SP
00A9: 62 D3 07 MOV   REG[0xD3],0x7      
00AC: 62 D0 00 MOV   REG[0xD0],0x0      
00AF: 62 D5 00 MOV   REG[0xD5],0x0      
00B2: 62 D4 00 MOV   REG[0xD4],0x0      
                                        (0411)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0412)     RAM_SETPAGE_CUR 0
                                        (0413)     RAM_SETPAGE_MVW 0
                                        (0414)     RAM_SETPAGE_MVR 0
                                        (0415) 
                                        (0416)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00B5: 71 C0    OR    F,0xC0             (0417)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0418)   ELSE
                                        (0419)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0420)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0421) ELSE
                                        (0422)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
                                        (0423)     swap  SP, A
                                        (0424) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0425) ENDIF ;	TOOLCHAIN
                                        (0426) 
                                        (0427)     ;@PSoC_BOOT_LOADCFG_UserCode_START@
                                        (0428)     ;---------------------------------------------------
                                        (0429)     ; Insert your custom code below this banner
                                        (0430)     ;---------------------------------------------------
                                        (0431) 
                                        (0432)     ;---------------------------------------------------
                                        (0433)     ; Insert your custom code above this banner
                                        (0434)     ;---------------------------------------------------
                                        (0435)     ;@PSoC_BOOT_LOADCFG_UserCode_END@ 
                                        (0436) 
                                        (0437)     ;-------------------------
                                        (0438)     ; Load Base Configuration
                                        (0439)     ;-------------------------
                                        (0440)     ; Load global parameter settings and load the user modules in the
                                        (0441)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0442)     ; to minimize start up time; (2) We may still need to play with the
                                        (0443)     ; Sleep Timer.
                                        (0444)     ;
00B7: 7C 06 A9 LCALL 0x06A9             (0445)     lcall LoadConfigInit
                                        (0446) 
                                        (0447)     ;-----------------------------------
                                        (0448)     ; Initialize C Run-Time Environment
                                        (0449)     ;-----------------------------------
                                        (0450) IF ( C_LANGUAGE_SUPPORT )
                                        (0451) IF ( SYSTEM_SMALL_MEMORY_MODEL )
                                        (0452)     mov  A,0                           ; clear the 'bss' segment to zero
                                        (0453)     mov  [__r0],<__bss_start
                                        (0454) BssLoop:
                                        (0455)     cmp  [__r0],<__bss_end
                                        (0456)     jz   BssDone
                                        (0457)     mvi  [__r0],A
                                        (0458)     jmp  BssLoop
                                        (0459) BssDone:
                                        (0460)     mov  A,>__idata_start              ; copy idata to data segment
                                        (0461)     mov  X,<__idata_start
                                        (0462)     mov  [__r0],<__data_start
                                        (0463) IDataLoop:
                                        (0464)     cmp  [__r0],<__data_end
                                        (0465)     jz   C_RTE_Done
                                        (0466)     push A
                                        (0467)     romx
                                        (0468)     mvi  [__r0],A
                                        (0469)     pop  A
                                        (0470)     inc  X
                                        (0471)     adc  A,0
                                        (0472)     jmp  IDataLoop
                                        (0473) 
                                        (0474) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                        (0475) 
                                        (0476) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00BA: 62 D0 00 MOV   REG[0xD0],0x0      (0477)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                        (0478)                                        ; to use the Virtual Register page.
                                        (0479) 
                                        (0480)     ; Dereference the constant (flash) pointer pXIData to access the start
                                        (0481)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                        (0482)     ; text segment and may have been relocated by the Code Compressor.
                                        (0483)     ;
00BD: 50 05    MOV   A,0x5              (0484)     mov   A, >__pXIData                ; Get the address of the flash
00BF: 57 82    MOV   X,0x82             (0485)     mov   X, <__pXIData                ;   pointer to the xidata area.
00C1: 08       PUSH  A                  (0486)     push  A
00C2: 28       ROMX                     (0487)     romx                               ; get the MSB of xidata's address
00C3: 53 20    MOV   [__r0],A           (0488)     mov   [__r0], A
00C5: 18       POP   A                  (0489)     pop   A
00C6: 75       INC   X                  (0490)     inc   X
00C7: 09 00    ADC   A,0x0              (0491)     adc   A, 0
00C9: 28       ROMX                     (0492)     romx                               ; get the LSB of xidata's address
00CA: 4B       SWAP  A,X                (0493)     swap  A, X
00CB: 51 20    MOV   A,[__r0]           (0494)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                        (0495)                                        ;   XIData structure list in flash
00CD: 80 04    JMP   0x00D2             (0496)     jmp   .AccessStruct
                                        (0497) 
                                        (0498)     ; Unpack one element in the xidata "structure list" that specifies the
                                        (0499)     ; values of C variables. Each structure contains 3 member elements.
                                        (0500)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                        (0501)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                        (0502)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                        (0503)     ; contains 0xFF. There are two formats for the struct depending on the
                                        (0504)     ; value in the second member element, an unsigned byte:
                                        (0505)     ; (1) If the value of the second element is non-zero, it represents
                                        (0506)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                        (0507)     ; third member of the struct is an array of bytes of length 'size' and
                                        (0508)     ; the bytes are copied to the block of RAM.
                                        (0509)     ; (2) If the value of the second element is zero, the block of RAM is
                                        (0510)     ; to be cleared to zero. In this case, the third member of the struct
                                        (0511)     ; is an unsigned byte containing the number of bytes to clear.
                                        (0512) 
                                        (0513) .AccessNextStructLoop:
00CF: 75       INC   X                  (0514)     inc   X                            ; pXIData++
00D0: 09 00    ADC   A,0x0              (0515)     adc   A, 0
00D2: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0516) .AccessStruct:                         ; Entry point for first block
                                        (0517)     ;
                                        (0518)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                        (0519)     ;
                                        (0520)     M8C_ClearWDT                       ; Clear the watchdog for long inits
00D5: 08       PUSH  A                  (0521)     push  A
00D6: 28       ROMX                     (0522)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
00D7: 60 D5    MOV   REG[0xD5],A        (0523)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
00D9: 74       INC   A                  (0524)     inc   A                            ; End of Struct List? (MSB==0xFF?)
00DA: A0 4B    JZ    0x0126             (0525)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
00DC: 18       POP   A                  (0526)     pop   A                            ; restore pXIData to [A,X]
00DD: 75       INC   X                  (0527)     inc   X                            ; pXIData++
00DE: 09 00    ADC   A,0x0              (0528)     adc   A, 0
00E0: 08       PUSH  A                  (0529)     push  A
00E1: 28       ROMX                     (0530)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
00E2: 53 20    MOV   [__r0],A           (0531)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
00E4: 18       POP   A                  (0532)     pop   A                            ; restore pXIData to [A,X]
00E5: 75       INC   X                  (0533)     inc   X                            ; pXIData++ (point to size)
00E6: 09 00    ADC   A,0x0              (0534)     adc   A, 0
00E8: 08       PUSH  A                  (0535)     push  A
00E9: 28       ROMX                     (0536)     romx                               ; Get the size (CPU.A <- *pXIData)
00EA: A0 1C    JZ    0x0107             (0537)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
00EC: 53 1F    MOV   [__r1],A           (0538)     mov   [__r1], A                    ;             else downcount in __r1
00EE: 18       POP   A                  (0539)     pop   A                            ; restore pXIData to [A,X]
                                        (0540) 
                                        (0541) .CopyNextByteLoop:
                                        (0542)     ; For each byte in the structure's array member, copy from flash to RAM.
                                        (0543)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                        (0544)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                        (0545)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0546)     ;
00EF: 75       INC   X                  (0547)     inc   X                            ; pXIData++ (point to next data byte)
00F0: 09 00    ADC   A,0x0              (0548)     adc   A, 0
00F2: 08       PUSH  A                  (0549)     push  A
00F3: 28       ROMX                     (0550)     romx                               ; Get the data value (CPU.A <- *pXIData)
00F4: 3F 20    MVI   [__r0],A           (0551)     mvi   [__r0], A                    ; Transfer the data to RAM
00F6: 47 20 FF TST   [__r0],0xFF        (0552)     tst   [__r0], 0xff                 ; Check for page crossing
00F9: B0 06    JNZ   0x0100             (0553)     jnz   .CopyLoopTail                ;   No crossing, keep going
00FB: 5D D5    MOV   A,REG[0xD5]        (0554)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
00FD: 74       INC   A                  (0555)     inc   A
00FE: 60 D5    MOV   REG[0xD5],A        (0556)     mov   reg[ MVW_PP], A
                                        (0557) .CopyLoopTail:
0100: 18       POP   A                  (0558)     pop   A                            ; restore pXIData to [A,X]
0101: 7A 1F    DEC   [__r1]             (0559)     dec   [__r1]                       ; End of this array in flash?
0103: BF EB    JNZ   0x00EF             (0560)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
0105: 8F C9    JMP   0x00CF             (0561)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                        (0562) 
                                        (0563) .ClearRAMBlockToZero:
0107: 18       POP   A                  (0564)     pop   A                            ; restore pXIData to [A,X]
0108: 75       INC   X                  (0565)     inc   X                            ; pXIData++ (point to next data byte)
0109: 09 00    ADC   A,0x0              (0566)     adc   A, 0
010B: 08       PUSH  A                  (0567)     push  A
010C: 28       ROMX                     (0568)     romx                               ; Get the run length (CPU.A <- *pXIData)
010D: 53 1F    MOV   [__r1],A           (0569)     mov   [__r1], A                    ; Initialize downcounter
010F: 50 00    MOV   A,0x0              (0570)     mov   A, 0                         ; Initialize source data
                                        (0571) 
                                        (0572) .ClearRAMBlockLoop:
                                        (0573)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                        (0574)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0575)     ;
0111: 3F 20    MVI   [__r0],A           (0576)     mvi   [__r0], A                    ; Clear a byte
0113: 47 20 FF TST   [__r0],0xFF        (0577)     tst   [__r0], 0xff                 ; Check for page crossing
0116: B0 08    JNZ   0x011F             (0578)     jnz   .ClearLoopTail               ;   No crossing, keep going
0118: 5D D5    MOV   A,REG[0xD5]        (0579)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
011A: 74       INC   A                  (0580)     inc   A
011B: 60 D5    MOV   REG[0xD5],A        (0581)     mov   reg[ MVW_PP], A
011D: 50 00    MOV   A,0x0              (0582)     mov   A, 0                         ; Restore the zero used for clearing
                                        (0583) .ClearLoopTail:
011F: 7A 1F    DEC   [__r1]             (0584)     dec   [__r1]                       ; Was this the last byte?
0121: BF EF    JNZ   0x0111             (0585)     jnz   .ClearRAMBlockLoop           ;   No,  continue
0123: 18       POP   A                  (0586)     pop   A                            ;   Yes, restore pXIData to [A,X] and
0124: 8F AA    JMP   0x00CF             (0587)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                        (0588) 
                                        (0589) .C_RTE_WrapUp:
0126: 18       POP   A                  (0590)     pop   A                            ; balance stack
0127: 71 10    OR    F,0x10             
                                        (0591) 
                                        (0592) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                        (0593) 
                                        (0594) C_RTE_Done:
                                        (0595) 
                                        (0596) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0597) 
                                        (0598)     ;-------------------------------
                                        (0599)     ; Voltage Stabilization for SMP
                                        (0600)     ;-------------------------------
                                        (0601) 
                                        (0602) IF ( POWER_SETTING & POWER_SET_5V0)    ; 5.0V Operation
                                        (0603) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
                                        (0604)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0605)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
                                        (0606)     ; 5V before enabling the Precision Power-On Reset (PPOR).
                                        (0607)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0608)     or   reg[INT_MSK0],INT_MSK0_SLEEP
                                        (0609)     M8C_SetBank1
                                        (0610)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
                                        (0611)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
                                        (0612)     M8C_SetBank0
                                        (0613)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
                                        (0614)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
                                        (0615) .WaitFor2ms:
                                        (0616)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0617)     jz   .WaitFor2ms                       ; Branch fails when 2 msec has passed
                                        (0618) ENDIF ; SMP is operational
                                        (0619) ENDIF ; 5.0V Operation
                                        (0620) 
                                        (0621)     ;-------------------------------
                                        (0622)     ; Set Power-On Reset (POR) Level
                                        (0623)     ;-------------------------------
                                        (0624)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH, 
                                        (0625)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper 
                                        (0626)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. 
                                        (0627)     ;  These values should not be changed from the settings here. See Section "POR and LVD" of 
                                        (0628)     ;  Technical Reference Manual #001-14463 for more information.
                                        (0629) 
                                        (0630)     M8C_SetBank1
                                        (0631) 
                                        (0632) IF (POWER_SETTING & POWER_SET_5V0)          ; 5.0V Operation?
                                        (0633)  IF (POWER_SETTING & POWER_SET_SLOW_IMO)    ; and Slow Mode?
                                        (0634)  ELSE                                       ;    No, fast mode
                                        (0635)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz ) ;    As fast as 24MHz?
                                        (0636)                                             ;       no, set midpoint POR in user code, if desired
                                        (0637)   ELSE ; 24HMz                              ;
0129: 43 E3 20 OR    REG[0xE3],0x20     (0638)     or    reg[VLT_CR],  VLT_CR_POR_HIGH     ;      yes, highest POR trip point required
012C: 70 EF    AND   F,0xEF             
                                        (0639)   ENDIF ; 24MHz
                                        (0640)  ENDIF ; Slow Mode
                                        (0641) ENDIF ; 5.0V Operation
                                        (0642) 
                                        (0643)     M8C_SetBank0
                                        (0644) 
                                        (0645)     ;----------------------------
                                        (0646)     ; Wrap up and invoke "main"
                                        (0647)     ;----------------------------
                                        (0648) 
                                        (0649)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0650)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0651)     ;
012E: 62 E0 00 MOV   REG[0xE0],0x0      (0652)     mov  reg[INT_MSK0],0
0131: 71 10    OR    F,0x10             
                                        (0653) 
                                        (0654)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0655)     ; And put decimator in full mode so it does not consume too much current.
                                        (0656)     ;
                                        (0657)     M8C_SetBank1
0133: 62 E0 03 MOV   REG[0xE0],0x3      (0658)     mov  reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
0136: 43 E7 80 OR    REG[0xE7],0x80     (0659)     or   reg[DEC_CR2],80h                    ; Put decimator in full mode
0139: 70 EF    AND   F,0xEF             
                                        (0660)     M8C_SetBank0
                                        (0661) 
                                        (0662)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0663)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0664)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0665)     ;
013B: 62 E2 00 MOV   REG[0xE2],0x0      (0666)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0667)                                    ; have been set during the boot process.
                                        (0668) IF	(TOOLCHAIN & HITECH)
                                        (0669) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0670) ELSE
                                        (0671) IF ENABLE_LJMP_TO_MAIN
                                        (0672)     ljmp  _main                    ; goto main (no return)
                                        (0673) ELSE
013E: 7C 0B FD LCALL __UserModules_end|__text_start|_main|_main(0674)     lcall _main                    ; call main
                                        (0675) .Exit:
0141: 8F FF    JMP   0x0141             (0676)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0677) ENDIF
                                        (0678) ENDIF ; TOOLCHAIN
                                        (0679) 
                                        (0680)     ;---------------------------------
                                        (0681)     ; Library Access to Global Parms
                                        (0682)     ;---------------------------------
                                        (0683)     ;
                                        (0684)  bGetPowerSetting:
                                        (0685) _bGetPowerSetting:
                                        (0686)     ; Returns value of POWER_SETTING in the A register.
                                        (0687)     ; No inputs. No Side Effects.
                                        (0688)     ;
0143: 50 10    MOV   A,0x10             (0689)     mov   A, POWER_SETTING
0145: 7F       RET                      (0690)     ret
                                        (0691) 
                                        (0692) IF	(TOOLCHAIN & HITECH)
                                        (0693) ELSE
                                        (0694)     ;---------------------------------
                                        (0695)     ; Order Critical RAM & ROM AREAs
                                        (0696)     ;---------------------------------
                                        (0697)     ;  'TOP' is all that has been defined so far...
                                        (0698) 
                                        (0699)     ;  ROM AREAs for C CONST, static & global items
                                        (0700)     ;
                                        (0701)     AREA lit               (ROM, REL, CON, LIT)   ; 'const' definitions
                                        (0702)     AREA idata             (ROM, REL, CON, LIT)   ; Constants for initializing RAM
                                        (0703) __idata_start:
                                        (0704) 
                                        (0705)     AREA func_lit          (ROM, REL, CON, proclab)   ; Function Pointers
                                        (0706) __func_lit_start:
                                        (0707) 
                                        (0708) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0709)     ; We use the func_lit area to store a pointer to extended initialized
                                        (0710)     ; data (xidata) area that follows the text area. Func_lit isn't
                                        (0711)     ; relocated by the code compressor, but the text area may shrink and
                                        (0712)     ; that moves xidata around.
                                        (0713)     ;
                                        (0714) __pXIData:         word __text_end           ; ptr to extended idata
                                        (0715) ENDIF
                                        (0716) 
                                        (0717)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
                                        (0718)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
                                        (0719) 
                                        (0720)     ; CODE segment for general use
                                        (0721)     ;
                                        (0722)     AREA text (ROM, REL, CON)
                                        (0723) __text_start:
                                        (0724) 
                                        (0725)     ; RAM area usage
                                        (0726)     ;
                                        (0727)     AREA data              (RAM, REL, CON)   ; initialized RAM
                                        (0728) __data_start:
                                        (0729) 
                                        (0730)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
                                        (0731)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
                                        (0732)     AREA bss               (RAM, REL, CON)   ; general use
                                        (0733) __bss_start:
                                        (0734) 
                                        (0735) ENDIF ; TOOLCHAIN
                                        (0736) 
                                        (0737) ; end of file boot.asm
FILE: lib\psocconfigtbl.asm             (0001) ;  Generated by PSoC Designer 5.4.2946
05A4: 70 EF    AND   F,0xEF             (0002) ;
                                        (0003) ; =============================================================================
                                        (0004) ; FILENAME: PSoCConfigTBL.asm
                                        (0005) ;  
                                        (0006) ; Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0007) ;  
                                        (0008) ; NOTES:
                                        (0009) ; Do not modify this file. It is generated by PSoC Designer each time the
                                        (0010) ; generate application function is run. The values of the parameters in this
                                        (0011) ; file can be modified by changing the values of the global parameters in the
                                        (0012) ; device editor.
                                        (0013) ;  
                                        (0014) ; =============================================================================
                                        (0015)  
                                        (0016) include "m8c.inc"
                                        (0017) ;  Personalization tables 
                                        (0018) export LoadConfigTBL_kipr_2_Bank1
                                        (0019) export LoadConfigTBL_kipr_2_Bank0
                                        (0020) export LoadConfigTBL_kipr_2_Ordered
                                        (0021) AREA lit(rom, rel)
                                        (0022) LoadConfigTBL_kipr_2_Bank0:
                                        (0023) ;  Instance name ENC1A_NEDGE, User Module DigInv
                                        (0024) ;       Instance name ENC1A_NEDGE, Block Name DigInv(DBB10)
                                        (0025) 	db		33h, 00h		;ENC1A_NEDGE_CONTROL_REG(DBB10CR0)
                                        (0026) 	db		31h, 00h		;ENC1A_NEDGE_PERIOD_REG (DBB10DR1)
                                        (0027) 	db		32h, 00h		;ENC1A_NEDGE_COMPARE_REG(DBB10DR2)
                                        (0028) ;  Instance name ENC1A_PEDGE, User Module DigBuf
                                        (0029) ;       Instance name ENC1A_PEDGE, Block Name DigBuf(DBB00)
                                        (0030) 	db		23h, 03h		;ENC1A_PEDGE_CONTROL_REG(DBB00CR0)
                                        (0031) 	db		21h, 00h		;ENC1A_PEDGE_DATA_1_REG(DBB00DR1)
                                        (0032) 	db		22h, 00h		;ENC1A_PEDGE_DATA_2_REG(DBB00DR2)
                                        (0033) ;  Instance name ENC1B_NEDGE, User Module DigInv
                                        (0034) ;       Instance name ENC1B_NEDGE, Block Name DigInv(DBB21)
                                        (0035) 	db		47h, 00h		;ENC1B_NEDGE_CONTROL_REG(DBB21CR0)
                                        (0036) 	db		45h, 00h		;ENC1B_NEDGE_PERIOD_REG (DBB21DR1)
                                        (0037) 	db		46h, 00h		;ENC1B_NEDGE_COMPARE_REG(DBB21DR2)
                                        (0038) ;  Instance name ENC1B_PEDGE, User Module DigBuf
                                        (0039) ;       Instance name ENC1B_PEDGE, Block Name DigBuf(DBB11)
                                        (0040) 	db		37h, 03h		;ENC1B_PEDGE_CONTROL_REG(DBB11CR0)
                                        (0041) 	db		35h, 00h		;ENC1B_PEDGE_DATA_1_REG(DBB11DR1)
                                        (0042) 	db		36h, 00h		;ENC1B_PEDGE_DATA_2_REG(DBB11DR2)
                                        (0043) ;  Instance name PWMA, User Module PWM8
                                        (0044) ;       Instance name PWMA, Block Name PWM8(DCB03)
                                        (0045) 	db		2fh, 00h		;PWMA_CONTROL_REG(DCB03CR0)
                                        (0046) 	db		2dh, ffh		;PWMA_PERIOD_REG(DCB03DR1)
                                        (0047) 	db		2eh, 00h		;PWMA_COMPARE_REG(DCB03DR2)
                                        (0048) ;  Instance name PWMB, User Module PWM8
                                        (0049) ;       Instance name PWMB, Block Name PWM8(DBB20)
                                        (0050) 	db		43h, 00h		;PWMB_CONTROL_REG(DBB20CR0)
                                        (0051) 	db		41h, ffh		;PWMB_PERIOD_REG(DBB20DR1)
                                        (0052) 	db		42h, 00h		;PWMB_COMPARE_REG(DBB20DR2)
                                        (0053) ;  Instance name Servo0, User Module PWM16
                                        (0054) ;       Instance name Servo0, Block Name PWM16_LSB(DBB01)
                                        (0055) 	db		27h, 00h		;Servo0_CONTROL_LSB_REG(DBB01CR0)
                                        (0056) 	db		25h, 1fh		;Servo0_PERIOD_LSB_REG(DBB01DR1)
                                        (0057) 	db		26h, e7h		;Servo0_COMPARE_LSB_REG(DBB01DR2)
                                        (0058) ;       Instance name Servo0, Block Name PWM16_MSB(DCB02)
                                        (0059) 	db		2bh, 00h		;Servo0_CONTROL_MSB_REG(DCB02CR0)
                                        (0060) 	db		29h, 4eh		;Servo0_PERIOD_MSB_REG(DCB02DR1)
                                        (0061) 	db		2ah, 03h		;Servo0_COMPARE_MSB_REG(DCB02DR2)
                                        (0062) ;  Instance name Servo1, User Module PWM16
                                        (0063) ;       Instance name Servo1, Block Name PWM16_LSB(DCB22)
                                        (0064) 	db		4bh, 00h		;Servo1_CONTROL_LSB_REG(DCB22CR0)
                                        (0065) 	db		49h, 1fh		;Servo1_PERIOD_LSB_REG(DCB22DR1)
                                        (0066) 	db		4ah, e7h		;Servo1_COMPARE_LSB_REG(DCB22DR2)
                                        (0067) ;       Instance name Servo1, Block Name PWM16_MSB(DCB23)
                                        (0068) 	db		4fh, 00h		;Servo1_CONTROL_MSB_REG(DCB23CR0)
                                        (0069) 	db		4dh, 4eh		;Servo1_PERIOD_MSB_REG(DCB23DR1)
                                        (0070) 	db		4eh, 03h		;Servo1_COMPARE_MSB_REG(DCB23DR2)
                                        (0071) ;  Instance name UART, User Module UART
                                        (0072) ;       Instance name UART, Block Name RX(DCB13)
                                        (0073) 	db		3fh, 00h		;UART_RX_CONTROL_REG(DCB13CR0)
                                        (0074) 	db		3dh, 00h		;UART_(DCB13DR1)
                                        (0075) 	db		3eh, 00h		;UART_RX_BUFFER_REG (DCB13DR2)
                                        (0076) ;       Instance name UART, Block Name TX(DCB12)
                                        (0077) 	db		3bh, 00h		;UART_TX_CONTROL_REG(DCB12CR0)
                                        (0078) 	db		39h, 00h		;UART_TX_BUFFER_REG (DCB12DR1)
                                        (0079) 	db		3ah, 00h		;UART_(DCB12DR2)
                                        (0080) ;  Instance name VelTimer, User Module Timer32
                                        (0081) ;       Instance name VelTimer, Block Name TIMER32_ISB1(DBB31)
                                        (0082) 	db		57h, 00h		;VelTimer_CONTROL_ISB1_REG(DBB31CR0)
                                        (0083) 	db		55h, ffh		;VelTimer_PERIOD_ISB1_REG(DBB31DR1)
                                        (0084) 	db		56h, 00h		;VelTimer_COMPARE_ISB1_REG(DBB31DR2)
                                        (0085) ;       Instance name VelTimer, Block Name TIMER32_ISB2(DCB32)
                                        (0086) 	db		5bh, 00h		;VelTimer_CONTROL_ISB2_REG(DCB32CR0)
                                        (0087) 	db		59h, ffh		;VelTimer_PERIOD_ISB2_REG(DCB32DR1)
                                        (0088) 	db		5ah, 00h		;VelTimer_COMPARE_ISB2_REG(DCB32DR2)
                                        (0089) ;       Instance name VelTimer, Block Name TIMER32_LSB(DBB30)
                                        (0090) 	db		53h, 00h		;VelTimer_CONTROL_LSB_REG(DBB30CR0)
                                        (0091) 	db		51h, ffh		;VelTimer_PERIOD_LSB_REG(DBB30DR1)
                                        (0092) 	db		52h, 00h		;VelTimer_COMPARE_LSB_REG(DBB30DR2)
                                        (0093) ;       Instance name VelTimer, Block Name TIMER32_MSB(DCB33)
                                        (0094) 	db		5fh, 06h		;VelTimer_CONTROL_MSB_REG(DCB33CR0)
                                        (0095) 	db		5dh, 7fh		;VelTimer_PERIOD_MSB_REG(DCB33DR1)
                                        (0096) 	db		5eh, 00h		;VelTimer_COMPARE_MSB_REG(DCB33DR2)
                                        (0097) ;  Global Register values Bank 0
                                        (0098) 	db		60h, 28h		; AnalogColumnInputSelect register (AMX_IN)
                                        (0099) 	db		66h, 00h		; AnalogComparatorControl1 register (CMP_CR1)
                                        (0100) 	db		63h, 05h		; AnalogReferenceControl register (ARF_CR)
                                        (0101) 	db		65h, 00h		; AnalogSyncControl register (ASY_CR)
                                        (0102) 	db		e6h, 00h		; DecimatorControl_0 register (DEC_CR0)
                                        (0103) 	db		e7h, 00h		; DecimatorControl_1 register (DEC_CR1)
                                        (0104) 	db		d6h, 00h		; I2CConfig register (I2C_CFG)
                                        (0105) 	db		b0h, 10h		; Row_0_InputMux register (RDI0RI)
                                        (0106) 	db		b1h, 00h		; Row_0_InputSync register (RDI0SYN)
                                        (0107) 	db		b2h, 00h		; Row_0_LogicInputAMux register (RDI0IS)
                                        (0108) 	db		b3h, 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
                                        (0109) 	db		b4h, 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
                                        (0110) 	db		b5h, 01h		; Row_0_OutputDrive_0 register (RDI0SRO0)
                                        (0111) 	db		b6h, 10h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                        (0112) 	db		b8h, 55h		; Row_1_InputMux register (RDI1RI)
                                        (0113) 	db		b9h, 00h		; Row_1_InputSync register (RDI1SYN)
                                        (0114) 	db		bah, 10h		; Row_1_LogicInputAMux register (RDI1IS)
                                        (0115) 	db		bbh, 33h		; Row_1_LogicSelect_0 register (RDI1LT0)
                                        (0116) 	db		bch, 33h		; Row_1_LogicSelect_1 register (RDI1LT1)
                                        (0117) 	db		bdh, 10h		; Row_1_OutputDrive_0 register (RDI1SRO0)
                                        (0118) 	db		beh, 00h		; Row_1_OutputDrive_1 register (RDI1SRO1)
                                        (0119) 	db		c0h, 01h		; Row_2_InputMux register (RDI2RI)
                                        (0120) 	db		c1h, 00h		; Row_2_InputSync register (RDI2SYN)
                                        (0121) 	db		c2h, 20h		; Row_2_LogicInputAMux register (RDI2IS)
                                        (0122) 	db		c3h, 33h		; Row_2_LogicSelect_0 register (RDI2LT0)
                                        (0123) 	db		c4h, 33h		; Row_2_LogicSelect_1 register (RDI3LT1)
                                        (0124) 	db		c5h, 80h		; Row_2_OutputDrive_0 register (RDI2SRO0)
                                        (0125) 	db		c6h, 20h		; Row_2_OutputDrive_1 register (RDI2SRO1)
                                        (0126) 	db		c8h, 55h		; Row_3_InputMux register (RDI3RI)
                                        (0127) 	db		c9h, 00h		; Row_3_InputSync register (RDI3SYN)
                                        (0128) 	db		cah, 30h		; Row_3_LogicInputAMux register (RDI3IS)
                                        (0129) 	db		cbh, 33h		; Row_3_LogicSelect_0 register (RDI3LT0)
                                        (0130) 	db		cch, 33h		; Row_3_LogicSelect_1 register (RDI3LT1)
                                        (0131) 	db		cdh, 00h		; Row_3_OutputDrive_0 register (RDI3SRO0)
                                        (0132) 	db		ceh, 00h		; Row_3_OutputDrive_1 register (RDI3SRO1)
                                        (0133) 	db		6ch, 00h		; TMP_DR0 register (TMP_DR0)
                                        (0134) 	db		6dh, 00h		; TMP_DR1 register (TMP_DR1)
                                        (0135) 	db		6eh, 00h		; TMP_DR2 register (TMP_DR2)
                                        (0136) 	db		6fh, 00h		; TMP_DR3 register (TMP_DR3)
                                        (0137) 	db		ffh
                                        (0138) LoadConfigTBL_kipr_2_Bank1:
                                        (0139) ;  Instance name ENC1A_NEDGE, User Module DigInv
                                        (0140) ;       Instance name ENC1A_NEDGE, Block Name DigInv(DBB10)
                                        (0141) 	db		30h, 20h		;ENC1A_NEDGE_FUNC_REG   (DBB10FN)
                                        (0142) 	db		31h, 0eh		;ENC1A_NEDGE_INPUT_REG  (DBB10IN)
                                        (0143) 	db		32h, 40h		;ENC1A_NEDGE_OUTPUT_REG (DBB10OU)
                                        (0144) ;  Instance name ENC1A_PEDGE, User Module DigBuf
                                        (0145) ;       Instance name ENC1A_PEDGE, Block Name DigBuf(DBB00)
                                        (0146) 	db		20h, 22h		;ENC1A_PEDGE_FUNC_REG(DBB00FN)
                                        (0147) 	db		21h, e0h		;ENC1A_PEDGE_INPUT_REG(DBB00IN)
                                        (0148) 	db		22h, 40h		;ENC1A_PEDGE_OUTPUT_REG(DBB00OU)
                                        (0149) ;  Instance name ENC1B_NEDGE, User Module DigInv
                                        (0150) ;       Instance name ENC1B_NEDGE, Block Name DigInv(DBB21)
                                        (0151) 	db		44h, 20h		;ENC1B_NEDGE_FUNC_REG   (DBB21FN)
                                        (0152) 	db		45h, 0ch		;ENC1B_NEDGE_INPUT_REG  (DBB21IN)
                                        (0153) 	db		46h, 40h		;ENC1B_NEDGE_OUTPUT_REG (DBB21OU)
                                        (0154) ;  Instance name ENC1B_PEDGE, User Module DigBuf
                                        (0155) ;       Instance name ENC1B_PEDGE, Block Name DigBuf(DBB11)
                                        (0156) 	db		34h, 22h		;ENC1B_PEDGE_FUNC_REG(DBB11FN)
                                        (0157) 	db		35h, c0h		;ENC1B_PEDGE_INPUT_REG(DBB11IN)
                                        (0158) 	db		36h, 40h		;ENC1B_PEDGE_OUTPUT_REG(DBB11OU)
                                        (0159) ;  Instance name PWMA, User Module PWM8
                                        (0160) ;       Instance name PWMA, Block Name PWM8(DCB03)
                                        (0161) 	db		2ch, 21h		;PWMA_FUNC_REG(DCB03FN)
                                        (0162) 	db		2dh, 16h		;PWMA_INPUT_REG(DCB03IN)
                                        (0163) 	db		2eh, 44h		;PWMA_OUTPUT_REG(DCB03OU)
                                        (0164) ;  Instance name PWMB, User Module PWM8
                                        (0165) ;       Instance name PWMB, Block Name PWM8(DBB20)
                                        (0166) 	db		40h, 21h		;PWMB_FUNC_REG(DBB20FN)
                                        (0167) 	db		41h, 11h		;PWMB_INPUT_REG(DBA20IN)
                                        (0168) 	db		42h, 45h		;PWMB_OUTPUT_REG(DBA20OU)
                                        (0169) ;  Instance name Servo0, User Module PWM16
                                        (0170) ;       Instance name Servo0, Block Name PWM16_LSB(DBB01)
                                        (0171) 	db		24h, 01h		;Servo0_FUNC_LSB_REG(DBB01FN)
                                        (0172) 	db		25h, 16h		;Servo0_INPUT_LSB_REG(DBB01IN)
                                        (0173) 	db		26h, 40h		;Servo0_OUTPUT_LSB_REG(DBB01OU)
                                        (0174) ;       Instance name Servo0, Block Name PWM16_MSB(DCB02)
                                        (0175) 	db		28h, 21h		;Servo0_FUNC_MSB_REG(DCB02FN)
                                        (0176) 	db		29h, 36h		;Servo0_INPUT_MSB_REG(DCB02IN)
                                        (0177) 	db		2ah, 47h		;Servo0_OUTPUT_MSB_REG(DCB02OU)
                                        (0178) ;  Instance name Servo1, User Module PWM16
                                        (0179) ;       Instance name Servo1, Block Name PWM16_LSB(DCB22)
                                        (0180) 	db		48h, 01h		;Servo1_FUNC_LSB_REG(DCB22FN)
                                        (0181) 	db		49h, 16h		;Servo1_INPUT_LSB_REG(DCB22IN)
                                        (0182) 	db		4ah, 40h		;Servo1_OUTPUT_LSB_REG(DCB22OU)
                                        (0183) ;       Instance name Servo1, Block Name PWM16_MSB(DCB23)
                                        (0184) 	db		4ch, 21h		;Servo1_FUNC_MSB_REG(DCB23FN)
                                        (0185) 	db		4dh, 36h		;Servo1_INPUT_MSB_REG(DCB23IN)
                                        (0186) 	db		4eh, 47h		;Servo1_OUTPUT_MSB_REG(DCB23OU)
                                        (0187) ;  Instance name UART, User Module UART
                                        (0188) ;       Instance name UART, Block Name RX(DCB13)
                                        (0189) 	db		3ch, 05h		;UART_RX_FUNC_REG   (DCB13FN)
                                        (0190) 	db		3dh, f1h		;UART_RX_INPUT_REG  (DCB13IN)
                                        (0191) 	db		3eh, 40h		;UART_RX_OUTPUT_REG (DCB13OU)
                                        (0192) ;       Instance name UART, Block Name TX(DCB12)
                                        (0193) 	db		38h, 0dh		;UART_TX_FUNC_REG   (DCB12FN)
                                        (0194) 	db		39h, 01h		;UART_TX_INPUT_REG  (DCB12IN)
                                        (0195) 	db		3ah, 45h		;UART_TX_OUTPUT_REG (DCB12OU)
                                        (0196) ;  Instance name VelTimer, User Module Timer32
                                        (0197) ;       Instance name VelTimer, Block Name TIMER32_ISB1(DBB31)
                                        (0198) 	db		54h, 00h		;VelTimer_FUNC_ISB1_REG(DBB31FN)
                                        (0199) 	db		55h, 34h		;VelTimer_INPUT_ISB1_REG(DBB31IN)
                                        (0200) 	db		56h, 80h		;VelTimer_OUTPUT_ISB1_REG(DBB31OU)
                                        (0201) ;       Instance name VelTimer, Block Name TIMER32_ISB2(DCB32)
                                        (0202) 	db		58h, 00h		;VelTimer_FUNC_ISB2_REG(DCB32FN)
                                        (0203) 	db		59h, 34h		;VelTimer_INPUT_ISB2_REG(DCB32IN)
                                        (0204) 	db		5ah, 80h		;VelTimer_OUTPUT_ISB2_REG(DCB32OU)
                                        (0205) ;       Instance name VelTimer, Block Name TIMER32_LSB(DBB30)
                                        (0206) 	db		50h, 00h		;VelTimer_FUNC_LSB_REG(DBB30FN)
                                        (0207) 	db		51h, 14h		;VelTimer_INPUT_LSB_REG(DBB30IN)
                                        (0208) 	db		52h, 80h		;VelTimer_OUTPUT_LSB_REG(DBB30OU)
                                        (0209) ;       Instance name VelTimer, Block Name TIMER32_MSB(DCB33)
                                        (0210) 	db		5ch, 20h		;VelTimer_FUNC_MSB_REG(DCB33FN)
                                        (0211) 	db		5dh, 34h		;VelTimer_INPUT_MSB_REG(DCB33IN)
                                        (0212) 	db		5eh, 80h		;VelTimer_OUTPUT_MSB_REG(DCB33OU)
                                        (0213) ;  Global Register values Bank 1
                                        (0214) 	db		61h, 00h		; AnalogClockSelect1 register (CLK_CR1)
                                        (0215) 	db		69h, 00h		; AnalogClockSelect2 register (CLK_CR2)
                                        (0216) 	db		60h, 00h		; AnalogColumnClockSelect register (CLK_CR0)
                                        (0217) 	db		62h, 00h		; AnalogIOControl_0 register (ABF_CR0)
                                        (0218) 	db		67h, 33h		; AnalogLUTControl0 register (ALT_CR0)
                                        (0219) 	db		68h, 33h		; AnalogLUTControl1 register (ALT_CR1)
                                        (0220) 	db		63h, 00h		; AnalogModulatorControl_0 register (AMD_CR0)
                                        (0221) 	db		66h, 00h		; AnalogModulatorControl_1 register (AMD_CR1)
                                        (0222) 	db		d1h, 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
                                        (0223) 	db		d3h, 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
                                        (0224) 	db		d0h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
                                        (0225) 	db		d2h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
                                        (0226) 	db		e1h, b1h		; OscillatorControl_1 register (OSC_CR1)
                                        (0227) 	db		e2h, 00h		; OscillatorControl_2 register (OSC_CR2)
                                        (0228) 	db		dfh, 19h		; OscillatorControl_3 register (OSC_CR3)
                                        (0229) 	db		deh, 00h		; OscillatorControl_4 register (OSC_CR4)
                                        (0230) 	db		ddh, 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
                                        (0231) 	db		e7h, 00h		; Type2Decimator_Control register (DEC_CR2)
                                        (0232) 	db		ffh
                                        (0233) AREA psoc_config(rom, rel)
                                        (0234) LoadConfigTBL_kipr_2_Ordered:
                                        (0235) ;  Ordered Global Register values
                                        (0236) 	M8C_SetBank0
05A6: 62 00 00 MOV   REG[0x0],0x0       (0237) 	mov	reg[00h], 00h		; Port_0_Data register (PRT0DR)
05A9: 71 10    OR    F,0x10             
                                        (0238) 	M8C_SetBank1
05AB: 62 00 8A MOV   REG[0x0],0x8A      (0239) 	mov	reg[00h], 8ah		; Port_0_DriveMode_0 register (PRT0DM0)
05AE: 62 01 75 MOV   REG[0x1],0x75      (0240) 	mov	reg[01h], 75h		; Port_0_DriveMode_1 register (PRT0DM1)
05B1: 70 EF    AND   F,0xEF             
                                        (0241) 	M8C_SetBank0
05B3: 62 03 75 MOV   REG[0x3],0x75      (0242) 	mov	reg[03h], 75h		; Port_0_DriveMode_2 register (PRT0DM2)
05B6: 62 02 8A MOV   REG[0x2],0x8A      (0243) 	mov	reg[02h], 8ah		; Port_0_GlobalSelect register (PRT0GS)
05B9: 71 10    OR    F,0x10             
                                        (0244) 	M8C_SetBank1
05BB: 62 02 00 MOV   REG[0x2],0x0       (0245) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
05BE: 62 03 00 MOV   REG[0x3],0x0       (0246) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
05C1: 70 EF    AND   F,0xEF             
                                        (0247) 	M8C_SetBank0
05C3: 62 01 00 MOV   REG[0x1],0x0       (0248) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
05C6: 62 04 00 MOV   REG[0x4],0x0       (0249) 	mov	reg[04h], 00h		; Port_1_Data register (PRT1DR)
05C9: 71 10    OR    F,0x10             
                                        (0250) 	M8C_SetBank1
05CB: 62 04 F0 MOV   REG[0x4],0xF0      (0251) 	mov	reg[04h], f0h		; Port_1_DriveMode_0 register (PRT1DM0)
05CE: 62 05 0F MOV   REG[0x5],0xF       (0252) 	mov	reg[05h], 0fh		; Port_1_DriveMode_1 register (PRT1DM1)
05D1: 70 EF    AND   F,0xEF             
                                        (0253) 	M8C_SetBank0
05D3: 62 07 0F MOV   REG[0x7],0xF       (0254) 	mov	reg[07h], 0fh		; Port_1_DriveMode_2 register (PRT1DM2)
05D6: 62 06 20 MOV   REG[0x6],0x20      (0255) 	mov	reg[06h], 20h		; Port_1_GlobalSelect register (PRT1GS)
05D9: 71 10    OR    F,0x10             
                                        (0256) 	M8C_SetBank1
05DB: 62 06 00 MOV   REG[0x6],0x0       (0257) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
05DE: 62 07 00 MOV   REG[0x7],0x0       (0258) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
05E1: 70 EF    AND   F,0xEF             
                                        (0259) 	M8C_SetBank0
05E3: 62 05 00 MOV   REG[0x5],0x0       (0260) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
05E6: 62 08 04 MOV   REG[0x8],0x4       (0261) 	mov	reg[08h], 04h		; Port_2_Data register (PRT2DR)
05E9: 71 10    OR    F,0x10             
                                        (0262) 	M8C_SetBank1
05EB: 62 08 07 MOV   REG[0x8],0x7       (0263) 	mov	reg[08h], 07h		; Port_2_DriveMode_0 register (PRT2DM0)
05EE: 62 09 F8 MOV   REG[0x9],0xF8      (0264) 	mov	reg[09h], f8h		; Port_2_DriveMode_1 register (PRT2DM1)
05F1: 70 EF    AND   F,0xEF             
                                        (0265) 	M8C_SetBank0
05F3: 62 0B 08 MOV   REG[0xB],0x8       (0266) 	mov	reg[0bh], 08h		; Port_2_DriveMode_2 register (PRT2DM2)
05F6: 62 0A D1 MOV   REG[0xA],0xD1      (0267) 	mov	reg[0ah], d1h		; Port_2_GlobalSelect register (PRT2GS)
05F9: 71 10    OR    F,0x10             
                                        (0268) 	M8C_SetBank1
05FB: 62 0A 28 MOV   REG[0xA],0x28      (0269) 	mov	reg[0ah], 28h		; Port_2_IntCtrl_0 register (PRT2IC0)
05FE: 62 0B 28 MOV   REG[0xB],0x28      (0270) 	mov	reg[0bh], 28h		; Port_2_IntCtrl_1 register (PRT2IC1)
0601: 70 EF    AND   F,0xEF             
                                        (0271) 	M8C_SetBank0
0603: 62 09 28 MOV   REG[0x9],0x28      (0272) 	mov	reg[09h], 28h		; Port_2_IntEn register (PRT2IE)
0606: 62 0C 00 MOV   REG[0xC],0x0       (0273) 	mov	reg[0ch], 00h		; Port_3_Data register (PRT3DR)
0609: 71 10    OR    F,0x10             
                                        (0274) 	M8C_SetBank1
060B: 62 0C 00 MOV   REG[0xC],0x0       (0275) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
060E: 62 0D 00 MOV   REG[0xD],0x0       (0276) 	mov	reg[0dh], 00h		; Port_3_DriveMode_1 register (PRT3DM1)
0611: 70 EF    AND   F,0xEF             
                                        (0277) 	M8C_SetBank0
0613: 62 0F 00 MOV   REG[0xF],0x0       (0278) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
0616: 62 0E 00 MOV   REG[0xE],0x0       (0279) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
0619: 71 10    OR    F,0x10             
                                        (0280) 	M8C_SetBank1
061B: 62 0E 00 MOV   REG[0xE],0x0       (0281) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
061E: 62 0F 00 MOV   REG[0xF],0x0       (0282) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
0621: 70 EF    AND   F,0xEF             
                                        (0283) 	M8C_SetBank0
0623: 62 0D 00 MOV   REG[0xD],0x0       (0284) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
0626: 62 10 00 MOV   REG[0x10],0x0      (0285) 	mov	reg[10h], 00h		; Port_4_Data register (PRT4DR)
0629: 71 10    OR    F,0x10             
                                        (0286) 	M8C_SetBank1
062B: 62 10 00 MOV   REG[0x10],0x0      (0287) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
062E: 62 11 00 MOV   REG[0x11],0x0      (0288) 	mov	reg[11h], 00h		; Port_4_DriveMode_1 register (PRT4DM1)
0631: 70 EF    AND   F,0xEF             
                                        (0289) 	M8C_SetBank0
0633: 62 13 00 MOV   REG[0x13],0x0      (0290) 	mov	reg[13h], 00h		; Port_4_DriveMode_2 register (PRT4DM2)
0636: 62 12 00 MOV   REG[0x12],0x0      (0291) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
0639: 71 10    OR    F,0x10             
                                        (0292) 	M8C_SetBank1
063B: 62 12 00 MOV   REG[0x12],0x0      (0293) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
063E: 62 13 00 MOV   REG[0x13],0x0      (0294) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
0641: 70 EF    AND   F,0xEF             
                                        (0295) 	M8C_SetBank0
0643: 62 11 00 MOV   REG[0x11],0x0      (0296) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
0646: 62 14 00 MOV   REG[0x14],0x0      (0297) 	mov	reg[14h], 00h		; Port_5_Data register (PRT5DR)
0649: 71 10    OR    F,0x10             
                                        (0298) 	M8C_SetBank1
064B: 62 14 00 MOV   REG[0x14],0x0      (0299) 	mov	reg[14h], 00h		; Port_5_DriveMode_0 register (PRT5DM0)
064E: 62 15 00 MOV   REG[0x15],0x0      (0300) 	mov	reg[15h], 00h		; Port_5_DriveMode_1 register (PRT5DM1)
0651: 70 EF    AND   F,0xEF             
                                        (0301) 	M8C_SetBank0
0653: 62 17 00 MOV   REG[0x17],0x0      (0302) 	mov	reg[17h], 00h		; Port_5_DriveMode_2 register (PRT5DM2)
0656: 62 16 00 MOV   REG[0x16],0x0      (0303) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
0659: 71 10    OR    F,0x10             
                                        (0304) 	M8C_SetBank1
065B: 62 16 00 MOV   REG[0x16],0x0      (0305) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
065E: 62 17 00 MOV   REG[0x17],0x0      (0306) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
0661: 70 EF    AND   F,0xEF             
                                        (0307) 	M8C_SetBank0
0663: 62 15 00 MOV   REG[0x15],0x0      (0308) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
0666: 62 18 00 MOV   REG[0x18],0x0      (0309) 	mov	reg[18h], 00h		; Port_6_Data register (PRT6DR)
0669: 71 10    OR    F,0x10             
                                        (0310) 	M8C_SetBank1
066B: 62 18 00 MOV   REG[0x18],0x0      (0311) 	mov	reg[18h], 00h		; Port_6_DriveMode_0 register (PRT6DM0)
066E: 62 19 00 MOV   REG[0x19],0x0      (0312) 	mov	reg[19h], 00h		; Port_6_DriveMode_1 register (PRT6DM1)
0671: 70 EF    AND   F,0xEF             
                                        (0313) 	M8C_SetBank0
0673: 62 1B 00 MOV   REG[0x1B],0x0      (0314) 	mov	reg[1bh], 00h		; Port_6_DriveMode_2 register (PRT6DM2)
0676: 62 1A 00 MOV   REG[0x1A],0x0      (0315) 	mov	reg[1ah], 00h		; Port_6_GlobalSelect register (PRT6GS)
0679: 71 10    OR    F,0x10             
                                        (0316) 	M8C_SetBank1
067B: 62 1A 00 MOV   REG[0x1A],0x0      (0317) 	mov	reg[1ah], 00h		; Port_6_IntCtrl_0 register (PRT6IC0)
067E: 62 1B 00 MOV   REG[0x1B],0x0      (0318) 	mov	reg[1bh], 00h		; Port_6_IntCtrl_1 register (PRT6IC1)
0681: 70 EF    AND   F,0xEF             
                                        (0319) 	M8C_SetBank0
0683: 62 19 00 MOV   REG[0x19],0x0      (0320) 	mov	reg[19h], 00h		; Port_6_IntEn register (PRT6IE)
0686: 62 1C 00 MOV   REG[0x1C],0x0      (0321) 	mov	reg[1ch], 00h		; Port_7_Data register (PRT7DR)
0689: 71 10    OR    F,0x10             
                                        (0322) 	M8C_SetBank1
068B: 62 1C 00 MOV   REG[0x1C],0x0      (0323) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
068E: 62 1D 00 MOV   REG[0x1D],0x0      (0324) 	mov	reg[1dh], 00h		; Port_7_DriveMode_1 register (PRT7DM1)
0691: 70 EF    AND   F,0xEF             
                                        (0325) 	M8C_SetBank0
0693: 62 1F 00 MOV   REG[0x1F],0x0      (0326) 	mov	reg[1fh], 00h		; Port_7_DriveMode_2 register (PRT7DM2)
0696: 62 1E 00 MOV   REG[0x1E],0x0      (0327) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
0699: 71 10    OR    F,0x10             
                                        (0328) 	M8C_SetBank1
069B: 62 1E 00 MOV   REG[0x1E],0x0      (0329) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
069E: 62 1F 00 MOV   REG[0x1F],0x0      (0330) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
06A1: 70 EF    AND   F,0xEF             
                                        (0331) 	M8C_SetBank0
06A3: 62 1D 00 MOV   REG[0x1D],0x0      (0332) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
06A6: 70 EF    AND   F,0xEF             
                                        (0333) 	M8C_SetBank0
06A8: 7F       RET                      (0334) 	ret
                                        (0335) 
                                        (0336) 
                                        (0337) ; PSoC Configuration file trailer PsocConfig.asm
FILE: lib\psocconfig.asm                (0001) ;  Generated by PSoC Designer 5.4.2946
                                        (0002) ;
                                        (0003) ;==========================================================================
                                        (0004) ;  PSoCConfig.asm
                                        (0005) ;  @PSOC_VERSION
                                        (0006) ;
                                        (0007) ;  Version: 0.85
                                        (0008) ;  Revised: June 22, 2004
                                        (0009) ;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;
                                        (0011) ;  This file is generated by the Device Editor on Application Generation.
                                        (0012) ;  It contains code which loads the configuration data table generated in
                                        (0013) ;  the file PSoCConfigTBL.asm
                                        (0014) ;
                                        (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                        (0016) ;  Edits to this file will not be preserved.
                                        (0017) ;==========================================================================
                                        (0018) ;
                                        (0019) include "m8c.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "GlobalParams.inc"
                                        (0022) 
                                        (0023) export LoadConfigInit
                                        (0024) export _LoadConfigInit
                                        (0025) export LoadConfig_kipr_2
                                        (0026) export _LoadConfig_kipr_2
                                        (0027) 
                                        (0028) export NO_SHADOW
                                        (0029) export _NO_SHADOW
                                        (0030) 
                                        (0031) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0032) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0033) 
                                        (0034) AREA psoc_config(rom, rel)
                                        (0035) 
                                        (0036) ;---------------------------------------------------------------------------
                                        (0037) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0038) ;                  parameters handled by boot code, like CPU speed). This
                                        (0039) ;                  function can be called from user code, but typically it
                                        (0040) ;                  is only called from boot.
                                        (0041) ;
                                        (0042) ;       INPUTS: None.
                                        (0043) ;      RETURNS: Nothing.
                                        (0044) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0045) ;               In the large memory model currently only the page
                                        (0046) ;               pointer registers listed below are modified.  This does
                                        (0047) ;               not guarantee that in future implementations of this
                                        (0048) ;               function other page pointer registers will not be
                                        (0049) ;               modified.
                                        (0050) ;          
                                        (0051) ;               Page Pointer Registers Modified: 
                                        (0052) ;               CUR_PP
                                        (0053) ;
                                        (0054) _LoadConfigInit:
                                        (0055)  LoadConfigInit:
                                        (0056)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0057)     
06A9: 7C 06 B0 LCALL 0x06B0             (0058) 	lcall	LoadConfig_kipr_2
06AC: 7C 05 A4 LCALL 0x05A4             (0059) 	lcall	LoadConfigTBL_kipr_2_Ordered
                                        (0060) 
                                        (0061) 
                                        (0062)     RAM_EPILOGUE RAM_USE_CLASS_4
06AF: 7F       RET                      (0063)     ret
                                        (0064) 
                                        (0065) ;---------------------------------------------------------------------------
                                        (0066) ; Load Configuration kipr_2
                                        (0067) ;
                                        (0068) ;    Load configuration registers for kipr_2.
                                        (0069) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0070) ;
                                        (0071) ;       INPUTS: None.
                                        (0072) ;      RETURNS: Nothing.
                                        (0073) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0074) ;               modified as may the Page Pointer registers!
                                        (0075) ;               In the large memory model currently only the page
                                        (0076) ;               pointer registers listed below are modified.  This does
                                        (0077) ;               not guarantee that in future implementations of this
                                        (0078) ;               function other page pointer registers will not be
                                        (0079) ;               modified.
                                        (0080) ;          
                                        (0081) ;               Page Pointer Registers Modified: 
                                        (0082) ;               CUR_PP
                                        (0083) ;
                                        (0084) _LoadConfig_kipr_2:
                                        (0085)  LoadConfig_kipr_2:
                                        (0086)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0087) 
06B0: 10       PUSH  X                  (0088) 	push	x
06B1: 70 EF    AND   F,0xEF             
                                        (0089)     M8C_SetBank0                    ; Force bank 0
06B3: 50 00    MOV   A,0x0              (0090)     mov     a, 0                    ; Specify bank 0
06B5: 67       ASR   A                  (0091)     asr     a                       ; Store in carry flag
                                        (0092)                                     ; Load bank 0 table:
06B6: 50 03    MOV   A,0x3              (0093)     mov     A, >LoadConfigTBL_kipr_2_Bank0
06B8: 57 4D    MOV   X,0x4D             (0094)     mov     X, <LoadConfigTBL_kipr_2_Bank0
06BA: 7C 06 CB LCALL 0x06CB             (0095)     lcall   LoadConfig              ; Load the bank 0 values
                                        (0096) 
06BD: 50 01    MOV   A,0x1              (0097)     mov     a, 1                    ; Specify bank 1
06BF: 67       ASR   A                  (0098)     asr     a                       ; Store in carry flag
                                        (0099)                                     ; Load bank 1 table:
06C0: 50 03    MOV   A,0x3              (0100)     mov     A, >LoadConfigTBL_kipr_2_Bank1
06C2: 57 FC    MOV   X,0xFC             (0101)     mov     X, <LoadConfigTBL_kipr_2_Bank1
06C4: 7C 06 CB LCALL 0x06CB             (0102)     lcall   LoadConfig              ; Load the bank 1 values
06C7: 70 EF    AND   F,0xEF             
                                        (0103) 
                                        (0104)     M8C_SetBank0                    ; Force return to bank 0
06C9: 20       POP   X                  (0105) 	pop		x
                                        (0106) 
                                        (0107)     RAM_EPILOGUE RAM_USE_CLASS_4
06CA: 7F       RET                      (0108)     ret
                                        (0109) 
                                        (0110) 
                                        (0111) 
                                        (0112) 
                                        (0113) ;---------------------------------------------------------------------------
                                        (0114) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
                                        (0115) ;              pairs. Terminate on address=0xFF.
                                        (0116) ;
                                        (0117) ;  INPUTS:  [A,X] points to the table to be loaded
                                        (0118) ;           Flag Register Carry bit encodes the Register Bank
                                        (0119) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
                                        (0120) ;
                                        (0121) ;  RETURNS: nothing.
                                        (0122) ;
                                        (0123) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
                                        (0124) ;                X-3 Temporary store for register address
                                        (0125) ;                X-2 LSB of config table address
                                        (0126) ;                X-1 MSB of config table address
                                        (0127) ;
                                        (0128) LoadConfig:
                                        (0129)     RAM_PROLOGUE RAM_USE_CLASS_2
06CB: 38 02    ADD   SP,0x2             (0130)     add     SP, 2                   ; Set up local vars
06CD: 10       PUSH  X                  (0131)     push    X                       ; Save config table address on stack
06CE: 08       PUSH  A                  (0132)     push    A
06CF: 4F       MOV   X,SP               (0133)     mov     X, SP
06D0: 56 FC 00 MOV   [X-4],0x0          (0134)     mov     [X-4], 0                ; Set default Destination to Bank 0
06D3: D0 04    JNC   0x06D8             (0135)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
06D5: 56 FC 01 MOV   [X-4],0x1          (0136)     mov     [X-4], 1                ; No Carry: default to Bank 1
                                        (0137) .BankSelectSaved:
06D8: 18       POP   A                  (0138)     pop     A
06D9: 20       POP   X                  (0139)     pop     X
06DA: 70 EF    AND   F,0xEF             
06DC: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0140) 
                                        (0141) LoadConfigLp:
                                        (0142)     M8C_SetBank0                    ; Switch to bank 0
                                        (0143)     M8C_ClearWDT                    ; Clear the watchdog for long inits
06DF: 10       PUSH  X                  (0144)     push    X                       ; Preserve the config table address
06E0: 08       PUSH  A                  (0145)     push    A
06E1: 28       ROMX                     (0146)     romx                            ; Load register address from table
06E2: 39 FF    CMP   A,0xFF             (0147)     cmp     A, END_CONFIG_TABLE     ; End of table?
06E4: A0 1F    JZ    0x0704             (0148)     jz      EndLoadConfig           ;   Yes, go wrap it up
06E6: 4F       MOV   X,SP               (0149)     mov     X, SP                   ;
06E7: 48 FC 01 TST   [X-4],0x1          (0150)     tst     [X-4], 1                ; Loading IO Bank 1?
06EA: A0 03    JZ    0x06EE             (0151)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
06EC: 71 10    OR    F,0x10             
                                        (0152)     M8C_SetBank1                    ;   Yes, switch to Bank 1
                                        (0153) .IOBankNowSet:
06EE: 54 FD    MOV   [X-3],A            (0154)     mov     [X-3], A                ; Stash the register address
06F0: 18       POP   A                  (0155)     pop     A                       ; Retrieve the table address
06F1: 20       POP   X                  (0156)     pop     X
06F2: 75       INC   X                  (0157)     inc     X                       ; Advance to the data byte
06F3: 09 00    ADC   A,0x0              (0158)     adc     A, 0
06F5: 10       PUSH  X                  (0159)     push    X                       ; Save the config table address again
06F6: 08       PUSH  A                  (0160)     push    A
06F7: 28       ROMX                     (0161)     romx                            ; load config data from the table
06F8: 4F       MOV   X,SP               (0162)     mov     X, SP                   ; retrieve the register address
06F9: 59 FD    MOV   X,[X-3]            (0163)     mov     X, [X-3]
06FB: 61 00    MOV   REG[X+0x0],A       (0164)     mov     reg[X], A               ; Configure the register
06FD: 18       POP   A                  (0165)     pop     A                       ; retrieve the table address
06FE: 20       POP   X                  (0166)     pop     X
06FF: 75       INC   X                  (0167)     inc     X                       ; advance to next table entry
0700: 09 00    ADC   A,0x0              (0168)     adc     A, 0
0702: 8F D7    JMP   0x06DA             (0169)     jmp     LoadConfigLp            ; loop to configure another register
                                        (0170) EndLoadConfig:
0704: 38 FC    ADD   SP,0xFC            (0171)     add     SP, -4
0706: 70 3F    AND   F,0x3F             
0708: 71 C0    OR    F,0xC0             
                                        (0172)     RAM_EPILOGUE RAM_USE_CLASS_2
070A: 7F       RET                      (0173)     ret
                                        (0174) 
                                        (0175) AREA InterruptRAM(ram, rel)
                                        (0176) 
                                        (0177) NO_SHADOW:
                                        (0178) _NO_SHADOW:
FILE: lib\veltimerint.asm               (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: VelTimerINT.asm
                                        (0004) ;;   Version: 2.6, Updated on 2014/7/14 at 8:16:40
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Timer32 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "VelTimer.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _VelTimer_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _VelTimer_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _VelTimer_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
                                        (0081)    ;lcall _My_C_Function
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
070B: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file VelTimerINT.asm
FILE: lib\veltimer.asm                  (0001) ;;*****************************************************************************
070C: 43 DF 80 OR    REG[0xDF],0x80     (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: VelTimer.asm
                                        (0004) ;;   Version: 2.6, Updated on 2014/7/14 at 8:16:40
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Timer32 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "VelTimer.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  VelTimer_EnableInt
                                        (0030) export _VelTimer_EnableInt
                                        (0031) export  VelTimer_DisableInt
                                        (0032) export _VelTimer_DisableInt
                                        (0033) export  VelTimer_Start
                                        (0034) export _VelTimer_Start
                                        (0035) export  VelTimer_Stop
                                        (0036) export _VelTimer_Stop
                                        (0037) export  VelTimer_WritePeriod
                                        (0038) export _VelTimer_WritePeriod
                                        (0039) export  VelTimer_WriteCompareValue
                                        (0040) export _VelTimer_WriteCompareValue
                                        (0041) export  VelTimer_ReadCompareValue
                                        (0042) export _VelTimer_ReadCompareValue
                                        (0043) export  VelTimer_ReadTimer
                                        (0044) export _VelTimer_ReadTimer
                                        (0045) export  VelTimer_ReadTimerSaveCV
                                        (0046) export _VelTimer_ReadTimerSaveCV
                                        (0047) 
                                        (0048) ; The following functions are deprecated and subject to omission in future releases
                                        (0049) ;
                                        (0050) export  VelTimer_ReadCounter       ; obsolete
                                        (0051) export _VelTimer_ReadCounter       ; obsolete
                                        (0052) export  VelTimer_CaptureCounter    ; obsolete
                                        (0053) export _VelTimer_CaptureCounter    ; obsolete
                                        (0054) 
                                        (0055) 
                                        (0056) AREA kipr_2_RAM (RAM,REL)
                                        (0057) 
                                        (0058) ;-----------------------------------------------
                                        (0059) ;  Constant Definitions
                                        (0060) ;-----------------------------------------------
                                        (0061) 
                                        (0062) 
                                        (0063) ;-----------------------------------------------
                                        (0064) ; Variable Allocation
                                        (0065) ;-----------------------------------------------
                                        (0066) 
                                        (0067) 
                                        (0068) AREA UserModules (ROM, REL)
                                        (0069) 
                                        (0070) .SECTION
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;  FUNCTION NAME: VelTimer_EnableInt
                                        (0073) ;
                                        (0074) ;  DESCRIPTION:
                                        (0075) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
                                        (0076) ;     associated with this User Module. This function has no effect until and
                                        (0077) ;     unless the global interrupts are enabled (for example by using the
                                        (0078) ;     macro M8C_EnableGInt).
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;
                                        (0081) ;  ARGUMENTS:    None.
                                        (0082) ;  RETURNS:      Nothing.
                                        (0083) ;  SIDE EFFECTS: 
                                        (0084) ;    The A and X registers may be modified by this or future implementations
                                        (0085) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0086) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0087) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0088) ;    functions.
                                        (0089) ;
                                        (0090)  VelTimer_EnableInt:
                                        (0091) _VelTimer_EnableInt:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0093)    VelTimer_EnableInt_M
                                        (0094)    RAM_EPILOGUE RAM_USE_CLASS_1
070F: 7F       RET                      (0095)    ret
0710: 41 DF 7F AND   REG[0xDF],0x7F     
                                        (0096) 
                                        (0097) .ENDSECTION
                                        (0098) 
                                        (0099) 
                                        (0100) .SECTION
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;  FUNCTION NAME: VelTimer_DisableInt
                                        (0103) ;
                                        (0104) ;  DESCRIPTION:
                                        (0105) ;     Disables this timer's interrupt by clearing the interrupt enable
                                        (0106) ;     mask bit associated with this User Module.
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS:    None
                                        (0110) ;  RETURNS:      Nothing
                                        (0111) ;  SIDE EFFECTS: 
                                        (0112) ;    The A and X registers may be modified by this or future implementations
                                        (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0116) ;    functions.
                                        (0117) ;
                                        (0118)  VelTimer_DisableInt:
                                        (0119) _VelTimer_DisableInt:
                                        (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0121)    VelTimer_DisableInt_M
                                        (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
0713: 7F       RET                      (0123)    ret
0714: 43 53 01 OR    REG[0x53],0x1      
                                        (0124) 
                                        (0125) .ENDSECTION
                                        (0126) 
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: VelTimer_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit in the Control register of this user module.  The
                                        (0134) ;     timer will begin counting on the next input clock.
                                        (0135) ;-----------------------------------------------------------------------------
                                        (0136) ;
                                        (0137) ;  ARGUMENTS:    None
                                        (0138) ;  RETURNS:      Nothing
                                        (0139) ;  SIDE EFFECTS: 
                                        (0140) ;    The A and X registers may be modified by this or future implementations
                                        (0141) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0142) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0143) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0144) ;    functions.
                                        (0145) ;
                                        (0146)  VelTimer_Start:
                                        (0147) _VelTimer_Start:
                                        (0148)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0149)    VelTimer_Start_M
                                        (0150)    RAM_EPILOGUE RAM_USE_CLASS_1
0717: 7F       RET                      (0151)    ret
0718: 41 53 FE AND   REG[0x53],0xFE     
                                        (0152) 
                                        (0153) .ENDSECTION
                                        (0154) 
                                        (0155) 
                                        (0156) .SECTION
                                        (0157) ;-----------------------------------------------------------------------------
                                        (0158) ;  FUNCTION NAME: VelTimer_Stop
                                        (0159) ;
                                        (0160) ;  DESCRIPTION:
                                        (0161) ;     Disables timer operation by clearing the start bit in the Control
                                        (0162) ;     register of the LSB block.
                                        (0163) ;-----------------------------------------------------------------------------
                                        (0164) ;
                                        (0165) ;  ARGUMENTS:    None
                                        (0166) ;  RETURNS:      Nothing
                                        (0167) ;  SIDE EFFECTS: 
                                        (0168) ;    The A and X registers may be modified by this or future implementations
                                        (0169) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0170) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0171) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0172) ;    functions.
                                        (0173) ;
                                        (0174)  VelTimer_Stop:
                                        (0175) _VelTimer_Stop:
                                        (0176)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0177)    VelTimer_Stop_M
                                        (0178)    RAM_EPILOGUE RAM_USE_CLASS_1
071B: 7F       RET                      (0179)    ret
                                        (0180) 
                                        (0181) .ENDSECTION
                                        (0182) 
                                        (0183) 
                                        (0184) .SECTION
                                        (0185) ;-----------------------------------------------------------------------------
                                        (0186) ;  FUNCTION NAME: VelTimer_WritePeriod
                                        (0187) ;
                                        (0188) ;  DESCRIPTION:
                                        (0189) ;     Write the 32-bit period value into the Period register (DR1). If the
                                        (0190) ;     Timer user module is stopped, then this value will also be latched
                                        (0191) ;     into the Count register (DR0).
                                        (0192) ;-----------------------------------------------------------------------------
                                        (0193) ;
                                        (0194) ;  ARGUMENTS: fastcall16 DWORD dwPeriodValue (on stack)
                                        (0195) ;  RETURNS:   Nothing
                                        (0196) ;  SIDE EFFECTS:
                                        (0197) ;    If the timer user module is stopped, then this value will also be
                                        (0198) ;    latched into the Count registers (DR0).
                                        (0199) ;    
                                        (0200) ;    The A and X registers may be modified by this or future implementations
                                        (0201) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0202) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0203) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0204) ;    functions.
                                        (0205) ;
                                        (0206) _VelTimer_WritePeriod:
                                        (0207)  VelTimer_WritePeriod:
                                        (0208)    RAM_PROLOGUE RAM_USE_CLASS_2
071C: 4F       MOV   X,SP               (0209)    mov   X, SP
071D: 52 FA    MOV   A,[X-6]            (0210)    mov   A, [X-6]                                ; load the period registers
071F: 60 5D    MOV   REG[0x5D],A        (0211)    mov   reg[VelTimer_PERIOD_MSB_REG],  A
0721: 52 FB    MOV   A,[X-5]            (0212)    mov   A, [X-5]
0723: 60 59    MOV   REG[0x59],A        (0213)    mov   reg[VelTimer_PERIOD_ISB2_REG], A
0725: 52 FC    MOV   A,[X-4]            (0214)    mov   A, [X-4]
0727: 60 55    MOV   REG[0x55],A        (0215)    mov   reg[VelTimer_PERIOD_ISB1_REG], A
0729: 52 FD    MOV   A,[X-3]            (0216)    mov   A, [X-3]
072B: 60 51    MOV   REG[0x51],A        (0217)    mov   reg[VelTimer_PERIOD_LSB_REG],  A
072D: 70 3F    AND   F,0x3F             
072F: 71 C0    OR    F,0xC0             
                                        (0218)    RAM_EPILOGUE RAM_USE_CLASS_2
0731: 7F       RET                      (0219)    ret
                                        (0220) 
                                        (0221) .ENDSECTION
                                        (0222) 
                                        (0223) 
                                        (0224) .SECTION
                                        (0225) ;-----------------------------------------------------------------------------
                                        (0226) ;  FUNCTION NAME: VelTimer_WriteCompareValue
                                        (0227) ;
                                        (0228) ;  DESCRIPTION:
                                        (0229) ;     Writes compare value into the Compare register (DR2).
                                        (0230) ;
                                        (0231) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                        (0232) ;           Compare register. (Call VelTimer_Stop to disable).
                                        (0233) ;-----------------------------------------------------------------------------
                                        (0234) ;
                                        (0235) ;  ARGUMENTS:    fastcall16 DWORD dwCompareValue (on stack)
                                        (0236) ;  RETURNS:      Nothing
                                        (0237) ;  SIDE EFFECTS: 
                                        (0238) ;    The A and X registers may be modified by this or future implementations
                                        (0239) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0240) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0241) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0242) ;    functions.
                                        (0243) ;
                                        (0244) _VelTimer_WriteCompareValue:
                                        (0245)  VelTimer_WriteCompareValue:
                                        (0246)    RAM_PROLOGUE RAM_USE_CLASS_2
0732: 4F       MOV   X,SP               (0247)    mov   X, SP
0733: 52 FA    MOV   A,[X-6]            (0248)    mov   A, [X-6]                                ; load the compare registers
0735: 60 5E    MOV   REG[0x5E],A        (0249)    mov   reg[VelTimer_COMPARE_MSB_REG],  A
0737: 52 FB    MOV   A,[X-5]            (0250)    mov   A, [X-5]
0739: 60 5A    MOV   REG[0x5A],A        (0251)    mov   reg[VelTimer_COMPARE_ISB2_REG], A
073B: 52 FC    MOV   A,[X-4]            (0252)    mov   A, [X-4]
073D: 60 56    MOV   REG[0x56],A        (0253)    mov   reg[VelTimer_COMPARE_ISB1_REG], A
073F: 52 FD    MOV   A,[X-3]            (0254)    mov   A, [X-3]
0741: 60 52    MOV   REG[0x52],A        (0255)    mov   reg[VelTimer_COMPARE_LSB_REG],  A
0743: 70 3F    AND   F,0x3F             
0745: 71 C0    OR    F,0xC0             
                                        (0256)    RAM_EPILOGUE RAM_USE_CLASS_2
0747: 7F       RET                      (0257)    ret
0748: 70 BF    AND   F,0xBF             
074A: 60 D3    MOV   REG[0xD3],A        
                                        (0258) 
                                        (0259) .ENDSECTION
                                        (0260) 
                                        (0261) 
                                        (0262) .SECTION
                                        (0263) ;-----------------------------------------------------------------------------
                                        (0264) ;  FUNCTION NAME: VelTimer_ReadCompareValue
                                        (0265) ;
                                        (0266) ;  DESCRIPTION:
                                        (0267) ;     Reads the Compare registers.
                                        (0268) ;-----------------------------------------------------------------------------
                                        (0269) ;
                                        (0270) ;  ARGUMENTS: fastcall16 DWORD * pdwCompareValue
                                        (0271) ;             (pointer: LSB in X, MSB in A, for pass-by-reference update)
                                        (0272) ;  RETURNS:   Nothing (but see Side Effects).
                                        (0273) ;  SIDE EFFECTS:
                                        (0274) ;     1. The DWORD pointed to by X takes on the value read from DR2
                                        (0275) ;     2. The A and X registers may be modified by this or future implementations
                                        (0276) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0277) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0278) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0279) ;        functions.
                                        (0280) ;              
                                        (0281) ;        Currently only the page pointer registers listed below are modified: 
                                        (0282) ;              IDX_PP
                                        (0283) 
                                        (0284) ;
                                        (0285)  VelTimer_ReadCompareValue:
                                        (0286) _VelTimer_ReadCompareValue:
                                        (0287)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0288)    RAM_SETPAGE_IDX A 
074C: 5D 5E    MOV   A,REG[0x5E]        (0289)    mov   A, reg[VelTimer_COMPARE_MSB_REG]
074E: 54 00    MOV   [X+0],A            (0290)    mov   [X+0], A
0750: 5D 5A    MOV   A,REG[0x5A]        (0291)    mov   A, reg[VelTimer_COMPARE_ISB2_REG]
0752: 54 01    MOV   [X+1],A            (0292)    mov   [X+1], A
0754: 5D 56    MOV   A,REG[0x56]        (0293)    mov   A, reg[VelTimer_COMPARE_ISB1_REG]
0756: 54 02    MOV   [X+2],A            (0294)    mov   [X+2], A
0758: 5D 52    MOV   A,REG[0x52]        (0295)    mov   A, reg[VelTimer_COMPARE_LSB_REG]
075A: 54 03    MOV   [X+3],A            (0296)    mov   [X+3], A
075C: 70 3F    AND   F,0x3F             
075E: 71 C0    OR    F,0xC0             
                                        (0297)    RAM_EPILOGUE RAM_USE_CLASS_3
0760: 7F       RET                      (0298)    ret
0761: 70 BF    AND   F,0xBF             
0763: 60 D3    MOV   REG[0xD3],A        
                                        (0299) 
                                        (0300) .ENDSECTION
                                        (0301) 
                                        (0302) 
                                        (0303) .SECTION
                                        (0304) ;-----------------------------------------------------------------------------
                                        (0305) ;  FUNCTION NAME: VelTimer_ReadTimerSaveCV
                                        (0306) ;
                                        (0307) ;  DESCRIPTION:
                                        (0308) ;     Retrieves the value in the Count register (DR0), preserving the
                                        (0309) ;     value in the compare register (DR2).
                                        (0310) ;-----------------------------------------------------------------------------
                                        (0311) ;
                                        (0312) ;  ARGUMENTS: fastcall16 DWORD * pdwCount
                                        (0313) ;             (pointer: LSB in X, MSB in A, for pass-by-reference update)
                                        (0314) ;  RETURNS:   Nothing (but see Side Effects).
                                        (0315) ;  SIDE EFFECTS:
                                        (0316) ;     1) The DWORD pointed to by X takes on the value read from DR0
                                        (0317) ;     2) May cause an interrupt, if interrupt on Compare is enabled.
                                        (0318) ;     3) If enabled, Global interrupts are momentarily disabled.
                                        (0319) ;     4) The user module is stopped momentarily while the compare value is
                                        (0320) ;        restored.  This may cause the Count register to miss one or more
                                        (0321) ;        counts depending on the input clock speed.
                                        (0322) ;     5) The A and X registers may be modified by this or future implementations
                                        (0323) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0324) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0325) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0326) ;        functions.
                                        (0327) ;              
                                        (0328) ;        Currently only the page pointer registers listed below are modified: 
                                        (0329) ;              IDX_PP
                                        (0330) ;
                                        (0331) ;  THEORY of OPERATION:
                                        (0332) ;     1) Read and save the Compare register.
                                        (0333) ;     2) Read the Count register, causing its data to be latched into
                                        (0334) ;        the Compare register.
                                        (0335) ;     3) Read and save the Counter value, now in the Compare register,
                                        (0336) ;        to the buffer.
                                        (0337) ;     4) Disable global interrupts
                                        (0338) ;     5) Halt the timer
                                        (0339) ;     6) Restore the Compare register values
                                        (0340) ;     7) Start the Timer again
                                        (0341) ;     8) Restore global interrupt state
                                        (0342) ;
                                        (0343)  VelTimer_ReadTimerSaveCV:
                                        (0344) _VelTimer_ReadTimerSaveCV:
                                        (0345)  VelTimer_ReadCounter:                           ; this name deprecated
                                        (0346) _VelTimer_ReadCounter:                           ; this name deprecated
                                        (0347) 
                                        (0348)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0349)    RAM_SETPAGE_IDX A 
                                        (0350) 
                                        (0351)    ; save the Control register on the stack
0765: 5D 53    MOV   A,REG[0x53]        (0352)    mov   A, reg[VelTimer_CONTROL_LSB_REG]
0767: 08       PUSH  A                  (0353)    push  A
                                        (0354) 
                                        (0355)    ; save the Compare register value
0768: 5D 5E    MOV   A,REG[0x5E]        (0356)    mov   A, reg[VelTimer_COMPARE_MSB_REG]
076A: 08       PUSH  A                  (0357)    push  A
076B: 5D 5A    MOV   A,REG[0x5A]        (0358)    mov   A, reg[VelTimer_COMPARE_ISB2_REG]
076D: 08       PUSH  A                  (0359)    push  A
076E: 5D 56    MOV   A,REG[0x56]        (0360)    mov   A, reg[VelTimer_COMPARE_ISB1_REG]
0770: 08       PUSH  A                  (0361)    push  A
0771: 5D 52    MOV   A,REG[0x52]        (0362)    mov   A, reg[VelTimer_COMPARE_LSB_REG]
0773: 08       PUSH  A                  (0363)    push  A
                                        (0364) 
                                        (0365)    ; Read the LSB count. This latches the Count register data into the
                                        (0366)    ; Compare register of all bytes of chained PSoC blocks!
                                        (0367)    ; This may cause an interrupt.
0774: 5D 50    MOV   A,REG[0x50]        (0368)    mov   A, reg[VelTimer_COUNTER_LSB_REG]
                                        (0369) 
                                        (0370)    ; Read the Compare register, which contains the counter value
                                        (0371)    ; and store the return result
0776: 5D 5E    MOV   A,REG[0x5E]        (0372)    mov   A, reg[VelTimer_COMPARE_MSB_REG]
0778: 54 00    MOV   [X+0],A            (0373)    mov   [X+0], A
077A: 5D 5A    MOV   A,REG[0x5A]        (0374)    mov   A, reg[VelTimer_COMPARE_ISB2_REG]
077C: 54 01    MOV   [X+1],A            (0375)    mov   [X+1], A
077E: 5D 56    MOV   A,REG[0x56]        (0376)    mov   A, reg[VelTimer_COMPARE_ISB1_REG]
0780: 54 02    MOV   [X+2],A            (0377)    mov   [X+2], A
0782: 5D 52    MOV   A,REG[0x52]        (0378)    mov   A, reg[VelTimer_COMPARE_LSB_REG]
0784: 54 03    MOV   [X+3],A            (0379)    mov   [X+3], A
                                        (0380) 
                                        (0381)    ; determine current interrupt state and save in X
0786: 50 00    MOV   A,0x0              (0382)    mov   A, 0
0788: 49 F7 01 TST   REG[0xF7],0x1      (0383)    tst   reg[CPU_F], FLAG_GLOBAL_IE
078B: A0 03    JZ    0x078F             (0384)    jz    .SetupStatusFlag
078D: 50 01    MOV   A,0x1              (0385)    mov   A, FLAG_GLOBAL_IE
                                        (0386) .SetupStatusFlag:
078F: 5C       MOV   X,A                (0387)    mov   X, A
0790: 70 FE    AND   F,0xFE             
0792: 41 53 FE AND   REG[0x53],0xFE     
                                        (0388) 
                                        (0389)    ; disable interrupts for the time being
                                        (0390)    M8C_DisableGInt
                                        (0391) 
                                        (0392)    ; stop the timer
                                        (0393)    VelTimer_Stop_M
                                        (0394) 
                                        (0395)    ; Restore the Compare register
0795: 18       POP   A                  (0396)    pop   A
0796: 60 52    MOV   REG[0x52],A        (0397)    mov   reg[VelTimer_COMPARE_LSB_REG],  A
0798: 18       POP   A                  (0398)    pop   A
0799: 60 56    MOV   REG[0x56],A        (0399)    mov   reg[VelTimer_COMPARE_ISB1_REG], A
079B: 18       POP   A                  (0400)    pop   A
079C: 60 5A    MOV   REG[0x5A],A        (0401)    mov   reg[VelTimer_COMPARE_ISB2_REG], A
079E: 18       POP   A                  (0402)    pop   A
079F: 60 5E    MOV   REG[0x5E],A        (0403)    mov   reg[VelTimer_COMPARE_MSB_REG],  A
                                        (0404) 
                                        (0405)    ; restore start state of the timer
07A1: 18       POP   A                  (0406)    pop   A
07A2: 60 53    MOV   REG[0x53],A        (0407)    mov   reg[VelTimer_CONTROL_LSB_REG], A
                                        (0408) 
                                        (0409)    ; push the flag register to restore on the stack
07A4: 10       PUSH  X                  (0410)    push  X
07A5: 70 3F    AND   F,0x3F             
07A7: 71 C0    OR    F,0xC0             
                                        (0411) 
                                        (0412)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0413)    ; Use RETI because it pops a the flag register off the stack
                                        (0414)    ; and then returns to the caller.
07A9: 7E       RETI                     (0415)    reti
07AA: 70 BF    AND   F,0xBF             
07AC: 60 D3    MOV   REG[0xD3],A        
                                        (0416) 
                                        (0417) .ENDSECTION
                                        (0418) 
                                        (0419) 
                                        (0420) .SECTION
                                        (0421) ;-----------------------------------------------------------------------------
                                        (0422) ;  FUNCTION NAME: VelTimer_ReadTimer
                                        (0423) ;
                                        (0424) ;  DESCRIPTION:
                                        (0425) ;     Performs a software capture of the Count register.  A synchronous
                                        (0426) ;     read of the Count register is performed.  The timer is NOT stopped.
                                        (0427) ;
                                        (0428) ;     WARNING - this will cause loss of data in the Compare register.
                                        (0429) ;-----------------------------------------------------------------------------
                                        (0430) ;
                                        (0431) ;  ARGUMENTS: fastcall16 DWORD * pdwCount
                                        (0432) ;             (pointer: LSB in X, MSB in A, for pass-by-reference update)
                                        (0433) ;  RETURNS:   Nothing (but see Side Effects).
                                        (0434) ;  SIDE EFFECTS:
                                        (0435) ;     1) The DWORD pointed to by X takes on the value read from DR2.
                                        (0436) ;     2) May cause an interrupt.
                                        (0437) ;     3) The A and X registers may be modified by this or future implementations
                                        (0438) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0439) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0440) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0441) ;        functions.
                                        (0442) ;              
                                        (0443) ;        Currently only the page pointer registers listed below are modified: 
                                        (0444) ;              IDX_PP
                                        (0445) ;
                                        (0446) ;  THEORY of OPERATION:
                                        (0447) ;     1) Read the Count register - this causes the count value to be
                                        (0448) ;        latched into the Compare registers.
                                        (0449) ;     2) Read and return the Count register values from the Compare
                                        (0450) ;        registers into the return buffer.
                                        (0451) ;
                                        (0452)  VelTimer_ReadTimer:
                                        (0453) _VelTimer_ReadTimer:
                                        (0454)  VelTimer_CaptureCounter:                        ; this name deprecated
                                        (0455) _VelTimer_CaptureCounter:                        ; this name deprecated
                                        (0456) 
                                        (0457)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0458)    RAM_SETPAGE_IDX A 
                                        (0459) 
                                        (0460)    ; Read the LSB of the Count register, DR0. This latches the count data into
                                        (0461)    ; the Compare register of all bytes of chained PSoC blocks and may cause
                                        (0462)    ; an interrupt.
07AE: 5D 50    MOV   A,REG[0x50]        (0463)    mov   A, reg[VelTimer_COUNTER_LSB_REG]
                                        (0464) 
                                        (0465)    ; Read the Compare register, which contains the counter value
                                        (0466)    ; and store ther return result
07B0: 5D 5E    MOV   A,REG[0x5E]        (0467)    mov   A, reg[VelTimer_COMPARE_MSB_REG]
07B2: 54 00    MOV   [X+0],A            (0468)    mov   [X+0], A
07B4: 5D 5A    MOV   A,REG[0x5A]        (0469)    mov   A, reg[VelTimer_COMPARE_ISB2_REG]
07B6: 54 01    MOV   [X+1],A            (0470)    mov   [X+1], A
07B8: 5D 56    MOV   A,REG[0x56]        (0471)    mov   A, reg[VelTimer_COMPARE_ISB1_REG]
07BA: 54 02    MOV   [X+2],A            (0472)    mov   [X+2], A
07BC: 5D 52    MOV   A,REG[0x52]        (0473)    mov   A, reg[VelTimer_COMPARE_LSB_REG]
07BE: 54 03    MOV   [X+3],A            (0474)    mov   [X+3], A
07C0: 70 3F    AND   F,0x3F             
07C2: 71 C0    OR    F,0xC0             
                                        (0475)    RAM_EPILOGUE RAM_USE_CLASS_3
07C4: 7F       RET                      (0476)    ret
                                        (0477) 
                                        (0478) .ENDSECTION
                                        (0479) 
                                        (0480) ; End of File VelTimer.asm
FILE: lib\uartint.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   UARTINT.asm
                                        (0004) ;;  Version: 5.3, Updated on 2014/7/14 at 8:16:55
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  UART Interrupt Service Routine.
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) 
                                        (0014) include "UART.inc"
                                        (0015) include "memory.inc"
                                        (0016) include "m8c.inc"
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _UART_TX_ISR
                                        (0022) export  _UART_RX_ISR
                                        (0023) 
                                        (0024) IF (UART_RXBUF_ENABLE)
                                        (0025) export  UART_aRxBuffer
                                        (0026) export _UART_aRxBuffer
                                        (0027) export  UART_bRxCnt
                                        (0028) export _UART_bRxCnt
                                        (0029) export  UART_fStatus
                                        (0030) export _UART_fStatus
                                        (0031) ENDIF
                                        (0032) 
                                        (0033) 
                                        (0034) ;-----------------------------------------------
                                        (0035) ; Variable Allocation
                                        (0036) ;-----------------------------------------------
                                        (0037) AREA InterruptRAM (RAM, REL, CON)
                                        (0038) 
                                        (0039) IF (UART_RXBUF_ENABLE)
                                        (0040)  UART_fStatus:
                                        (0041) _UART_fStatus:      BLK  1
                                        (0042)  UART_bRxCnt:
                                        (0043) _UART_bRxCnt:       BLK  1
                                        (0044) AREA UART_RAM (RAM, REL, CON)
                                        (0045)  UART_aRxBuffer:
                                        (0046) _UART_aRxBuffer:    BLK UART_RX_BUFFER_SIZE
                                        (0047) ENDIF
                                        (0048) 
                                        (0049) AREA InterruptRAM (RAM, REL, CON)
                                        (0050) 
                                        (0051) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0052) ;---------------------------------------------------
                                        (0053) ; Insert your custom declarations below this banner
                                        (0054) ;---------------------------------------------------
                                        (0055) 
                                        (0056) ;------------------------
                                        (0057) ;  Includes
                                        (0058) ;------------------------
                                        (0059) 
                                        (0060) 
                                        (0061) ;------------------------
                                        (0062) ;  Constant Definitions
                                        (0063) ;------------------------
                                        (0064) 
                                        (0065) 
                                        (0066) ;------------------------
                                        (0067) ; Variable Allocation
                                        (0068) ;------------------------
                                        (0069) 
                                        (0070) 
                                        (0071) ;---------------------------------------------------
                                        (0072) ; Insert your custom declarations above this banner
                                        (0073) ;---------------------------------------------------
                                        (0074) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0075) 
                                        (0076) 
                                        (0077) AREA UserModules (ROM, REL, CON)
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;  FUNCTION NAME: _UART_TX_ISR
                                        (0081) ;
                                        (0082) ;  DESCRIPTION:
                                        (0083) ;     UART TX interrupt handler for instance UART.
                                        (0084) ;
                                        (0085) ;     This is a place holder function.  If the user requires use of an interrupt
                                        (0086) ;     handler for this function, then place code where specified.
                                        (0087) ;-----------------------------------------------------------------------------
                                        (0088) 
                                        (0089) _UART_TX_ISR:
                                        (0090)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0091)    ;---------------------------------------------------
                                        (0092)    ; Insert your custom assembly code below this banner
                                        (0093)    ;---------------------------------------------------
                                        (0094)    ;   NOTE: interrupt service routines must preserve
                                        (0095)    ;   the values of the A and X CPU registers.
                                        (0096)    
                                        (0097)    ;---------------------------------------------------
                                        (0098)    ; Insert your custom assembly code above this banner
                                        (0099)    ;---------------------------------------------------
                                        (0100)    
                                        (0101)    ;---------------------------------------------------
                                        (0102)    ; Insert a lcall to a C function below this banner
                                        (0103)    ; and un-comment the lines between these banners
                                        (0104)    ;---------------------------------------------------
                                        (0105)    
                                        (0106)    ;PRESERVE_CPU_CONTEXT
                                        (0107)    ;lcall _My_C_Function
                                        (0108)    ;RESTORE_CPU_CONTEXT
                                        (0109)    
                                        (0110)    ;---------------------------------------------------
                                        (0111)    ; Insert a lcall to a C function above this banner
                                        (0112)    ; and un-comment the lines between these banners
                                        (0113)    ;---------------------------------------------------
                                        (0114)    ;@PSoC_UserCode_END@ (Do not change this line.)
07C5: 7E       RETI                     (0115)    reti
                                        (0116) 
                                        (0117) 
                                        (0118) ;-----------------------------------------------------------------------------
                                        (0119) ;  FUNCTION NAME: _UART_RX_ISR
                                        (0120) ;
                                        (0121) ;  DESCRIPTION:
                                        (0122) ;     UART RX interrupt handler for instance UART.
                                        (0123) ;     This ISR handles the background processing of received characters if
                                        (0124) ;     the buffer is enabled.
                                        (0125) ;
                                        (0126) ;
                                        (0127) ;  The following assumes that the RX buffer feature has been enabled.
                                        (0128) ;
                                        (0129) ;  SIDE EFFECTS:
                                        (0130) ;     There are 3 posible errors that may occur with the serial port.
                                        (0131) ;      1) Parity Error
                                        (0132) ;      2) Framing Error
                                        (0133) ;      3) OverRun Error
                                        (0134) ;
                                        (0135) ;  This user module check for parity and framing error.  If either of these
                                        (0136) ;  two errors are detected, the data is read and ignored.  When an overRun
                                        (0137) ;  error occurs, the last byte was lost, but the current byte is valid.  For
                                        (0138) ;  this reason this error is ignored at this time.  Code could be added to
                                        (0139) ;  this ISR to set a flag if an error condition occurs.
                                        (0140) ;
                                        (0141) ;  THEORY of OPERATION:
                                        (0142) ;     When using the RX buffer feature, the ISR collects received characters
                                        (0143) ;     in a buffer until the user defined command terminator is detected.  After
                                        (0144) ;     the command terminator is detected, the command bit is set and all other
                                        (0145) ;     characters will be ignored until the command bit is reset.  Up to
                                        (0146) ;     buffer_size - 1 characters will be collected waiting for a command
                                        (0147) ;     terminator.  After that, the characters will be discarded, although
                                        (0148) ;     a command determinator will still cause the command bit to be set.
                                        (0149) ;
                                        (0150) ;-----------------------------------------------------------------------------
                                        (0151) _UART_RX_ISR:
                                        (0152) 
                                        (0153)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                        (0154)    ;---------------------------------------------------
                                        (0155)    ; Insert your custom assembly code below this banner
                                        (0156)    ;---------------------------------------------------
                                        (0157)    ;   NOTE: interrupt service routines must preserve
                                        (0158)    ;   the values of the A and X CPU registers.
                                        (0159)    
                                        (0160)    ;---------------------------------------------------
                                        (0161)    ; Insert your custom assembly code above this banner
                                        (0162)    ;---------------------------------------------------
                                        (0163)    
                                        (0164)    ;---------------------------------------------------
                                        (0165)    ; Insert a lcall to a C function below this banner
                                        (0166)    ; and un-comment the lines between these banners
                                        (0167)    ;---------------------------------------------------
                                        (0168)    
                                        (0169)    ;PRESERVE_CPU_CONTEXT
                                        (0170)    ;lcall _My_C_Function
                                        (0171)    ;RESTORE_CPU_CONTEXT
                                        (0172)    
                                        (0173)    ;---------------------------------------------------
                                        (0174)    ; Insert a lcall to a C function above this banner
                                        (0175)    ; and un-comment the lines between these banners
                                        (0176)    ;---------------------------------------------------
                                        (0177)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0178) 
                                        (0179) IF (UART_RXBUF_ENABLE)
07C6: 08       PUSH  A                  (0180)    push A
07C7: 10       PUSH  X                  (0181)    push X
07C8: 5D D3    MOV   A,REG[0xD3]        
07CA: 08       PUSH  A                  
                                        (0182)    
                                        (0183)    IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0184)       REG_PRESERVE IDX_PP
                                        (0185)    ENDIF
                                        (0186)    
07CB: 58 01    MOV   X,[0x1]            (0187)    mov  X,[UART_bRxCnt]                                    ; Load X with byte counter
07CD: 5D 3F    MOV   A,REG[0x3F]        (0188)    mov  A,REG[UART_RX_CONTROL_REG]                         ; Read the control register
07CF: 08       PUSH  A                  (0189)    push A                                                  ; Store copy for later test
                                        (0190)                                                            ; IF real RX interrupt
07D0: 21 08    AND   A,0x8              (0191)    and  A,UART_RX_REG_FULL                                 ; Did really really get an IRQ
07D2: B0 04    JNZ   0x07D7             (0192)    jnz  .UARTRX_ReadRx                                     ; Data ready, go get it
07D4: 18       POP   A                  (0193)    pop  A                                                  ; Restore stack
07D5: 80 5E    JMP   0x0834             (0194)    jmp  .RESTORE_IDX_PP
                                        (0195) 
                                        (0196) .UARTRX_ReadRx:
07D7: 18       POP   A                  (0197)    pop  A                                                  ; Restore status flags
                                        (0198)                                                            ; IF there is no error, get data
                                        (0199)                                                            ; Check for parity or framing error
07D8: 21 E0    AND   A,0xE0             (0200)    and  A,UART_RX_ERROR
07DA: A0 12    JZ    0x07ED             (0201)    jz   .UARTRX_NO_ERROR                                   ; If there is not an Error go read data
                                        (0202) 
07DC: 2C 00    OR    [0x0],A            (0203)    or   [UART_fStatus],A                                   ; Set error flags (parity,framing,overrun) bits
07DE: 49 3E 00 TST   REG[0x3E],0x0      (0204)    tst  REG[UART_RX_BUFFER_REG], 0x00                      ; Read the data buffer to clear it.
07E1: 21 20    AND   A,0x20             (0205)    and  A,UART_RX_FRAMING_ERROR                            ; Check for framing error special case
07E3: A0 50    JZ    0x0834             (0206)    jz   .RESTORE_IDX_PP                                    ; Not framing error, all done
                                        (0207) 
                                        (0208)                                                            ; Disable and re-enable RX to reset after
                                        (0209)                                                            ; framing error.
07E5: 41 3F FE AND   REG[0x3F],0xFE     (0210)    and   REG[UART_RX_CONTROL_REG], ~UART_RX_ENABLE         ; Disable RX
07E8: 43 3F 01 OR    REG[0x3F],0x1      (0211)    or    REG[UART_RX_CONTROL_REG],  UART_RX_ENABLE         ; Enable RX
07EB: 80 48    JMP   0x0834             (0212)    jmp  .RESTORE_IDX_PP                                    ; Done with framing error, leave.
                                        (0213) 
                                        (0214) 
                                        (0215) .UARTRX_NO_ERROR:
07ED: 5D 3E    MOV   A,REG[0x3E]        (0216)    mov  A,REG[UART_RX_BUFFER_REG ]                         ; Read the data buffer
                                        (0217) 
                                        (0218)                                                            ; IF buffer not full
07EF: 47 00 01 TST   [0x0],0x1          (0219)    tst  [UART_fStatus],UART_RX_BUF_CMDTERM                 ; Check for buffer full
07F2: B0 41    JNZ   0x0834             (0220)    jnz  .RESTORE_IDX_PP                                    ; All done
                                        (0221) 
07F4: 39 07    CMP   A,0x7              (0222)    cmp  A,UART_CMD_TERM                                    ; Check for End of command
07F6: B0 14    JNZ   0x080B             (0223)    jnz  .UARTRX_CHK_BACKSPACE
07F8: 2E 00 01 OR    [0x0],0x1          (0224)    or   [UART_fStatus],UART_RX_BUF_CMDTERM                 ; Set command ready bit
07FB: 62 D3 00 MOV   REG[0xD3],0x0      
07FE: 70 3F    AND   F,0x3F             
0800: 71 80    OR    F,0x80             
                                        (0225) 
                                        (0226) 
                                        (0227) 
                                        (0228)    RAM_SETPAGE_IDX >UART_aRxBuffer
                                        (0229)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
0802: 56 02 00 MOV   [X+2],0x0          (0230)    mov  [X + UART_aRxBuffer],00h                           ; Zero out last data
0805: 70 3F    AND   F,0x3F             
0807: 71 00    OR    F,0x0              
                                        (0231)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
0809: 80 2A    JMP   0x0834             (0232)    jmp  .RESTORE_IDX_PP
                                        (0233) 
                                        (0234) .UARTRX_CHK_BACKSPACE:                                     ; 
                                        (0235) IF(UART_BACKSPACE_ENABLE)                                  ; Enable if backspace/delete mode
                                        (0236)    cmp  A,UART_BACKSPACE_ENABLE                            ; Check for backspace character
                                        (0237)    jnz  .UARTRX_IGNORE                                     ; If not, skip the backspace stuff
                                        (0238)    cmp  [UART_bRxCnt],00h                                  ; Check if buffer empty
                                        (0239)    jz   .RESTORE_IDX_PP                                    ; 
                                        (0240)    dec  [UART_bRxCnt]                                      ; Decrement buffer count by one.
                                        (0241)    jmp  .RESTORE_IDX_PP
                                        (0242) ENDIF                                                      ; 
                                        (0243) 
                                        (0244) .UARTRX_IGNORE:
                                        (0245) IF(UART_RX_IGNORE_BELOW)                                   ; Ignore charaters below this value
080B: 39 20    CMP   A,0x20             (0246)    cmp  A,UART_RX_IGNORE_BELOW                             ; If ignore char is set to 0x00, do not
080D: C0 26    JC    0x0834             (0247)    jc   .RESTORE_IDX_PP                                    ; ignore any characters.
080F: 62 D3 00 MOV   REG[0xD3],0x0      
                                        (0248) ENDIF
                                        (0249) 
                                        (0250) .UARTRX_CHK_OVFL:                                          ; Check for MAX String here
                                        (0251) 	
                                        (0252)    RAM_SETPAGE_IDX >UART_aRxBuffer                         ;   using idexed address mode
0812: 3C 01 0F CMP   [0x1],0xF          (0253)    cmp  [UART_bRxCnt],(UART_RX_BUFFER_SIZE - 1)
0815: C0 11    JC    0x0827             (0254)    jc   .UARTRX_ISR_GETDATA
0817: 70 3F    AND   F,0x3F             
0819: 71 80    OR    F,0x80             
                                        (0255)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
081B: 56 02 00 MOV   [X+2],0x0          (0256)    mov  [X + UART_aRxBuffer],00h                           ; Zero out last data in the buffer
081E: 70 3F    AND   F,0x3F             
0820: 71 00    OR    F,0x0              
                                        (0257)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
0822: 2E 00 10 OR    [0x0],0x10         (0258)    or   [UART_fStatus],UART_RX_BUF_OVERRUN                 ; Set error flags (parity,framing,overrun) bits
0825: 80 0E    JMP   0x0834             (0259)    jmp  .RESTORE_IDX_PP
0827: 70 3F    AND   F,0x3F             
0829: 71 80    OR    F,0x80             
                                        (0260) 
                                        (0261) .UARTRX_ISR_GETDATA:                                       ; IF input data == "CR", then end of command
                                        (0262)                                                            ; X is already loaded with pointer
                                        (0263)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
082B: 54 02    MOV   [X+2],A            (0264)    mov  [X+UART_aRxBuffer],A                               ; store data in array
082D: 70 3F    AND   F,0x3F             
082F: 71 00    OR    F,0x0              
                                        (0265)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
0831: 75       INC   X                  (0266)    inc  X                                                  ; Inc the pointer
0832: 5A 01    MOV   [0x1],X            (0267)    mov  [UART_bRxCnt],X                                    ; Restore the pointer
0834: 18       POP   A                  
0835: 60 D3    MOV   REG[0xD3],A        
                                        (0268)                                                            ; ENDIF max string size
                                        (0269) .RESTORE_IDX_PP:
                                        (0270)    IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0271)       REG_RESTORE IDX_PP
                                        (0272)    ENDIF
                                        (0273) 
                                        (0274) .END_UARTRX_ISR:
0837: 20       POP   X                  (0275)    pop  X
0838: 18       POP   A                  (0276)    pop  A
                                        (0277) 
                                        (0278) ENDIF
                                        (0279) 
                                        (0280) UART_RX_ISR_END:
0839: 7E       RETI                     (0281)    reti
                                        (0282) 
                                        (0283) ; end of file UARTINT.asm
                                        (0284) 
FILE: lib\uart.asm                      (0001) ;;*****************************************************************************
083A: 43 E1 40 OR    REG[0xE1],0x40     (0002) ;;*****************************************************************************
083D: 43 E1 80 OR    REG[0xE1],0x80     
                                        (0003) ;;  Filename:   UART.asm
                                        (0004) ;;  Version: 5.3, Updated on 2014/7/14 at 8:16:55
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  UART User Module software implementation file for the
                                        (0008) ;;                22/24/25/26/27xxx families.
                                        (0009) ;;
                                        (0010) ;;
                                        (0011) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0012) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0013) ;;        This means it is the caller's responsibility to preserve any values
                                        (0014) ;;        in the X and A registers that are still needed after the API functions
                                        (0015) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0016) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0017) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0018) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0019) ;;-----------------------------------------------------------------------------
                                        (0020) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0021) ;;*****************************************************************************
                                        (0022) ;;*****************************************************************************
                                        (0023) 
                                        (0024) 
                                        (0025) include "m8c.inc"
                                        (0026) include "memory.inc"
                                        (0027) include "UART.inc"
                                        (0028) 
                                        (0029) ;-----------------------------------------------
                                        (0030) ;  Global Symbols
                                        (0031) ;-----------------------------------------------
                                        (0032) ;-------------------------------------------------------------------
                                        (0033) ;  Declare the functions global for both assembler and C compiler.
                                        (0034) ;
                                        (0035) ;  Note that there are two names for each API. First name is
                                        (0036) ;  assembler reference. Name with underscore is name refence for
                                        (0037) ;  C compiler.  Calling function in C source code does not require
                                        (0038) ;  the underscore.
                                        (0039) ;-------------------------------------------------------------------
                                        (0040) export  UART_SetTxIntMode
                                        (0041) export _UART_SetTxIntMode
                                        (0042) export  UART_EnableInt
                                        (0043) export _UART_EnableInt
                                        (0044) export  UART_DisableInt
                                        (0045) export _UART_DisableInt
                                        (0046) 
                                        (0047) export  UART_Start
                                        (0048) export _UART_Start
                                        (0049) export  UART_Stop
                                        (0050) export _UART_Stop
                                        (0051) export  UART_SendData
                                        (0052) export _UART_SendData
                                        (0053) export  UART_bReadTxStatus
                                        (0054) export _UART_bReadTxStatus
                                        (0055) export  UART_bReadRxData
                                        (0056) export _UART_bReadRxData
                                        (0057) export  UART_bReadRxStatus
                                        (0058) export _UART_bReadRxStatus
                                        (0059) 
                                        (0060) export  UART_IntCntl
                                        (0061) export _UART_IntCntl
                                        (0062) 
                                        (0063) export  UART_TxIntMode
                                        (0064) export _UART_TxIntMode
                                        (0065) 
                                        (0066) export  UART_PutSHexByte
                                        (0067) export _UART_PutSHexByte
                                        (0068) export  UART_PutSHexInt
                                        (0069) export _UART_PutSHexInt
                                        (0070) 
                                        (0071) export  UART_CPutString
                                        (0072) export _UART_CPutString
                                        (0073) export  UART_PutString
                                        (0074) export _UART_PutString
                                        (0075) export  UART_PutChar
                                        (0076) export _UART_PutChar
                                        (0077) export  UART_Write
                                        (0078) export _UART_Write
                                        (0079) export  UART_CWrite
                                        (0080) export _UART_CWrite
                                        (0081) 
                                        (0082) export  UART_cGetChar
                                        (0083) export _UART_cGetChar
                                        (0084) export  UART_cReadChar
                                        (0085) export _UART_cReadChar
                                        (0086) export  UART_iReadChar
                                        (0087) export _UART_iReadChar
                                        (0088) export  UART_PutCRLF
                                        (0089) export _UART_PutCRLF
                                        (0090) 
                                        (0091) IF (UART_RXBUF_ENABLE)
                                        (0092) export  UART_CmdReset
                                        (0093) export _UART_CmdReset
                                        (0094) export  UART_bCmdCheck
                                        (0095) export _UART_bCmdCheck
                                        (0096) export  UART_bCmdLength
                                        (0097) export _UART_bCmdLength
                                        (0098) export  UART_bErrCheck
                                        (0099) export _UART_bErrCheck
                                        (0100) 
                                        (0101) export  UART_szGetParam
                                        (0102) export _UART_szGetParam
                                        (0103) export  UART_szGetRestOfParams
                                        (0104) export _UART_szGetRestOfParams
                                        (0105) ENDIF
                                        (0106) 
                                        (0107) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        (0108) ; WARNING WARNING WARNING
                                        (0109) ; The following exports are for backwards compatibility only and should
                                        (0110) ; not be used for new designs. They may be eliminated in a future release.
                                        (0111) ; Their status is "NO FURTHER MAINTENANCE". 
                                        (0112) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        (0113) export  bUART_ReadTxStatus
                                        (0114) export _bUART_ReadTxStatus
                                        (0115) export  bUART_ReadRxData
                                        (0116) export _bUART_ReadRxData
                                        (0117) export  bUART_ReadRxStatus
                                        (0118) export _bUART_ReadRxStatus
                                        (0119) 	
                                        (0120) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        (0121) ;             END WARNING
                                        (0122) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        (0123) 
                                        (0124) ;-----------------------------------------------
                                        (0125) ; Variable Allocation
                                        (0126) ;-----------------------------------------------
                                        (0127) IF (UART_RXBUF_ENABLE)
                                        (0128)     
                                        (0129) area UART_RAM (RAM, REL, CON)
                                        (0130)     
                                        (0131)  ptrParam:   BLK  1
                                        (0132) 
                                        (0133) ENDIF
                                        (0134) 
                                        (0135) area text (ROM,REL)
                                        (0136) 
                                        (0137) ;-----------------------------------------------
                                        (0138) ;  EQUATES
                                        (0139) ;-----------------------------------------------
                                        (0140) bfCONTROL_REG_START_BIT:        equ    1    ; Control register start bit
                                        (0141) bfFUNCTION_REG_TX_INT_MODE_BIT: equ 0x10    ; the TX Int Mode bit
                                        (0142) 
                                        (0143) area UserModules (ROM, REL, CON)
                                        (0144) 
                                        (0145) ;=============================================================================
                                        (0146) ;=============================================================================
                                        (0147) ;
                                        (0148) ;     Low-Level Commands
                                        (0149) ;
                                        (0150) ;=============================================================================
                                        (0151) ;=============================================================================
                                        (0152) 
                                        (0153) .SECTION
                                        (0154) ;-----------------------------------------------------------------------------
                                        (0155) ;  FUNCTION NAME: UART_EnableInt
                                        (0156) ;
                                        (0157) ;  DESCRIPTION:
                                        (0158) ;     Enables this UART's interrupt by setting the interrupt enable mask
                                        (0159) ;     bit associated with this User Module. Remember to call the global
                                        (0160) ;     interrupt enable function by using the macro: M8C_EnableGInt.
                                        (0161) ;-----------------------------------------------------------------------------
                                        (0162) ;
                                        (0163) ;  ARGUMENTS:
                                        (0164) ;     none.
                                        (0165) ;
                                        (0166) ;  RETURNS:
                                        (0167) ;     none.
                                        (0168) ;
                                        (0169) ;  SIDE EFFECTS:
                                        (0170) ;    The A and X registers may be modified by this or future implementations
                                        (0171) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0172) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0173) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0174) ;    functions.
                                        (0175) ;
                                        (0176)  UART_EnableInt:
                                        (0177) _UART_EnableInt:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0179)    M8C_EnableIntMask UART_TX_INT_REG, UART_TX_INT_MASK
                                        (0180)    M8C_EnableIntMask UART_RX_INT_REG, UART_RX_INT_MASK
                                        (0181)    RAM_EPILOGUE RAM_USE_CLASS_1
0840: 7F       RET                      (0182)    ret
0841: 41 E1 BF AND   REG[0xE1],0xBF     
0844: 41 E1 7F AND   REG[0xE1],0x7F     
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185)     
                                        (0186) .SECTION
                                        (0187) ;-----------------------------------------------------------------------------
                                        (0188) ;  FUNCTION NAME: UART_DisableInt
                                        (0189) ;
                                        (0190) ;  DESCRIPTION:
                                        (0191) ;     Disables this UART's interrupt by clearing the interrupt enable mask bit
                                        (0192) ;     associated with this User Module.
                                        (0193) ;-----------------------------------------------------------------------------
                                        (0194) ;
                                        (0195) ;  ARGUMENTS:
                                        (0196) ;     none.
                                        (0197) ;
                                        (0198) ;  RETURNS:
                                        (0199) ;     none.
                                        (0200) ;
                                        (0201) ;  SIDE EFFECTS:
                                        (0202) ;    The A and X registers may be modified by this or future implementations
                                        (0203) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0204) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0205) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0206) ;    functions.
                                        (0207) ;
                                        (0208)  UART_DisableInt:
                                        (0209) _UART_DisableInt:
                                        (0210)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0211)    M8C_DisableIntMask UART_TX_INT_REG, UART_TX_INT_MASK
                                        (0212)    M8C_DisableIntMask UART_RX_INT_REG, UART_RX_INT_MASK
                                        (0213)    RAM_EPILOGUE RAM_USE_CLASS_1
0847: 7F       RET                      (0214)    ret
0848: 71 10    OR    F,0x10             
                                        (0215) .ENDSECTION
                                        (0216) 
                                        (0217) 
                                        (0218) .SECTION
                                        (0219) ;-----------------------------------------------------------------------------
                                        (0220) ;  FUNCTION NAME: UART_SetTxIntMode(BYTE bTxIntMode)
                                        (0221) ;
                                        (0222) ;  DESCRIPTION:
                                        (0223) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                        (0224) ;-----------------------------------------------------------------------------
                                        (0225) ;
                                        (0226) ;  ARGUMENTS:
                                        (0227) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                        (0228) ;        Passed in the A register
                                        (0229) ;
                                        (0230) ;  RETURNS:
                                        (0231) ;     none.
                                        (0232) ;
                                        (0233) ;  SIDE EFFECTS:
                                        (0234) ;    The A and X registers may be modified by this or future implementations
                                        (0235) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0236) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0237) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0238) ;    functions.
                                        (0239) ;
                                        (0240) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0241) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                        (0242) ;     on TX register empty or TX transmit complete
                                        (0243) ;
                                        (0244)  UART_SetTxIntMode:
                                        (0245) _UART_SetTxIntMode:
                                        (0246)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0247)    M8C_SetBank1
084A: 21 01    AND   A,0x1              (0248)    and   A, UART_INT_MODE_TX_COMPLETE
084C: A0 07    JZ    0x0854             (0249)    jz    .SetModeRegEmpty
084E: 43 38 10 OR    REG[0x38],0x10     (0250)    or    REG[UART_TX_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
0851: 70 EF    AND   F,0xEF             
                                        (0251)    M8C_SetBank0
                                        (0252)    RAM_EPILOGUE RAM_USE_CLASS_1
0853: 7F       RET                      (0253)    ret
                                        (0254) 
                                        (0255) .SetModeRegEmpty:
0854: 41 38 EF AND   REG[0x38],0xEF     (0256)    and   REG[UART_TX_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
0857: 70 EF    AND   F,0xEF             
                                        (0257)    M8C_SetBank0
                                        (0258)    RAM_EPILOGUE RAM_USE_CLASS_1
0859: 7F       RET                      (0259)    ret
                                        (0260) .ENDSECTION
                                        (0261) 
                                        (0262) 
                                        (0263) .SECTION
                                        (0264) ;-----------------------------------------------------------------------------
                                        (0265) ;  FUNCTION NAME: UART_Start(BYTE bParity)
                                        (0266) ;
                                        (0267) ;  DESCRIPTION:
                                        (0268) ;     Sets the start bit and parity in the Control register of this user module.
                                        (0269) ;-----------------------------------------------------------------------------
                                        (0270) ;
                                        (0271) ;  ARGUMENTS:
                                        (0272) ;     BYTE bParity - parity setting for the Transmitter and receiver. Use defined masks.
                                        (0273) ;        Passed in the A register.
                                        (0274) ;
                                        (0275) ;  RETURNS:
                                        (0276) ;     none.
                                        (0277) ;
                                        (0278) ;  SIDE EFFECTS:
                                        (0279) ;    The A and X registers may be modified by this or future implementations
                                        (0280) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0281) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0282) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0283) ;    functions.
                                        (0284) ;
                                        (0285)  UART_Start:
                                        (0286) _UART_Start:
                                        (0287)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0288)    ; Note, Proxy Class 4 only if receive buffer used; otherwise Proxy Class 1.
                                        (0289) 
085A: 29 01    OR    A,0x1              (0290)    or    A, bfCONTROL_REG_START_BIT
085C: 60 3B    MOV   REG[0x3B],A        (0291)    mov   REG[UART_TX_CONTROL_REG], A
085E: 60 3F    MOV   REG[0x3F],A        (0292)    mov   REG[UART_RX_CONTROL_REG], A
                                        (0293) IF ( UART_RXBUF_ENABLE )
0860: 91 2A    CALL  _UART_CmdReset     (0294)    call  _UART_CmdReset
                                        (0295) ENDIF
                                        (0296)    RAM_EPILOGUE RAM_USE_CLASS_1
0862: 7F       RET                      (0297)    ret
                                        (0298) .ENDSECTION
                                        (0299) 
                                        (0300) 
                                        (0301) .SECTION
                                        (0302) ;-----------------------------------------------------------------------------
                                        (0303) ;  FUNCTION NAME: UART_Stop
                                        (0304) ;
                                        (0305) ;  DESCRIPTION:
                                        (0306) ;     Disables UART operation.
                                        (0307) ;-----------------------------------------------------------------------------
                                        (0308) ;
                                        (0309) ;  ARGUMENTS:
                                        (0310) ;     none.
                                        (0311) ;
                                        (0312) ;  RETURNS:
                                        (0313) ;     none.
                                        (0314) ;
                                        (0315) ;  SIDE EFFECTS:
                                        (0316) ;    The A and X registers may be modified by this or future implementations
                                        (0317) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0318) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0319) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0320) ;    functions.
                                        (0321) ;
                                        (0322)  UART_Stop:
                                        (0323) _UART_Stop:
                                        (0324)    RAM_PROLOGUE RAM_USE_CLASS_1
0863: 41 3B FE AND   REG[0x3B],0xFE     (0325)    and   REG[UART_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
0866: 41 3F FE AND   REG[0x3F],0xFE     (0326)    and   REG[UART_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                        (0327)    RAM_EPILOGUE RAM_USE_CLASS_1
0869: 7F       RET                      (0328)    ret
                                        (0329) .ENDSECTION
                                        (0330) 
                                        (0331) 
                                        (0332) .SECTION
                                        (0333) ;-----------------------------------------------------------------------------
                                        (0334) ;  FUNCTION NAME: UART_SendData
                                        (0335) ;
                                        (0336) ;  DESCRIPTION:
                                        (0337) ;     Initiates a transmission of data.
                                        (0338) ;-----------------------------------------------------------------------------
                                        (0339) ;
                                        (0340) ;  ARGUMENTS:
                                        (0341) ;     BYTE  TxData - data to transmit. PASSED in A register.
                                        (0342) ;
                                        (0343) ;  RETURNS:
                                        (0344) ;     none.
                                        (0345) ;
                                        (0346) ;  SIDE EFFECTS:
                                        (0347) ;    The A and X registers may be modified by this or future implementations
                                        (0348) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0349) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0350) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0351) ;    functions.
                                        (0352) ;
                                        (0353)  UART_SendData:
                                        (0354) _UART_SendData:
                                        (0355)    RAM_PROLOGUE RAM_USE_CLASS_1
086A: 60 39    MOV   REG[0x39],A        (0356)    mov REG[UART_TX_BUFFER_REG], A
                                        (0357)    RAM_EPILOGUE RAM_USE_CLASS_1
086C: 7F       RET                      (0358)    ret
                                        (0359) .ENDSECTION
                                        (0360) 
                                        (0361) 
                                        (0362) .SECTION
                                        (0363) ;-----------------------------------------------------------------------------
                                        (0364) ;  FUNCTION NAME: UART_bReadTxStatus
                                        (0365) ;
                                        (0366) ;  DESCRIPTION:
                                        (0367) ;     Reads the Tx Status bits in the Control/Status register.
                                        (0368) ;-----------------------------------------------------------------------------
                                        (0369) ;
                                        (0370) ;  ARGUMENTS:
                                        (0371) ;     none.
                                        (0372) ;
                                        (0373) ;  RETURNS:
                                        (0374) ;     BYTE  bTxStatus - transmit status data.  Use defined masks for detecting
                                        (0375) ;           status bits (returned in A)
                                        (0376) ;
                                        (0377) ;  SIDE EFFECTS:
                                        (0378) ;    The A and X registers may be modified by this or future implementations
                                        (0379) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0380) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0381) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0382) ;    functions.
                                        (0383) ;
                                        (0384)  UART_bReadTxStatus:
                                        (0385) _UART_bReadTxStatus:
                                        (0386)  bUART_ReadTxStatus:                             ; For backwards compatibility only
                                        (0387) _bUART_ReadTxStatus:                             ; For backwards compatibility only
                                        (0388)    RAM_PROLOGUE RAM_USE_CLASS_1
086D: 5D 3B    MOV   A,REG[0x3B]        (0389)    mov A,  REG[UART_TX_CONTROL_REG]
                                        (0390)    RAM_EPILOGUE RAM_USE_CLASS_1
086F: 7F       RET                      (0391)    ret
                                        (0392) .ENDSECTION
                                        (0393) 
                                        (0394) 
                                        (0395) .SECTION
                                        (0396) ;-----------------------------------------------------------------------------
                                        (0397) ;  FUNCTION NAME: UART_bReadRxData
                                        (0398) ;
                                        (0399) ;  DESCRIPTION:
                                        (0400) ;     Reads the RX buffer register.  Should check the status regiser to make
                                        (0401) ;     sure data is valid.
                                        (0402) ;-----------------------------------------------------------------------------
                                        (0403) ;
                                        (0404) ;  ARGUMENTS:
                                        (0405) ;     none.
                                        (0406) ;
                                        (0407) ;  RETURNS:
                                        (0408) ;     bRxData - returned in A.
                                        (0409) ;
                                        (0410) ;  SIDE EFFECTS:
                                        (0411) ;    The A and X registers may be modified by this or future implementations
                                        (0412) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0413) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0414) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0415) ;    functions.
                                        (0416) ;
                                        (0417)  UART_bReadRxData:
                                        (0418) _UART_bReadRxData:
                                        (0419)  bUART_ReadRxData:                               ; For backwards compatibility only
                                        (0420) _bUART_ReadRxData:                               ; For backwards compatibility only
                                        (0421)    RAM_PROLOGUE RAM_USE_CLASS_1
0870: 5D 3E    MOV   A,REG[0x3E]        (0422)    mov A, REG[UART_RX_BUFFER_REG]
                                        (0423)    RAM_EPILOGUE RAM_USE_CLASS_1
0872: 7F       RET                      (0424)    ret
                                        (0425) .ENDSECTION
                                        (0426) 
                                        (0427) 
                                        (0428) .SECTION
                                        (0429) ;-----------------------------------------------------------------------------
                                        (0430) ;  FUNCTION NAME: UART_bReadRxStatus
                                        (0431) ;
                                        (0432) ;  DESCRIPTION:
                                        (0433) ;     Reads the RX Status bits in the Control/Status register.
                                        (0434) ;-----------------------------------------------------------------------------
                                        (0435) ;
                                        (0436) ;  ARGUMENTS:
                                        (0437) ;     none.
                                        (0438) ;
                                        (0439) ;  RETURNS:
                                        (0440) ;     BYTE  bRXStatus - receive status data.  Use the following defined bits
                                        (0441) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                        (0442) ;           returned in A.
                                        (0443) ;
                                        (0444) ;  SIDE EFFECTS:
                                        (0445) ;    The A and X registers may be modified by this or future implementations
                                        (0446) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0447) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0448) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0449) ;    functions.
                                        (0450) ;
                                        (0451)  UART_bReadRxStatus:
                                        (0452) _UART_bReadRxStatus:
                                        (0453)  bUART_ReadRxStatus:                             ; For backwards compatibility only
                                        (0454) _bUART_ReadRxStatus:                             ; For backwards compatibility only
                                        (0455)    RAM_PROLOGUE RAM_USE_CLASS_1
0873: 5D 3F    MOV   A,REG[0x3F]        (0456)    mov A,  REG[UART_RX_CONTROL_REG]
                                        (0457)    RAM_EPILOGUE RAM_USE_CLASS_1
0875: 7F       RET                      (0458)    ret
                                        (0459) .ENDSECTION
                                        (0460) 
                                        (0461) 
                                        (0462) .SECTION
                                        (0463) ;-----------------------------------------------------------------------------
                                        (0464) ;  FUNCTION NAME: UART_TxIntMode
                                        (0465) ;
                                        (0466) ;  DESCRIPTION:
                                        (0467) ;     This function is used to change the TX Interrupt mode.
                                        (0468) ;-----------------------------------------------------------------------------
                                        (0469) ;
                                        (0470) ;  ARGUMENTS:
                                        (0471) ;     A => Tx Interrupt mode
                                        (0472) ;             0 => Interrupt on TX_Reg_Empty  (Default)
                                        (0473) ;             1 => Interrupt on TX Complete
                                        (0474) ;
                                        (0475) ;  RETURNS:
                                        (0476) ;     none.
                                        (0477) ;
                                        (0478) ;  SIDE EFFECTS:
                                        (0479) ;    The A and X registers may be modified by this or future implementations
                                        (0480) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0481) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0482) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0483) ;    functions.
                                        (0484) ;
                                        (0485)  UART_TxIntMode:
                                        (0486) _UART_TxIntMode:
                                        (0487)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0488) 
0876: 21 01    AND   A,0x1              (0489)    and  A,UART_INT_MODE_TX_COMPLETE
0878: 71 10    OR    F,0x10             
                                        (0490)    M8C_SetBank1
087A: 39 01    CMP   A,0x1              (0491)    cmp  A,UART_INT_MODE_TX_COMPLETE
087C: A0 06    JZ    0x0883             (0492)    jz   .SetTxCmpMode
                                        (0493) 
087E: 41 38 EF AND   REG[0x38],0xEF     (0494)    and  reg[UART_TX_FUNC_REG],0xEF               ; Set Interrupt on Tx_Reg_Empty
0881: 80 04    JMP   0x0886             (0495)    jmp  .TxIntMode_End
                                        (0496) 
                                        (0497) .SetTxCmpMode:                                       ; Set Interrupt on TX Complete
0883: 43 38 10 OR    REG[0x38],0x10     (0498)    or   reg[UART_TX_FUNC_REG],0x10
0886: 70 EF    AND   F,0xEF             
                                        (0499) 
                                        (0500) .TxIntMode_End:
                                        (0501)    M8C_SetBank0
                                        (0502)    RAM_EPILOGUE RAM_USE_CLASS_1
0888: 7F       RET                      (0503)    ret
                                        (0504) .ENDSECTION
                                        (0505) 
                                        (0506)     
                                        (0507) .SECTION
                                        (0508) ;-----------------------------------------------------------------------------
                                        (0509) ;  FUNCTION NAME: UART_IntCntl
                                        (0510) ;
                                        (0511) ;  DESCRIPTION:
                                        (0512) ;     This function is used to enable/disable the Rx and Tx interrupt.
                                        (0513) ;-----------------------------------------------------------------------------
                                        (0514) ;
                                        (0515) ;  ARGUMENTS:
                                        (0516) ;     A => Interrupt mask
                                        (0517) ;
                                        (0518) ;  RETURNS:
                                        (0519) ;     none.
                                        (0520) ;
                                        (0521) ;  SIDE EFFECTS:
                                        (0522) ;    The A and X registers may be modified by this or future implementations
                                        (0523) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0524) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0525) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0526) ;    functions.
                                        (0527) ;
                                        (0528) ;  THEORY of OPERATION or PROCEDURE:
                                        (0529) ;     Set or Clears the Tx/Rx user module interrupt enable mask bit in the TX
                                        (0530) ;     and RX block.
                                        (0531) ;
                                        (0532)  UART_IntCntl:
                                        (0533) _UART_IntCntl:
                                        (0534)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0535) 
0889: 08       PUSH  A                  (0536)    push A
088A: 21 01    AND   A,0x1              (0537)    and  A,UART_ENABLE_RX_INT
088C: A0 06    JZ    0x0893             (0538)    jz   .DisRxInt
088E: 43 E1 80 OR    REG[0xE1],0x80     
                                        (0539)      ; Enable Rx Interrupt
                                        (0540)    M8C_EnableIntMask UART_RX_INT_REG, UART_RX_INT_MASK
0891: 80 04    JMP   0x0896             (0541)    jmp  .CheckTxInt
0893: 41 E1 7F AND   REG[0xE1],0x7F     
                                        (0542) .DisRxInt:
                                        (0543)      ; Disable Rx Interrupt
                                        (0544)    M8C_DisableIntMask UART_RX_INT_REG, UART_RX_INT_MASK
                                        (0545) 
                                        (0546) .CheckTxInt:
0896: 18       POP   A                  (0547)    pop  A
0897: 21 02    AND   A,0x2              (0548)    and  A,UART_ENABLE_TX_INT
0899: A0 06    JZ    0x08A0             (0549)    jz   .DisTxInt
089B: 43 E1 40 OR    REG[0xE1],0x40     
                                        (0550)      ; Enable Tx Interrupt
                                        (0551)    M8C_EnableIntMask UART_TX_INT_REG, UART_TX_INT_MASK
089E: 80 04    JMP   0x08A3             (0552)    jmp  .End_IntCntl
08A0: 41 E1 BF AND   REG[0xE1],0xBF     
                                        (0553) .DisTxInt:
                                        (0554)      ; Disable Tx Interrupt
                                        (0555)    M8C_DisableIntMask UART_TX_INT_REG, UART_TX_INT_MASK
                                        (0556) 
                                        (0557) .End_IntCntl:
                                        (0558)    RAM_EPILOGUE RAM_USE_CLASS_1
08A3: 7F       RET                      (0559)    ret
                                        (0560) .ENDSECTION
                                        (0561) 
                                        (0562) 
                                        (0563) ;=============================================================================
                                        (0564) ;=============================================================================
                                        (0565) ;
                                        (0566) ;     High-Level Commands
                                        (0567) ;
                                        (0568) ;=============================================================================
                                        (0569) ;=============================================================================
                                        (0570) 
                                        (0571) 
                                        (0572) ;-----------------------------------------------------------------------------
                                        (0573) ;  FUNCTION NAME: UART_PutSHexByte
                                        (0574) ;
                                        (0575) ;  DESCRIPTION:
                                        (0576) ;     Print a byte in Hex (two characters) to the UART Tx
                                        (0577) ;-----------------------------------------------------------------------------
                                        (0578) ;
                                        (0579) ;  ARGUMENTS:
                                        (0580) ;     A  => (BYTE) Data/char to be printed
                                        (0581) ;
                                        (0582) ;  RETURNS:
                                        (0583) ;     none.
                                        (0584) ;
                                        (0585) ;  SIDE EFFECTS:
                                        (0586) ;    The A and X registers may be modified by this or future implementations
                                        (0587) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0588) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0589) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0590) ;    functions.
                                        (0591) ;
                                        (0592) .LITERAL
                                        (0593) UART_HEX_STR:
                                        (0594)      DS    "0123456789ABCDEF"
                                        (0595) .ENDLITERAL
                                        (0596) 
                                        (0597) .SECTION
                                        (0598)  UART_PutSHexByte:
                                        (0599) _UART_PutSHexByte:
                                        (0600)    RAM_PROLOGUE RAM_USE_CLASS_1
08B4: 08       PUSH  A                  (0601)    push  A                             ; Save lower nibble
08B5: 67       ASR   A                  (0602)    asr   A                             ; Shift high nibble to right
08B6: 67       ASR   A                  (0603)    asr   A
08B7: 67       ASR   A                  (0604)    asr   A
08B8: 67       ASR   A                  (0605)    asr   A
08B9: 21 0F    AND   A,0xF              (0606)    and   A,0Fh                         ; Mask off nibble
08BB: FF E7    INDEX 0x08A4             (0607)    index UART_HEX_STR                  ; Get Hex value
08BD: 90 0F    CALL  _UART_PutChar      (0608)    call  UART_PutChar                  ; Write data to screen
08BF: 18       POP   A                  (0609)    pop   A                             ; Restore value
08C0: 21 0F    AND   A,0xF              (0610)    and   A,0Fh                         ; Mask off lower nibble
08C2: FF E0    INDEX 0x08A4             (0611)    index UART_HEX_STR                  ; Get Hex value
08C4: 90 08    CALL  _UART_PutChar      (0612)    call  UART_PutChar                  ; Write data to screen
                                        (0613)    RAM_EPILOGUE RAM_USE_CLASS_1
08C6: 7F       RET                      (0614)    ret
                                        (0615) .ENDSECTION
                                        (0616) 
                                        (0617) 
                                        (0618) .SECTION
                                        (0619) ;-----------------------------------------------------------------------------
                                        (0620) ;  FUNCTION NAME: UART_PutSHexInt
                                        (0621) ;
                                        (0622) ;  DESCRIPTION:
                                        (0623) ;     Print an Int in Hex (four characters) to UART Tx
                                        (0624) ;-----------------------------------------------------------------------------
                                        (0625) ;
                                        (0626) ;  ARGUMENTS:
                                        (0627) ;     Pointer to string
                                        (0628) ;     A  => ASB of Int
                                        (0629) ;     X  => MSB of Int
                                        (0630) ;
                                        (0631) ;  RETURNS:
                                        (0632) ;     none.
                                        (0633) ;
                                        (0634) ;  SIDE EFFECTS:
                                        (0635) ;    The A and X registers may be modified by this or future implementations
                                        (0636) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0637) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0638) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0639) ;    functions.
                                        (0640) ;
                                        (0641) 
                                        (0642)  UART_PutSHexInt:
                                        (0643) _UART_PutSHexInt:
                                        (0644)    RAM_PROLOGUE RAM_USE_CLASS_1
08C7: 4B       SWAP  A,X                (0645)    swap  A,X
08C8: 9F EA    CALL  _UART_PutSHexByte  (0646)    call  UART_PutSHexByte              ; Print MSB
08CA: 5B       MOV   A,X                (0647)    mov   A,X                           ; Move LSB into position
08CB: 9F E7    CALL  _UART_PutSHexByte  (0648)    call  UART_PutSHexByte              ; Print LSB
                                        (0649)    RAM_EPILOGUE RAM_USE_CLASS_1
08CD: 7F       RET                      (0650)    ret
08CE: 49 3B 10 TST   REG[0x3B],0x10     
08D1: AF FC    JZ    _UART_PutChar      
08D3: 60 39    MOV   REG[0x39],A        
                                        (0651) .ENDSECTION
                                        (0652) 
                                        (0653) 
                                        (0654) .SECTION
                                        (0655) ;-----------------------------------------------------------------------------
                                        (0656) ;  FUNCTION NAME: UART_PutChar
                                        (0657) ;
                                        (0658) ;  DESCRIPTION:
                                        (0659) ;     Send character out through UART TX port.
                                        (0660) ;-----------------------------------------------------------------------------
                                        (0661) ;
                                        (0662) ;  ARGUMENTS:
                                        (0663) ;     A has Character to send to UART Tx Port
                                        (0664) ;
                                        (0665) ;  RETURNS:
                                        (0666) ;     none
                                        (0667) ;
                                        (0668) ;  SIDE EFFECTS:
                                        (0669) ;    The A and X registers may be modified by this or future implementations
                                        (0670) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0671) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0672) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0673) ;    functions.
                                        (0674) ;
                                        (0675) 
                                        (0676)    macro InLinePutChar( Source )
                                        (0677) .BufEmptyWaitLoop:
                                        (0678)    tst REG[UART_TX_CONTROL_REG], UART_TX_BUFFER_EMPTY     ; Check Tx Status
                                        (0679)    jz  .BufEmptyWaitLoop
                                        (0680)    mov REG[UART_TX_BUFFER_REG], @Source          ; Write data to Tx Port
                                        (0681)    endm
                                        (0682) 
                                        (0683)  UART_PutChar:
                                        (0684) _UART_PutChar:
                                        (0685)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0686)    InLinePutChar A
                                        (0687)    RAM_EPILOGUE RAM_USE_CLASS_1
08D5: 7F       RET                      (0688)    ret
                                        (0689) .ENDSECTION
                                        (0690) 
                                        (0691) 
                                        (0692) .SECTION
                                        (0693) ;-----------------------------------------------------------------------------
                                        (0694) ;  FUNCTION NAME: UART_cGetChar
                                        (0695) ;
                                        (0696) ;  DESCRIPTION:
                                        (0697) ;     Read character from UART RX port.
                                        (0698) ;-----------------------------------------------------------------------------
                                        (0699) ;
                                        (0700) ;  ARGUMENTS:
                                        (0701) ;      none
                                        (0702) ;
                                        (0703) ;  RETURNS:
                                        (0704) ;     char that is returned from UART
                                        (0705) ;
                                        (0706) ;  SIDE EFFECTS:
                                        (0707) ;    The A and X registers may be modified by this or future implementations
                                        (0708) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0709) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0710) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0711) ;    functions.
                                        (0712) ;
                                        (0713) ;    Program flow will stay in this function until a character is received.
                                        (0714) ;    If the watchdog timer is used, care must be taken to make sure that
                                        (0715) ;    the delay between characters is less than the watchdog timeout.
                                        (0716) ;
                                        (0717)  UART_cGetChar:
                                        (0718) _UART_cGetChar:
                                        (0719)    RAM_PROLOGUE RAM_USE_CLASS_1
08D6: 49 3F 08 TST   REG[0x3F],0x8      (0720)    tst REG[UART_RX_CONTROL_REG],UART_RX_REG_FULL    ; Check if a character is ready
08D9: AF FC    JZ    _UART_cGetChar     (0721)    jz  UART_cGetChar                             ; If not loop
08DB: 5D 3E    MOV   A,REG[0x3E]        (0722)    mov A, REG[UART_RX_BUFFER_REG]                ; Get character
                                        (0723)    RAM_EPILOGUE RAM_USE_CLASS_1
08DD: 7F       RET                      (0724)    ret
                                        (0725) .ENDSECTION
                                        (0726) 
                                        (0727) 
                                        (0728) .SECTION
                                        (0729) ;-----------------------------------------------------------------------------
                                        (0730) ;  FUNCTION NAME: UART_cReadChar
                                        (0731) ;
                                        (0732) ;  DESCRIPTION:
                                        (0733) ;     Read character from UART RX port.
                                        (0734) ;-----------------------------------------------------------------------------
                                        (0735) ;
                                        (0736) ;  ARGUMENTS:
                                        (0737) ;      none
                                        (0738) ;
                                        (0739) ;  RETURNS:
                                        (0740) ;     char that is returned from UART
                                        (0741) ;
                                        (0742) ;  SIDE EFFECTS:
                                        (0743) ;    The A and X registers may be modified by this or future implementations
                                        (0744) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0745) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0746) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0747) ;    functions.
                                        (0748) ;
                                        (0749) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                        (0750) ;    implies a valid character or an error condition occured.
                                        (0751) ;
                                        (0752)  UART_cReadChar:
                                        (0753) _UART_cReadChar:
                                        (0754)    RAM_PROLOGUE RAM_USE_CLASS_1
08DE: 5D 3F    MOV   A,REG[0x3F]        (0755)    mov  A,REG[UART_RX_CONTROL_REG]                         ; Get Status of RX
08E0: 08       PUSH  A                  (0756)    push A
08E1: 21 08    AND   A,0x8              (0757)    and  A,UART_RX_COMPLETE                                 ; Check if a character is ready
08E3: B0 04    JNZ   0x08E8             (0758)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
08E5: 18       POP   A                  (0759)    pop  A
08E6: 80 0B    JMP   0x08F2             (0760)    jmp  .RX_NO_VALID_CHAR
                                        (0761) 
                                        (0762) .RX_DATA_RDY:
08E8: 5D 3E    MOV   A,REG[0x3E]        (0763)    mov  A,REG[UART_RX_BUFFER_REG ]          
08EA: 4B       SWAP  A,X                (0764)    swap A,X                                                ; determine if data is valid
                                        (0765) 
08EB: 18       POP   A                  (0766)    pop  A                                                  ; Check for errors
08EC: 21 A0    AND   A,0xA0             (0767)    and  A,(UART_RX_PARITY_ERROR | UART_RX_FRAMING_ERROR)
08EE: B0 03    JNZ   0x08F2             (0768)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
08F0: 4B       SWAP  A,X                (0769)    swap A,X                                                ; Put data in A and exit
                                        (0770)    RAM_EPILOGUE RAM_USE_CLASS_1
08F1: 7F       RET                      (0771)    ret
                                        (0772) 
                                        (0773) .RX_NO_VALID_CHAR:
08F2: 50 00    MOV   A,0x0              (0774)    mov A,0x00                                              ; Zero out character
                                        (0775) 
                                        (0776)  End_UART_cReadChar:
                                        (0777)    RAM_EPILOGUE RAM_USE_CLASS_1
08F4: 7F       RET                      (0778)    ret
                                        (0779) .ENDSECTION
                                        (0780) 
                                        (0781) 
                                        (0782) .SECTION
                                        (0783) ;-----------------------------------------------------------------------------
                                        (0784) ;  FUNCTION NAME: UART_iReadChar
                                        (0785) ;
                                        (0786) ;  WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                        (0787) ;  to just set a value in the upper byte if error conditions exists.
                                        (0788) ;
                                        (0789) ;  DESCRIPTION:
                                        (0790) ;     Read character from UART RX port.
                                        (0791) ;-----------------------------------------------------------------------------
                                        (0792) ;
                                        (0793) ;  ARGUMENTS:
                                        (0794) ;      none
                                        (0795) ;
                                        (0796) ;  RETURNS:
                                        (0797) ;     An integer value is returned.  A negative value inplies and error
                                        (0798) ;     condition, a positive value between 0 and 255 is the return character.
                                        (0799) ;
                                        (0800) ;     Error Codes:
                                        (0801) ;        0x80CC    Parity Error
                                        (0802) ;        0x40CC    Overrun Error
                                        (0803) ;        0x20CC    Framing Error
                                        (0804) ;        0x01CC    No Data available
                                        (0805) ;
                                        (0806) ;  SIDE EFFECTS:
                                        (0807) ;    The A and X registers may be modified by this or future implementations
                                        (0808) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0809) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0810) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0811) ;    functions.
                                        (0812) ;
                                        (0813)  UART_iReadChar:
                                        (0814) _UART_iReadChar:
                                        (0815)    RAM_PROLOGUE RAM_USE_CLASS_1
08F5: 5D 3F    MOV   A,REG[0x3F]        (0816)    mov  A,REG[UART_RX_CONTROL_REG]                         ; Get Status of RX
                                        (0817)                                                            ; Mask only errors and data ready
08F7: 21 E8    AND   A,0xE8             (0818)    and  A,(UART_RX_ERROR|UART_RX_REG_FULL)
08F9: 08       PUSH  A                  (0819)    push A
08FA: 21 08    AND   A,0x8              (0820)    and  A,UART_RX_COMPLETE                                 ; Check if a character is ready
08FC: B0 07    JNZ   0x0904             (0821)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
08FE: 18       POP   A                  (0822)    pop  A
08FF: 29 01    OR    A,0x1              (0823)    or   A,UART_RX_NO_DATA                                  ; Add no data flag
0901: 4B       SWAP  A,X                (0824)    swap A,X
0902: 80 07    JMP   0x090A             (0825)    jmp  End_UART_iReadChar
                                        (0826) 
                                        (0827) .RX_GET_DATA:
0904: 18       POP   A                  (0828)    pop  A
0905: 21 E0    AND   A,0xE0             (0829)    and  A,UART_RX_ERROR
0907: 4B       SWAP  A,X                (0830)    swap A,X
0908: 5D 3E    MOV   A,REG[0x3E]        (0831)    mov  A,REG[UART_RX_BUFFER_REG ]                         ; Read data first, then
                                        (0832)                                                            ; determine if data is valid
                                        (0833) 
                                        (0834)  End_UART_iReadChar:
                                        (0835)    RAM_EPILOGUE RAM_USE_CLASS_1
090A: 7F       RET                      (0836)    ret
090B: 70 BF    AND   F,0xBF             
090D: 60 D3    MOV   REG[0xD3],A        
                                        (0837) .ENDSECTION
                                        (0838) 
                                        (0839) 
                                        (0840) .SECTION
                                        (0841) ;-----------------------------------------------------------------------------
                                        (0842) ;  FUNCTION NAME: UART_PutString
                                        (0843) ;
                                        (0844) ;  DESCRIPTION:
                                        (0845) ;     Send String out through UART TX port.
                                        (0846) ;-----------------------------------------------------------------------------
                                        (0847) ;
                                        (0848) ;  ARGUMENTS:
                                        (0849) ;     Pointer to String
                                        (0850) ;     A has MSB of string address
                                        (0851) ;     X has LSB of string address
                                        (0852) ;
                                        (0853) ;  RETURNS:
                                        (0854) ;     none
                                        (0855) ;
                                        (0856) ;  SIDE EFFECTS:
                                        (0857) ;    The A and X registers may be modified by this or future implementations
                                        (0858) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0859) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0860) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0861) ;    functions.
                                        (0862) ;          
                                        (0863) ;    Currently only the page pointer registers listed below are modified: 
                                        (0864) ;          IDX_PP
                                        (0865) ;
                                        (0866)  UART_PutString:
                                        (0867) _UART_PutString:
                                        (0868)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0869)    RAM_SETPAGE_IDX A
                                        (0870) .PutStringLoop:
090F: 52 00    MOV   A,[X+0]            (0871)    mov   A,[X]                                   ; Get value pointed to by X
0911: A0 06    JZ    0x0918             (0872)    jz    End_PutString                           ; Check for end of string
0913: 9F B9    CALL  _UART_PutChar      (0873)    call  UART_PutChar                            ; Send character to Tx port
0915: 75       INC   X                  (0874)    inc   X                                       ; Advance pointer to next character
0916: 8F F8    JMP   0x090F             (0875)    jmp   .PutStringLoop                          ; Get next character
0918: 70 3F    AND   F,0x3F             
091A: 71 C0    OR    F,0xC0             
                                        (0876) 
                                        (0877) End_PutString:
                                        (0878)    RAM_EPILOGUE RAM_USE_CLASS_3
091C: 7F       RET                      (0879)    ret
091D: 70 BF    AND   F,0xBF             
091F: 62 D3 07 MOV   REG[0xD3],0x7      
                                        (0880) .ENDSECTION
                                        (0881)     
                                        (0882) .SECTION
                                        (0883) ;-----------------------------------------------------------------------------
                                        (0884) ;  FUNCTION NAME: UART_Write
                                        (0885) ;
                                        (0886) ;  DESCRIPTION:
                                        (0887) ;     Send String of length X to serial port
                                        (0888) ;-----------------------------------------------------------------------------
                                        (0889) ;
                                        (0890) ;  ARGUMENTS:
                                        (0891) ;     Pointer to String
                                        (0892) ;     [SP-5] Count of characters to send
                                        (0893) ;     [SP-4] has MSB of string address
                                        (0894) ;     [SP-3] has LSB of string address
                                        (0895) ;
                                        (0896) ;  RETURNS:
                                        (0897) ;     none
                                        (0898) ;
                                        (0899) ;  SIDE EFFECTS:
                                        (0900) ;    The A and X registers may be modified by this or future implementations
                                        (0901) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0902) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0903) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0904) ;    functions.
                                        (0905) ;          
                                        (0906) ;    Currently only the page pointer registers listed below are modified: 
                                        (0907) ;          IDX_PP
                                        (0908) ;
                                        (0909) CNT_LEN:    equ -5                               ; Length of data to send
                                        (0910) STR_MSB:    equ -4                               ; MSB pointer of string 
                                        (0911) STR_LSB:    equ -3                               ; LSB pointer of string 
                                        (0912) 
                                        (0913)  UART_Write:
                                        (0914) _UART_Write:
                                        (0915)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0916)    RAM_SETPAGE_IDX2STK                           ; Refer indexed addrs to the stack
0922: 4F       MOV   X,SP               (0917)    mov   X, SP                                   ; Establish the frame pointer 
                                        (0918) 
                                        (0919) .NextByteLoop:
0923: 52 FB    MOV   A,[X-5]            (0920)    mov   A, [X+CNT_LEN]                          ; End of the string?
0925: A0 1A    JZ    0x0940             (0921)    jz    .End_Write                              ;   Yes, prepare to exit
0927: 7B FB    DEC   [X-5]              (0922)    dec   [X+CNT_LEN]                             ; Decrement counter
                                        (0923) 
                                        (0924)    IF SYSTEM_LARGE_MEMORY_MODEL
0929: 52 FC    MOV   A,[X-4]            (0925)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
                                        (0926)    ENDIF
                                        (0927) 
092B: 59 FD    MOV   X,[X-3]            (0928)    mov   X, [X+STR_LSB]                          ; Load pointer to char to send
092D: 60 D3    MOV   REG[0xD3],A        
                                        (0929)    RAM_SETPAGE_IDX A                             ; switch index pages
092F: 52 00    MOV   A,[X+0]            (0930)    mov   A, [X]                                  ; Grab the data
0931: 49 3B 10 TST   REG[0x3B],0x10     
0934: AF FC    JZ    0x0931             
0936: 60 39    MOV   REG[0x39],A        
                                        (0931)    InLinePutChar A                               ; Put data in empty TX buf reg
0938: 4F       MOV   X,SP               (0932)    mov   X, SP                                   ; Recover frame pointer
0939: 62 D3 07 MOV   REG[0xD3],0x7      
                                        (0933)    RAM_SETPAGE_IDX2STK                           ; Prepare for stack access
093C: 77 FD    INC   [X-3]              (0934)    inc   [X+STR_LSB]                             ; Point to next byte, but do not
093E: 8F E4    JMP   0x0923             (0935)    jmp   .NextByteLoop                           ;    cross RAM page boundary!
0940: 70 3F    AND   F,0x3F             
0942: 71 C0    OR    F,0xC0             
                                        (0936) 
                                        (0937) .End_Write:
                                        (0938)    RAM_EPILOGUE RAM_USE_CLASS_3
0944: 7F       RET                      (0939)    ret
                                        (0940) .ENDSECTION
                                        (0941)     
                                        (0942) 
                                        (0943) .SECTION
                                        (0944) ;-----------------------------------------------------------------------------
                                        (0945) ;  FUNCTION NAME: UART_CWrite
                                        (0946) ;
                                        (0947) ;             WARNING WARNING NOT COMPLETE
                                        (0948) ;
                                        (0949) ;  DESCRIPTION:
                                        (0950) ;     Send String of length X to serial port
                                        (0951) ;-----------------------------------------------------------------------------
                                        (0952) ;
                                        (0953) ;  ARGUMENTS:
                                        (0954) ;     [SP-4] MSB of Count of character to send
                                        (0955) ;     [SP-3] LSB of Count of character to send
                                        (0956) ;     [SP-2] has MSB of string address
                                        (0957) ;     [SP-1] has LSB of string address
                                        (0958) ;
                                        (0959) ;  RETURNS:
                                        (0960) ;     none
                                        (0961) ;
                                        (0962) ;  SIDE EFFECTS:
                                        (0963) ;    The A and X registers may be modified by this or future implementations
                                        (0964) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0965) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0966) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0967) ;    functions.
                                        (0968) ;
                                        (0969) CLEN_MSB:   equ -6           ; MSB Length of data to send
                                        (0970) CLEN_LSB:   equ -5           ; LSB Length of data to send
                                        (0971) CSTR_MSB:   equ -4           ; MSB pointer of string
                                        (0972) CSTR_LSB:   equ -3           ; LSB pointer of string
                                        (0973) 
                                        (0974)  UART_CWrite:
                                        (0975) _UART_CWrite:
                                        (0976)    RAM_PROLOGUE RAM_USE_CLASS_2
0945: 4F       MOV   X,SP               (0977)    mov   X,SP
                                        (0978) .CW_Loop:
0946: 3D FA 00 CMP   [X-6],0x0          (0979)    cmp   [X+CLEN_MSB],0x00                  ; Check for zero counter
0949: B0 06    JNZ   0x0950             (0980)    jnz   .CW_WRITEIT
094B: 3D FB 00 CMP   [X-5],0x0          (0981)    cmp   [X+CLEN_LSB],0x00
094E: A0 1D    JZ    0x096C             (0982)    jz    .End_CWrite                        ; Leave if done
                                        (0983) 
                                        (0984) .CW_WRITEIT:                                
0950: 10       PUSH  X                  (0985)    push  X                                  ; Save frame pointer
0951: 52 FC    MOV   A,[X-4]            (0986)    mov   A,[X+CSTR_MSB]
0953: 59 FD    MOV   X,[X-3]            (0987)    mov   X,[X+CSTR_LSB]
0955: 28       ROMX                     (0988)    romx                                     ; Get character from ROM
0956: 49 3B 10 TST   REG[0x3B],0x10     
0959: AF FC    JZ    0x0956             
095B: 60 39    MOV   REG[0x39],A        
                                        (0989)    InLinePutChar A                          ; Put data in empty TX buf reg
095D: 20       POP   X                  (0990)    pop   X                                  ; Restore frame pointer
095E: 07 FD 01 ADD   [X-3],0x1          (0991)    add   [X+CSTR_LSB],1                     ; Increment the string pointer
0961: 0F FC 00 ADC   [X-4],0x0          (0992)    adc   [X+CSTR_MSB],0
0964: 17 FB 01 SUB   [X-5],0x1          (0993)    sub   [X+CLEN_LSB],0x01                  ; Dec the counter
0967: 1F FA 00 SBB   [X-6],0x0          (0994)    sbb   [X+CLEN_MSB],0x00
096A: 8F DB    JMP   0x0946             (0995)    jmp   .CW_Loop
096C: 70 3F    AND   F,0x3F             
096E: 71 C0    OR    F,0xC0             
                                        (0996) 
                                        (0997) .End_CWrite:
                                        (0998)    RAM_EPILOGUE RAM_USE_CLASS_2
0970: 7F       RET                      (0999)    ret
                                        (1000) .ENDSECTION
                                        (1001) 
                                        (1002) 
                                        (1003) .SECTION
                                        (1004) ;-----------------------------------------------------------------------------
                                        (1005) ;  FUNCTION NAME: UART_CPutString
                                        (1006) ;
                                        (1007) ;  DESCRIPTION:
                                        (1008) ;     Send String out through UART TX port.
                                        (1009) ;-----------------------------------------------------------------------------
                                        (1010) ;
                                        (1011) ;  ARGUMENTS:
                                        (1012) ;     Pointer to String
                                        (1013) ;     A has MSB of string address
                                        (1014) ;     X has LSB of string address
                                        (1015) ;
                                        (1016) ;  RETURNS:
                                        (1017) ;     none
                                        (1018) ;
                                        (1019) ;  SIDE EFFECTS:
                                        (1020) ;    The A and X registers may be modified by this or future implementations
                                        (1021) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1022) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1023) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1024) ;    functions.
                                        (1025) ;
                                        (1026)  UART_CPutString:
                                        (1027) _UART_CPutString:
                                        (1028)    RAM_PROLOGUE RAM_USE_CLASS_1
0971: 08       PUSH  A                  (1029)    push  A                                       ; Store ROM pointer
0972: 10       PUSH  X                  (1030)    push  X
0973: 28       ROMX                     (1031)    romx                                          ; Get character from ROM
0974: A0 0B    JZ    0x0980             (1032)    jz    .End_CPutString
0976: 9F 56    CALL  _UART_PutChar      (1033)    call  UART_PutChar                            ; Print character
0978: 20       POP   X                  (1034)    pop   X
0979: 18       POP   A                  (1035)    pop   A
097A: 75       INC   X                  (1036)    inc   X                                       ; Inc LSB of pointer
097B: DF F5    JNC   _UART_CPutString   (1037)    jnc   UART_CPutString                         ; Check for carry
097D: 74       INC   A                  (1038)    inc   A                                       ; Inc MSB of pointer
097E: 8F F2    JMP   _UART_CPutString   (1039)    jmp   UART_CPutString
                                        (1040) 
                                        (1041) 
                                        (1042) .End_CPutString:
0980: 38 FE    ADD   SP,0xFE            (1043)    add   SP, -2
                                        (1044)    RAM_EPILOGUE RAM_USE_CLASS_1
0982: 7F       RET                      (1045)    ret
                                        (1046) .ENDSECTION
                                        (1047) 
                                        (1048) 
                                        (1049) .SECTION
                                        (1050) ;-----------------------------------------------------------------------------
                                        (1051) ;  FUNCTION NAME: UART_PutCRLF
                                        (1052) ;
                                        (1053) ;  DESCRIPTION:
                                        (1054) ;     Send a CR and LF
                                        (1055) ;-----------------------------------------------------------------------------
                                        (1056) ;
                                        (1057) ;  ARGUMENTS:
                                        (1058) ;     none.
                                        (1059) ;
                                        (1060) ;  RETURNS:
                                        (1061) ;     none.
                                        (1062) ;
                                        (1063) ;  SIDE EFFECTS:
                                        (1064) ;    The A and X registers may be modified by this or future implementations
                                        (1065) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1066) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1067) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1068) ;    functions.
                                        (1069) ;
                                        (1070)  UART_PutCRLF:
                                        (1071) _UART_PutCRLF:
                                        (1072)    RAM_PROLOGUE RAM_USE_CLASS_1
0983: 50 0D    MOV   A,0xD              (1073)    mov  A,0x0D                        ; Send CR
0985: 9F 47    CALL  _UART_PutChar      (1074)    call UART_PutChar
0987: 50 0A    MOV   A,0xA              (1075)    mov  A,0x0A                        ; Send LF
0989: 9F 43    CALL  _UART_PutChar      (1076)    call UART_PutChar
                                        (1077)    RAM_EPILOGUE RAM_USE_CLASS_1
098B: 7F       RET                      (1078)    ret
098C: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1079) .ENDSECTION
                                        (1080) 
                                        (1081) 
                                        (1082) IF (UART_RXBUF_ENABLE)
                                        (1083) ;=============================================================================
                                        (1084) ;=============================================================================
                                        (1085) ;
                                        (1086) ;     Command Buffer commands
                                        (1087) ;
                                        (1088) ;=============================================================================
                                        (1089) ;=============================================================================
                                        (1090) 
                                        (1091) .SECTION
                                        (1092) ;-----------------------------------------------------------------------------
                                        (1093) ;  FUNCTION NAME: UART_CmdReset
                                        (1094) ;
                                        (1095) ;  DESCRIPTION:
                                        (1096) ;     Reset command string and status flags
                                        (1097) ;-----------------------------------------------------------------------------
                                        (1098) ;
                                        (1099) ;  ARGUMENTS:
                                        (1100) ;     none.
                                        (1101) ;
                                        (1102) ;  RETURNS:
                                        (1103) ;     none.
                                        (1104) ;
                                        (1105) ;  SIDE EFFECTS:
                                        (1106) ;    The A and X registers may be modified by this or future implementations
                                        (1107) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1108) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1109) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1110) ;    functions.
                                        (1111) ;          
                                        (1112) ;    Currently only the page pointer registers listed below are modified: 
                                        (1113) ;          CUR_PP
                                        (1114) ;
                                        (1115) ;  THEORY of OPERATION or PROCEDURE:
                                        (1116) ;     Clear the command buffer, command counter, and flag.
                                        (1117) ;
                                        (1118)  UART_CmdReset:
                                        (1119) _UART_CmdReset:
                                        (1120)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1121)    RAM_SETPAGE_CUR >UART_aRxBuffer
098F: 55 02 00 MOV   [0x2],0x0          (1122)    mov [UART_aRxBuffer], 0x00
0992: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1123)    RAM_SETPAGE_CUR >UART_bRxCnt
0995: 55 01 00 MOV   [0x1],0x0          (1124)    mov [UART_bRxCnt], 0x00
0998: 26 00 00 AND   [0x0],0x0          (1125)    and [UART_fStatus], 0x00
099B: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1126)    RAM_SETPAGE_CUR >ptrParam
099E: 55 2D 00 MOV   [curPrt1+1],0x0    (1127)    mov [ptrParam],0x00
                                        (1128)    RAM_EPILOGUE RAM_USE_CLASS_4
09A1: 7F       RET                      (1129)    ret
09A2: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1130) .ENDSECTION
                                        (1131) 
                                        (1132) 
                                        (1133) .SECTION
                                        (1134) ;-----------------------------------------------------------------------------
                                        (1135) ;  FUNCTION NAME: UART_bCmdCheck
                                        (1136) ;
                                        (1137) ;  DESCRIPTION:
                                        (1138) ;     Check to see if valid command in buffer.
                                        (1139) ;-----------------------------------------------------------------------------
                                        (1140) ;
                                        (1141) ;  ARGUMENTS:
                                        (1142) ;     none.
                                        (1143) ;
                                        (1144) ;  RETURNS:
                                        (1145) ;     BYTE  fStatus - Status of command receive buffer.
                                        (1146) ;                     Returns non-zero value in A if command is valid.
                                        (1147) ;
                                        (1148) ;  SIDE EFFECTS:
                                        (1149) ;    The A and X registers may be modified by this or future implementations
                                        (1150) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1151) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1152) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1153) ;    functions.
                                        (1154) ;          
                                        (1155) ;    Currently only the page pointer registers listed below are modified: 
                                        (1156) ;          CUR_PP
                                        (1157) ;
                                        (1158) ;  THEORY of OPERATION or PROCEDURE:
                                        (1159) ;     Read the status and control register.
                                        (1160) ;
                                        (1161)  UART_bCmdCheck:
                                        (1162) _UART_bCmdCheck:
                                        (1163)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1164)    RAM_SETPAGE_CUR >UART_fStatus
09A5: 51 00    MOV   A,[0x0]            (1165)    mov A,  [UART_fStatus]
09A7: 21 01    AND   A,0x1              (1166)    and A, UART_RX_BUF_CMDTERM                    ; Mask off Command status
                                        (1167)    RAM_EPILOGUE RAM_USE_CLASS_4
09A9: 7F       RET                      (1168)    ret
09AA: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1169) .ENDSECTION
                                        (1170)     
                                        (1171) 
                                        (1172) .SECTION
                                        (1173) ;-----------------------------------------------------------------------------
                                        (1174) ;  FUNCTION NAME: UART_bErrCheck
                                        (1175) ;
                                        (1176) ;  DESCRIPTION:
                                        (1177) ;     Check to see if an error has occured since last CmdReset
                                        (1178) ;-----------------------------------------------------------------------------
                                        (1179) ;
                                        (1180) ;  ARGUMENTS:
                                        (1181) ;     none.
                                        (1182) ;
                                        (1183) ;  RETURNS:
                                        (1184) ;     BYTE  fStatus - Status of command receive buffer.
                                        (1185) ;                     Returns non-zero value in A if command is valid.
                                        (1186) ;           0x80 => Parity Error
                                        (1187) ;           0x40 => OverRun Error
                                        (1188) ;           0x20 => Framing Error
                                        (1189) ;           0x10 => Software Buffer OverRun
                                        (1190) ;
                                        (1191) ;  SIDE EFFECTS:
                                        (1192) ;    The A and X registers may be modified by this or future implementations
                                        (1193) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1194) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1195) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1196) ;    functions.
                                        (1197) ;          
                                        (1198) ;    Currently only the page pointer registers listed below are modified: 
                                        (1199) ;          CUR_PP
                                        (1200) ;     Error Status is clear when read.
                                        (1201) ;
                                        (1202) ;  THEORY of OPERATION or PROCEDURE:
                                        (1203) ;     Read RX buffer error status and clear status
                                        (1204) ;
                                        (1205)  UART_bErrCheck:
                                        (1206) _UART_bErrCheck:
                                        (1207)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1208)    RAM_SETPAGE_CUR >UART_fStatus
09AD: 51 00    MOV   A,[0x0]            (1209)    mov A,  [UART_fStatus]
09AF: 21 F0    AND   A,0xF0             (1210)    and A, UART_RX_BUF_ERROR                      ; Mask off Error status
09B1: 26 00 0F AND   [0x0],0xF          (1211)    and [UART_fStatus], ~UART_RX_BUF_ERROR
                                        (1212)    RAM_EPILOGUE RAM_USE_CLASS_4
09B4: 7F       RET                      (1213)    ret
09B5: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1214) .ENDSECTION
                                        (1215) 
                                        (1216) .SECTION
                                        (1217) ;-----------------------------------------------------------------------------
                                        (1218) ;  FUNCTION NAME: UART_bCmdLength
                                        (1219) ;
                                        (1220) ;  DESCRIPTION:
                                        (1221) ;     Get length of command string
                                        (1222) ;-----------------------------------------------------------------------------
                                        (1223) ;
                                        (1224) ;  ARGUMENTS:
                                        (1225) ;     none.
                                        (1226) ;
                                        (1227) ;  RETURNS:
                                        (1228) ;     BYTE  bRxCnt    Returns the command length in A.
                                        (1229) ;
                                        (1230) ;  SIDE EFFECTS:
                                        (1231) ;    The A and X registers may be modified by this or future implementations
                                        (1232) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1234) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1235) ;    functions.
                                        (1236) ;          
                                        (1237) ;    Currently only the page pointer registers listed below are modified: 
                                        (1238) ;          CUR_PP
                                        (1239) ;
                                        (1240)  UART_bCmdLength:
                                        (1241) _UART_bCmdLength:
                                        (1242)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1243)    RAM_SETPAGE_CUR >UART_bRxCnt
09B8: 51 01    MOV   A,[0x1]            (1244)    mov A,  [UART_bRxCnt]
                                        (1245)    RAM_EPILOGUE RAM_USE_CLASS_4
09BA: 7F       RET                      (1246)    ret
09BB: 70 BF    AND   F,0xBF             
09BD: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1247) .ENDSECTION
                                        (1248) 
                                        (1249) 
                                        (1250) .SECTION
                                        (1251) ;-----------------------------------------------------------------------------
                                        (1252) ;  FUNCTION NAME: UART_szGetParam
                                        (1253) ;
                                        (1254) ;  DESCRIPTION:
                                        (1255) ;      Return next parameter from UART Rx buffer
                                        (1256) ;-----------------------------------------------------------------------------
                                        (1257) ;
                                        (1258) ;  ARGUMENTS:  none
                                        (1259) ;
                                        (1260) ;  RETURNS:
                                        (1261) ;     A => MSB of parameter address
                                        (1262) ;     X => LSB of parameter address
                                        (1263) ;
                                        (1264) ;  SIDE EFFECTS:
                                        (1265) ;    The A and X registers may be modified by this or future implementations
                                        (1266) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1268) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1269) ;    functions.
                                        (1270) ;          
                                        (1271) ;    Currently only the page pointer registers listed below are modified: 
                                        (1272) ;          CUR_PP
                                        (1273) ;          IDX_PP
                                        (1274) ;
                                        (1275) ;     The receive string is modified by placing Null characters at the end
                                        (1276) ;     of each parameter as they are recovered.
                                        (1277) ;
                                        (1278) ;  THEORY OF OPERATION:
                                        (1279) ;     This function is a stateful generator of addresses to the "parameters"
                                        (1280) ;     of an input "Command". It scans the (optional) input buffer and breaks
                                        (1281) ;     each lexically distinct element into a null-terminated string by replacing
                                        (1282) ;     delimiters with nulls, as appropriate. The state of the generator is 
                                        (1283) ;     maintained by the private variable ptrParam, which is a buffer-relative
                                        (1284) ;     offset. The generator is initialized by a call to the function
                                        (1285) ;     UART_CmdReset which resets the entire buffer to the 'empty'
                                        (1286) ;     state. Typically this function, UART_szGetParam, is
                                        (1287) ;     not called until the buffer has been loaded with an entire command
                                        (1288) ;     (See UART_bCmdCheck).
                                        (1289) ;
                                        (1290) ;     Note, there is no special distinction between the "command" and the 
                                        (1291) ;     "parameters". The first non-delimiter character of the buffer---the first
                                        (1292) ;     character of the "command"---is also, for the purposes of this function,
                                        (1293) ;     the first "parameter" to which it returns an address.
                                        (1294) ;
                                        (1295) ;     The value of a delimiter (commonly an ascii space, 0x20 and decimal 32)
                                        (1296) ;     is determined at configuration time by a user module parameter.
                                        (1297) ;
                                        (1298)  UART_szGetParam:
                                        (1299) _UART_szGetParam:
                                        (1300)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1301)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (1302)     
                                        (1303)    RAM_SETPAGE_CUR >ptrParam
09C0: 50 02    MOV   A,0x2              (1304)    mov   A, <UART_aRxBuffer                 ; Get address to receive buffer
09C2: 02 2D    ADD   A,[curPrt1+1]      (1305)    add   A, [ptrParam]                      ; Add string offset
09C4: 5C       MOV   X,A                (1306)    mov   X, A
09C5: 62 D3 00 MOV   REG[0xD3],0x0      
                                        (1307)    RAM_SETPAGE_IDX >UART_aRxBuffer
09C8: 52 00    MOV   A,[X+0]            (1308)    mov   A, [X]                             ; Get character pointed by X
09CA: B0 04    JNZ   0x09CF             (1309)    jnz   .SkipOverDelimitersLoop            ; Null? No,  continue...
09CC: 10       PUSH  X                  (1310)    push  X                                  ;       Yes, Save LSB of current pointer
09CD: 80 33    JMP   0x0A01             (1311)    jmp   .End_GetNextParam
                                        (1312)                                             ; Check for delimiter and keep looping until
                                        (1313)                                             ; all leading delimiters have been found.
                                        (1314) .SkipOverDelimitersLoop:
09CF: 39 20    CMP   A,0x20             (1315)    cmp   A, UART_DELIMITER                  ; Do we have a delimiter?
09D1: B0 11    JNZ   0x09E3             (1316)    jnz   .ParamStartFound                   ;   No,  Bingo! found a parameter
09D3: 75       INC   X                  (1317)    inc   X                                  ;   Yes, Increment both index and...
09D4: 76 2D    INC   [curPrt1+1]        (1318)    inc   [ptrParam]                         ;          the stored pointer.
09D6: 52 00    MOV   A,[X+0]            (1319)    mov   A, [X]                             ; Get character pointed by X
09D8: 3C 2D 0F CMP   [curPrt1+1],0xF    (1320)    cmp   [ptrParam], (UART_RX_BUFFER_SIZE -1)   ; End of buffer?
09DB: BF F3    JNZ   0x09CF             (1321)    jnz   .SkipOverDelimitersLoop            ;   No,  continue the scan
                                        (1322) 
                                        (1323) .EndOfString:                               ;   Yes, end of string found...
09DD: 10       PUSH  X                  (1324)    push  X                                  ;        Save ptr
                                        (1325) .TerminateString:
09DE: 56 00 00 MOV   [X+0],0x0          (1326)    mov   [X], 0x00                          ; Make sure string is zero
09E1: 80 1F    JMP   0x0A01             (1327)    jmp   .End_GetNextParam
                                        (1328) 
                                        (1329) .ParamStartFound:
09E3: 10       PUSH  X                  (1330)    push  X                                  ; Beginning of parameter found, save pointer
                                        (1331) 
                                        (1332) .ParamLoop:                                 ; Now loop until end of parameter found.
09E4: 75       INC   X                  (1333)    inc   X                                  ; Advance pointers.
09E5: 76 2D    INC   [curPrt1+1]        (1334)    inc   [ptrParam]
09E7: 3C 2D 0F CMP   [curPrt1+1],0xF    (1335)    cmp   [ptrParam], (UART_RX_BUFFER_SIZE -1)   ; Check if we are at the end of buffer
09EA: AF F3    JZ    0x09DE             (1336)    jz    .TerminateString
09EC: 52 00    MOV   A,[X+0]            (1337)    mov   A, [X]                             ; Get next character
09EE: A0 12    JZ    0x0A01             (1338)    jz    .End_GetNextParam
09F0: 39 20    CMP   A,0x20             (1339)    cmp   A, UART_DELIMITER                  ; Check if we have a delimiter
09F2: BF F1    JNZ   0x09E4             (1340)    jnz   .ParamLoop                         ; Still no delimiter, loop again
09F4: 56 00 00 MOV   [X+0],0x0          (1341)    mov   [X], 0x00                          ; Replace delimiter with null for end of substring
09F7: 76 2D    INC   [curPrt1+1]        (1342)    inc   [ptrParam]
09F9: 3C 2D 0F CMP   [curPrt1+1],0xF    (1343)    cmp   [ptrParam], (UART_RX_BUFFER_SIZE -1)   ; Check if we are at the end of buffer
09FC: B0 04    JNZ   0x0A01             (1344)    jnz   .End_GetNextParam                  ; If not end of string leave
09FE: 55 2D 0F MOV   [curPrt1+1],0xF    (1345)    mov   [ptrParam], (UART_RX_BUFFER_SIZE -1)   ; Reset pointer to end of string.
                                        (1346) 
                                        (1347) .End_GetNextParam:
0A01: 20       POP   X                  (1348)    pop   X
0A02: 10       PUSH  X                  (1349)    push  X
0A03: 3D 00 00 CMP   [X+0],0x0          (1350)    cmp   [X], 0x00
0A06: B0 0A    JNZ   0x0A11             (1351)    jnz   .NotNullString
0A08: 20       POP   X                  (1352)    pop   X
0A09: 57 00    MOV   X,0x0              (1353)    mov   X, 0x00
0A0B: 5B       MOV   A,X                (1354)    mov   A, X
0A0C: 70 3F    AND   F,0x3F             
0A0E: 71 C0    OR    F,0xC0             
                                        (1355)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (1356)    RAM_EPILOGUE RAM_USE_CLASS_4
0A10: 7F       RET                      (1357)    ret
                                        (1358) 
                                        (1359) .NotNullString:
0A11: 20       POP   X                  (1360)    pop  X
0A12: 50 00    MOV   A,0x0              (1361)    mov  A, >UART_aRxBuffer                  ; Return pointer
0A14: 70 3F    AND   F,0x3F             
0A16: 71 C0    OR    F,0xC0             
                                        (1362)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (1363)    RAM_EPILOGUE RAM_USE_CLASS_4
0A18: 7F       RET                      (1364)    ret
0A19: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (1365) .ENDSECTION
                                        (1366) 
                                        (1367) 
                                        (1368) .SECTION
                                        (1369) ;-----------------------------------------------------------------------------
                                        (1370) ;  FUNCTION NAME: UART_szGetRestOfParams
                                        (1371) ;
                                        (1372) ;  DESCRIPTION:
                                        (1373) ;      Returns a pointer to the rest of the UART RX buffer
                                        (1374) ;-----------------------------------------------------------------------------
                                        (1375) ;
                                        (1376) ;  ARGUMENTS:  none
                                        (1377) ;
                                        (1378) ;  RETURNS:
                                        (1379) ;     A => MSB of parameter
                                        (1380) ;     X => LSB of parameter
                                        (1381) ;
                                        (1382) ;  SIDE EFFECTS:
                                        (1383) ;    The A and X registers may be modified by this or future implementations
                                        (1384) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1385) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1386) ;    responsibility to perserve their values across calls to fastcall16 
                                        (1387) ;    functions.
                                        (1388) ;          
                                        (1389) ;    Currently only the page pointer registers listed below are modified: 
                                        (1390) ;          CUR_PP
                                        (1391) ;
                                        (1392)  UART_szGetRestOfParams:
                                        (1393) _UART_szGetRestOfParams:
                                        (1394)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (1395)    RAM_SETPAGE_CUR >ptrParam
0A1C: 50 02    MOV   A,0x2              (1396)    mov  A, <UART_aRxBuffer                  ; Get address to receive buffer
0A1E: 02 2D    ADD   A,[curPrt1+1]      (1397)    add  A, [ptrParam]                       ; Add string offset
0A20: 5C       MOV   X,A                (1398)    mov  X,A
0A21: 50 00    MOV   A,0x0              (1399)    mov  A,>UART_aRxBuffer                   ; Return pointer
                                        (1400)    RAM_EPILOGUE RAM_USE_CLASS_4
0A23: 7F       RET                      (1401)    ret
                                        (1402) .ENDSECTION
                                        (1403) 
                                        (1404) ENDIF
                                        (1405) 
                                        (1406) 
                                        (1407) ; End of File UART.asm
FILE: lib\servo1int.asm                 (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Servo1INT.asm
                                        (0004) ;;   Version: 2.5, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "Servo1.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _Servo1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _Servo1_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _Servo1_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
                                        (0081)    ;lcall _My_C_Function
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
0A24: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file Servo1INT.asm
FILE: lib\servo1.asm                    (0001) ;;*****************************************************************************
0A25: 43 DF 08 OR    REG[0xDF],0x8      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Servo1.asm
                                        (0004) ;;   Version: 2.5, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "Servo1.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  Servo1_EnableInt
                                        (0030) export _Servo1_EnableInt
                                        (0031) export  Servo1_DisableInt
                                        (0032) export _Servo1_DisableInt
                                        (0033) export  Servo1_Start
                                        (0034) export _Servo1_Start
                                        (0035) export  Servo1_Stop
                                        (0036) export _Servo1_Stop
                                        (0037) export  Servo1_WritePeriod
                                        (0038) export _Servo1_WritePeriod
                                        (0039) export  Servo1_WritePulseWidth
                                        (0040) export _Servo1_WritePulseWidth
                                        (0041) export  Servo1_wReadPulseWidth
                                        (0042) export _Servo1_wReadPulseWidth
                                        (0043) export  Servo1_wReadCounter
                                        (0044) export _Servo1_wReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  wServo1_ReadPulseWidth    ; deprecated
                                        (0049) export _wServo1_ReadPulseWidth    ; deprecated
                                        (0050) export  wServo1_ReadCounter       ; deprecated
                                        (0051) export _wServo1_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) 
                                        (0054) AREA kipr_2_RAM (RAM,REL)
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Constant Definitions
                                        (0058) ;-----------------------------------------------
                                        (0059) 
                                        (0060) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0061) 
                                        (0062) 
                                        (0063) ;-----------------------------------------------
                                        (0064) ; Variable Allocation
                                        (0065) ;-----------------------------------------------
                                        (0066) 
                                        (0067) 
                                        (0068) AREA UserModules (ROM, REL)
                                        (0069) 
                                        (0070) .SECTION
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;  FUNCTION NAME: Servo1_EnableInt
                                        (0073) ;
                                        (0074) ;  DESCRIPTION:
                                        (0075) ;     Enables this PWM's interrupt by setting the interrupt enable mask bit
                                        (0076) ;     associated with this User Module. This function has no effect until and
                                        (0077) ;     unless the global interrupts are enabled (for example by using the
                                        (0078) ;     macro M8C_EnableGInt).
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;
                                        (0081) ;  ARGUMENTS:    None.
                                        (0082) ;  RETURNS:      Nothing.
                                        (0083) ;  SIDE EFFECTS: 
                                        (0084) ;    The A and X registers may be modified by this or future implementations
                                        (0085) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0086) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0087) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0088) ;    functions.
                                        (0089) ;
                                        (0090)  Servo1_EnableInt:
                                        (0091) _Servo1_EnableInt:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0093)    Servo1_EnableInt_M
                                        (0094)    RAM_EPILOGUE RAM_USE_CLASS_1
0A28: 7F       RET                      (0095)    ret
0A29: 41 DF F7 AND   REG[0xDF],0xF7     
                                        (0096) 
                                        (0097) 
                                        (0098) .ENDSECTION
                                        (0099) 
                                        (0100) .SECTION
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;  FUNCTION NAME: Servo1_DisableInt
                                        (0103) ;
                                        (0104) ;  DESCRIPTION:
                                        (0105) ;     Disables this PWM's interrupt by clearing the interrupt enable
                                        (0106) ;     mask bit associated with this User Module.
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS:    None
                                        (0110) ;  RETURNS:      Nothing
                                        (0111) ;  SIDE EFFECTS:
                                        (0112) ;    The A and X registers may be modified by this or future implementations
                                        (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0116) ;    functions.
                                        (0117) ;
                                        (0118)  Servo1_DisableInt:
                                        (0119) _Servo1_DisableInt:
                                        (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0121)    Servo1_DisableInt_M
                                        (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
0A2C: 7F       RET                      (0123)    ret
0A2D: 43 4B 01 OR    REG[0x4B],0x1      
                                        (0124) 
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: Servo1_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit in the Control register of this user module.  The
                                        (0134) ;     PWM will begin counting on the next input clock as soon as the
                                        (0135) ;     enable input is asserted high.
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;
                                        (0138) ;  ARGUMENTS:    None
                                        (0139) ;  RETURNS:      Nothing
                                        (0140) ;  SIDE EFFECTS:
                                        (0141) ;    The A and X registers may be modified by this or future implementations
                                        (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0145) ;    functions.
                                        (0146) ;
                                        (0147)  Servo1_Start:
                                        (0148) _Servo1_Start:
                                        (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0150)    Servo1_Start_M
                                        (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
0A30: 7F       RET                      (0152)    ret
0A31: 41 4B FE AND   REG[0x4B],0xFE     
                                        (0153) 
                                        (0154) 
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: Servo1_Stop
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:
                                        (0162) ;     Disables PWM operation by clearing the start bit in the Control
                                        (0163) ;     register of the LSB block.
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;
                                        (0166) ;  ARGUMENTS:    None
                                        (0167) ;  RETURNS:      Nothing
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  Servo1_Stop:
                                        (0176) _Servo1_Stop:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0178)    Servo1_Stop_M
                                        (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
0A34: 7F       RET                      (0180)    ret
                                        (0181) 
                                        (0182) 
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185) .SECTION
                                        (0186) ;-----------------------------------------------------------------------------
                                        (0187) ;  FUNCTION NAME: Servo1_WritePeriod
                                        (0188) ;
                                        (0189) ;  DESCRIPTION:
                                        (0190) ;     Write the 16-bit period value into the Period register (DR1).
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                        (0194) ;  RETURNS:   Nothing
                                        (0195) ;  SIDE EFFECTS:
                                        (0196) ;    If the PWM user module is stopped, then this value will also be
                                        (0197) ;    latched into the Count registers (DR0).
                                        (0198) ;    
                                        (0199) ;    The A and X registers may be modified by this or future implementations
                                        (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0203) ;    functions.
                                        (0204) ;
                                        (0205)  Servo1_WritePeriod:
                                        (0206) _Servo1_WritePeriod:
                                        (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
0A35: 60 49    MOV   REG[0x49],A        (0208)    mov   reg[Servo1_PERIOD_LSB_REG], A
0A37: 5B       MOV   A,X                (0209)    mov   A, X
0A38: 60 4D    MOV   REG[0x4D],A        (0210)    mov   reg[Servo1_PERIOD_MSB_REG], A
                                        (0211)    RAM_EPILOGUE RAM_USE_CLASS_1
0A3A: 7F       RET                      (0212)    ret
                                        (0213) 
                                        (0214) 
                                        (0215) .ENDSECTION
                                        (0216) 
                                        (0217) .SECTION
                                        (0218) ;-----------------------------------------------------------------------------
                                        (0219) ;  FUNCTION NAME: Servo1_WritePulseWidth
                                        (0220) ;
                                        (0221) ;  DESCRIPTION:
                                        (0222) ;     Writes the pulse width value into the Compare register (DR2).
                                        (0223) ;-----------------------------------------------------------------------------
                                        (0224) ;
                                        (0225) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
                                        (0226) ;  RETURNS:      Nothing
                                        (0227) ;  SIDE EFFECTS:
                                        (0228) ;    The A and X registers may be modified by this or future implementations
                                        (0229) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0230) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0231) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0232) ;    functions.
                                        (0233) ;
                                        (0234)  Servo1_WritePulseWidth:
                                        (0235) _Servo1_WritePulseWidth:
                                        (0236)    RAM_PROLOGUE RAM_USE_CLASS_1
0A3B: 60 4A    MOV   REG[0x4A],A        (0237)    mov   reg[Servo1_COMPARE_LSB_REG], A
0A3D: 5B       MOV   A,X                (0238)    mov   A, X
0A3E: 60 4E    MOV   REG[0x4E],A        (0239)    mov   reg[Servo1_COMPARE_MSB_REG], A
                                        (0240)    RAM_EPILOGUE RAM_USE_CLASS_1
0A40: 7F       RET                      (0241)    ret
                                        (0242) 
                                        (0243) 
                                        (0244) .ENDSECTION
                                        (0245) 
                                        (0246) .SECTION
                                        (0247) ;-----------------------------------------------------------------------------
                                        (0248) ;  FUNCTION NAME: Servo1_wReadPulseWidth
                                        (0249) ;
                                        (0250) ;  DESCRIPTION:
                                        (0251) ;     Reads the Compare register.
                                        (0252) ;-----------------------------------------------------------------------------
                                        (0253) ;
                                        (0254) ;  ARGUMENTS:    None
                                        (0255) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                        (0256) ;  SIDE EFFECTS:
                                        (0257) ;    The A and X registers may be modified by this or future implementations
                                        (0258) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0259) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0260) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0261) ;    functions.
                                        (0262) ;
                                        (0263)  Servo1_wReadPulseWidth:
                                        (0264) _Servo1_wReadPulseWidth:
                                        (0265)  wServo1_ReadPulseWidth:                         ; this name deprecated
                                        (0266) _wServo1_ReadPulseWidth:                         ; this name deprecated
                                        (0267)    RAM_PROLOGUE RAM_USE_CLASS_1
0A41: 5D 4E    MOV   A,REG[0x4E]        (0268)    mov   A, reg[Servo1_COMPARE_MSB_REG]
0A43: 5C       MOV   X,A                (0269)    mov   X, A
0A44: 5D 4A    MOV   A,REG[0x4A]        (0270)    mov   A, reg[Servo1_COMPARE_LSB_REG]
                                        (0271)    RAM_EPILOGUE RAM_USE_CLASS_1
0A46: 7F       RET                      (0272)    ret
                                        (0273) 
                                        (0274) 
                                        (0275) .ENDSECTION
                                        (0276) 
                                        (0277) .SECTION
                                        (0278) ;-----------------------------------------------------------------------------
                                        (0279) ;  FUNCTION NAME: Servo1_wReadCounter
                                        (0280) ;
                                        (0281) ;  DESCRIPTION:
                                        (0282) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0283) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0284) ;     from the Count to the Compare register by holding the clock low in
                                        (0285) ;     the MSB PSoC block.
                                        (0286) ;-----------------------------------------------------------------------------
                                        (0287) ;
                                        (0288) ;  ARGUMENTS: None
                                        (0289) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                        (0290) ;  SIDE EFFECTS:
                                        (0291) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0292) ;     2) The A and X registers may be modified by this or future implementations
                                        (0293) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0294) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0295) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0296) ;        functions.
                                        (0297) ;
                                        (0298)  Servo1_wReadCounter:
                                        (0299) _Servo1_wReadCounter:
                                        (0300)  wServo1_ReadCounter:                            ; this name deprecated
                                        (0301) _wServo1_ReadCounter:                            ; this name deprecated
                                        (0302) 
                                        (0303)    bOrigCompareValue:      EQU   0                  ; Frame offset to temp Compare store
                                        (0304)    bOrigClockSetting:      EQU   2                  ; Frame offset to temp Input   store
                                        (0305)    wCounter:               EQU   3                  ; Frame offset to temp Count   store
                                        (0306)    STACK_FRAME_SIZE:       EQU   5                  ; max stack frame size is 5 bytes
                                        (0307) 
                                        (0308)    RAM_PROLOGUE RAM_USE_CLASS_2
0A47: 4F       MOV   X,SP               (0309)    mov   X, SP                                      ; X <-  stack frame pointer
0A48: 5D 4E    MOV   A,REG[0x4E]        (0310)    mov   A, reg[Servo1_COMPARE_MSB_REG]          ; Save the Compare register on the stack
0A4A: 08       PUSH  A                  (0311)    push  A                                          ;
0A4B: 5D 4A    MOV   A,REG[0x4A]        (0312)    mov   A, reg[Servo1_COMPARE_LSB_REG]          ;
0A4D: 08       PUSH  A                  (0313)    push  A                                          ;  -stack frame now 2 bytes-
0A4E: 41 4B FE AND   REG[0x4B],0xFE     
0A51: 71 10    OR    F,0x10             
                                        (0314)    Servo1_Stop_M                                 ; Disable the PWM function
                                        (0315)    M8C_SetBank1                                     ;
0A53: 5D 49    MOV   A,REG[0x49]        (0316)    mov   A, reg[Servo1_INPUT_LSB_REG]            ; save the LSB clock input setting
0A55: 08       PUSH  A                  (0317)    push  A                                          ;   on the stack (now 3 bytes) and ...
                                        (0318)                                                     ;   hold the clock low:
0A56: 62 49 00 MOV   REG[0x49],0x0      (0319)    mov   reg[Servo1_INPUT_LSB_REG], INPUT_REG_NULL
0A59: 70 EF    AND   F,0xEF             
                                        (0320)    M8C_SetBank0                                     ; Extract the Count via DR2 register
0A5B: 5D 4C    MOV   A,REG[0x4C]        (0321)    mov   A, reg[Servo1_COUNTER_MSB_REG]          ; DR2 <- DR0 (in the MSB block)
0A5D: 5D 4E    MOV   A,REG[0x4E]        (0322)    mov   A, reg[Servo1_COMPARE_MSB_REG]          ; Stash the Count MSB on the stack
0A5F: 08       PUSH  A                  (0323)    push  A                                          ;  -stack frame is now 4 bytes
0A60: 5D 48    MOV   A,REG[0x48]        (0324)    mov   A, reg[Servo1_COUNTER_LSB_REG]          ; DR2 <- DR0 (in the LSB block)
0A62: 5D 4A    MOV   A,REG[0x4A]        (0325)    mov   A, reg[Servo1_COMPARE_LSB_REG]          ; Stash the Count LSB on the stack
0A64: 08       PUSH  A                  (0326)    push  A                                          ;   -stack frame is now 5 bytes-
0A65: 52 00    MOV   A,[X+0]            (0327)    mov   A, [X+bOrigCompareValue]                   ; Restore the Compare MSB register
0A67: 60 4E    MOV   REG[0x4E],A        (0328)    mov   reg[Servo1_COMPARE_MSB_REG], A          ;
0A69: 52 01    MOV   A,[X+1]            (0329)    mov   A, [X+bOrigCompareValue+1]                 ; Restore the Compare LSB register
0A6B: 60 4A    MOV   REG[0x4A],A        (0330)    mov   reg[Servo1_COMPARE_LSB_REG], A          ;
0A6D: 71 10    OR    F,0x10             
                                        (0331)    M8C_SetBank1                                     ; ---Restore the PWM operation
0A6F: 52 02    MOV   A,[X+2]            (0332)    mov   A, [X+bOrigClockSetting]                   ; Grab the LSB clock setting...
0A71: 60 49    MOV   REG[0x49],A        (0333)    mov   reg[Servo1_INPUT_LSB_REG], A            ;    and restore it
0A73: 70 EF    AND   F,0xEF             
0A75: 43 4B 01 OR    REG[0x4B],0x1      
                                        (0334)    M8C_SetBank0                                     ;
                                        (0335)    Servo1_Start_M                                ; Now re-enable the PWM function
0A78: 18       POP   A                  (0336)    pop   A                                          ; Setup the return value
0A79: 20       POP   X                  (0337)    pop   X                                          ;
0A7A: 38 FD    ADD   SP,0xFD            (0338)    ADD   SP, -(STACK_FRAME_SIZE-2)                  ; Zap remainder of stack frame
0A7C: 70 3F    AND   F,0x3F             
0A7E: 71 C0    OR    F,0xC0             
                                        (0339)    RAM_EPILOGUE RAM_USE_CLASS_2
0A80: 7F       RET                      (0340)    ret
                                        (0341) 
                                        (0342) .ENDSECTION
                                        (0343) 
                                        (0344) ; End of File Servo1.asm
FILE: lib\servo0int.asm                 (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Servo0INT.asm
                                        (0004) ;;   Version: 2.5, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "Servo0.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _Servo0_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _Servo0_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _Servo0_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
                                        (0081)    ;lcall _My_C_Function
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
0A81: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file Servo0INT.asm
FILE: lib\servo0.asm                    (0001) ;;*****************************************************************************
0A82: 43 E1 04 OR    REG[0xE1],0x4      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Servo0.asm
                                        (0004) ;;   Version: 2.5, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM16 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "Servo0.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  Servo0_EnableInt
                                        (0030) export _Servo0_EnableInt
                                        (0031) export  Servo0_DisableInt
                                        (0032) export _Servo0_DisableInt
                                        (0033) export  Servo0_Start
                                        (0034) export _Servo0_Start
                                        (0035) export  Servo0_Stop
                                        (0036) export _Servo0_Stop
                                        (0037) export  Servo0_WritePeriod
                                        (0038) export _Servo0_WritePeriod
                                        (0039) export  Servo0_WritePulseWidth
                                        (0040) export _Servo0_WritePulseWidth
                                        (0041) export  Servo0_wReadPulseWidth
                                        (0042) export _Servo0_wReadPulseWidth
                                        (0043) export  Servo0_wReadCounter
                                        (0044) export _Servo0_wReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  wServo0_ReadPulseWidth    ; deprecated
                                        (0049) export _wServo0_ReadPulseWidth    ; deprecated
                                        (0050) export  wServo0_ReadCounter       ; deprecated
                                        (0051) export _wServo0_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) 
                                        (0054) AREA kipr_2_RAM (RAM,REL)
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Constant Definitions
                                        (0058) ;-----------------------------------------------
                                        (0059) 
                                        (0060) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0061) 
                                        (0062) 
                                        (0063) ;-----------------------------------------------
                                        (0064) ; Variable Allocation
                                        (0065) ;-----------------------------------------------
                                        (0066) 
                                        (0067) 
                                        (0068) AREA UserModules (ROM, REL)
                                        (0069) 
                                        (0070) .SECTION
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;  FUNCTION NAME: Servo0_EnableInt
                                        (0073) ;
                                        (0074) ;  DESCRIPTION:
                                        (0075) ;     Enables this PWM's interrupt by setting the interrupt enable mask bit
                                        (0076) ;     associated with this User Module. This function has no effect until and
                                        (0077) ;     unless the global interrupts are enabled (for example by using the
                                        (0078) ;     macro M8C_EnableGInt).
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;
                                        (0081) ;  ARGUMENTS:    None.
                                        (0082) ;  RETURNS:      Nothing.
                                        (0083) ;  SIDE EFFECTS: 
                                        (0084) ;    The A and X registers may be modified by this or future implementations
                                        (0085) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0086) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0087) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0088) ;    functions.
                                        (0089) ;
                                        (0090)  Servo0_EnableInt:
                                        (0091) _Servo0_EnableInt:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0093)    Servo0_EnableInt_M
                                        (0094)    RAM_EPILOGUE RAM_USE_CLASS_1
0A85: 7F       RET                      (0095)    ret
0A86: 41 E1 FB AND   REG[0xE1],0xFB     
                                        (0096) 
                                        (0097) 
                                        (0098) .ENDSECTION
                                        (0099) 
                                        (0100) .SECTION
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;  FUNCTION NAME: Servo0_DisableInt
                                        (0103) ;
                                        (0104) ;  DESCRIPTION:
                                        (0105) ;     Disables this PWM's interrupt by clearing the interrupt enable
                                        (0106) ;     mask bit associated with this User Module.
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS:    None
                                        (0110) ;  RETURNS:      Nothing
                                        (0111) ;  SIDE EFFECTS:
                                        (0112) ;    The A and X registers may be modified by this or future implementations
                                        (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0116) ;    functions.
                                        (0117) ;
                                        (0118)  Servo0_DisableInt:
                                        (0119) _Servo0_DisableInt:
                                        (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0121)    Servo0_DisableInt_M
                                        (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
0A89: 7F       RET                      (0123)    ret
0A8A: 43 27 01 OR    REG[0x27],0x1      
                                        (0124) 
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: Servo0_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit in the Control register of this user module.  The
                                        (0134) ;     PWM will begin counting on the next input clock as soon as the
                                        (0135) ;     enable input is asserted high.
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;
                                        (0138) ;  ARGUMENTS:    None
                                        (0139) ;  RETURNS:      Nothing
                                        (0140) ;  SIDE EFFECTS:
                                        (0141) ;    The A and X registers may be modified by this or future implementations
                                        (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0145) ;    functions.
                                        (0146) ;
                                        (0147)  Servo0_Start:
                                        (0148) _Servo0_Start:
                                        (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0150)    Servo0_Start_M
                                        (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
0A8D: 7F       RET                      (0152)    ret
0A8E: 41 27 FE AND   REG[0x27],0xFE     
                                        (0153) 
                                        (0154) 
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: Servo0_Stop
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:
                                        (0162) ;     Disables PWM operation by clearing the start bit in the Control
                                        (0163) ;     register of the LSB block.
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;
                                        (0166) ;  ARGUMENTS:    None
                                        (0167) ;  RETURNS:      Nothing
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  Servo0_Stop:
                                        (0176) _Servo0_Stop:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0178)    Servo0_Stop_M
                                        (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
0A91: 7F       RET                      (0180)    ret
                                        (0181) 
                                        (0182) 
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185) .SECTION
                                        (0186) ;-----------------------------------------------------------------------------
                                        (0187) ;  FUNCTION NAME: Servo0_WritePeriod
                                        (0188) ;
                                        (0189) ;  DESCRIPTION:
                                        (0190) ;     Write the 16-bit period value into the Period register (DR1).
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                        (0194) ;  RETURNS:   Nothing
                                        (0195) ;  SIDE EFFECTS:
                                        (0196) ;    If the PWM user module is stopped, then this value will also be
                                        (0197) ;    latched into the Count registers (DR0).
                                        (0198) ;    
                                        (0199) ;    The A and X registers may be modified by this or future implementations
                                        (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0203) ;    functions.
                                        (0204) ;
                                        (0205)  Servo0_WritePeriod:
                                        (0206) _Servo0_WritePeriod:
                                        (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
0A92: 60 25    MOV   REG[0x25],A        (0208)    mov   reg[Servo0_PERIOD_LSB_REG], A
0A94: 5B       MOV   A,X                (0209)    mov   A, X
0A95: 60 29    MOV   REG[0x29],A        (0210)    mov   reg[Servo0_PERIOD_MSB_REG], A
                                        (0211)    RAM_EPILOGUE RAM_USE_CLASS_1
0A97: 7F       RET                      (0212)    ret
                                        (0213) 
                                        (0214) 
                                        (0215) .ENDSECTION
                                        (0216) 
                                        (0217) .SECTION
                                        (0218) ;-----------------------------------------------------------------------------
                                        (0219) ;  FUNCTION NAME: Servo0_WritePulseWidth
                                        (0220) ;
                                        (0221) ;  DESCRIPTION:
                                        (0222) ;     Writes the pulse width value into the Compare register (DR2).
                                        (0223) ;-----------------------------------------------------------------------------
                                        (0224) ;
                                        (0225) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
                                        (0226) ;  RETURNS:      Nothing
                                        (0227) ;  SIDE EFFECTS:
                                        (0228) ;    The A and X registers may be modified by this or future implementations
                                        (0229) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0230) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0231) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0232) ;    functions.
                                        (0233) ;
                                        (0234)  Servo0_WritePulseWidth:
                                        (0235) _Servo0_WritePulseWidth:
                                        (0236)    RAM_PROLOGUE RAM_USE_CLASS_1
0A98: 60 26    MOV   REG[0x26],A        (0237)    mov   reg[Servo0_COMPARE_LSB_REG], A
0A9A: 5B       MOV   A,X                (0238)    mov   A, X
0A9B: 60 2A    MOV   REG[0x2A],A        (0239)    mov   reg[Servo0_COMPARE_MSB_REG], A
                                        (0240)    RAM_EPILOGUE RAM_USE_CLASS_1
0A9D: 7F       RET                      (0241)    ret
                                        (0242) 
                                        (0243) 
                                        (0244) .ENDSECTION
                                        (0245) 
                                        (0246) .SECTION
                                        (0247) ;-----------------------------------------------------------------------------
                                        (0248) ;  FUNCTION NAME: Servo0_wReadPulseWidth
                                        (0249) ;
                                        (0250) ;  DESCRIPTION:
                                        (0251) ;     Reads the Compare register.
                                        (0252) ;-----------------------------------------------------------------------------
                                        (0253) ;
                                        (0254) ;  ARGUMENTS:    None
                                        (0255) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                        (0256) ;  SIDE EFFECTS:
                                        (0257) ;    The A and X registers may be modified by this or future implementations
                                        (0258) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0259) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0260) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0261) ;    functions.
                                        (0262) ;
                                        (0263)  Servo0_wReadPulseWidth:
                                        (0264) _Servo0_wReadPulseWidth:
                                        (0265)  wServo0_ReadPulseWidth:                         ; this name deprecated
                                        (0266) _wServo0_ReadPulseWidth:                         ; this name deprecated
                                        (0267)    RAM_PROLOGUE RAM_USE_CLASS_1
0A9E: 5D 2A    MOV   A,REG[0x2A]        (0268)    mov   A, reg[Servo0_COMPARE_MSB_REG]
0AA0: 5C       MOV   X,A                (0269)    mov   X, A
0AA1: 5D 26    MOV   A,REG[0x26]        (0270)    mov   A, reg[Servo0_COMPARE_LSB_REG]
                                        (0271)    RAM_EPILOGUE RAM_USE_CLASS_1
0AA3: 7F       RET                      (0272)    ret
                                        (0273) 
                                        (0274) 
                                        (0275) .ENDSECTION
                                        (0276) 
                                        (0277) .SECTION
                                        (0278) ;-----------------------------------------------------------------------------
                                        (0279) ;  FUNCTION NAME: Servo0_wReadCounter
                                        (0280) ;
                                        (0281) ;  DESCRIPTION:
                                        (0282) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0283) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0284) ;     from the Count to the Compare register by holding the clock low in
                                        (0285) ;     the MSB PSoC block.
                                        (0286) ;-----------------------------------------------------------------------------
                                        (0287) ;
                                        (0288) ;  ARGUMENTS: None
                                        (0289) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                        (0290) ;  SIDE EFFECTS:
                                        (0291) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0292) ;     2) The A and X registers may be modified by this or future implementations
                                        (0293) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0294) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0295) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0296) ;        functions.
                                        (0297) ;
                                        (0298)  Servo0_wReadCounter:
                                        (0299) _Servo0_wReadCounter:
                                        (0300)  wServo0_ReadCounter:                            ; this name deprecated
                                        (0301) _wServo0_ReadCounter:                            ; this name deprecated
                                        (0302) 
                                        (0303)    bOrigCompareValue:      EQU   0                  ; Frame offset to temp Compare store
                                        (0304)    bOrigClockSetting:      EQU   2                  ; Frame offset to temp Input   store
                                        (0305)    wCounter:               EQU   3                  ; Frame offset to temp Count   store
                                        (0306)    STACK_FRAME_SIZE:       EQU   5                  ; max stack frame size is 5 bytes
                                        (0307) 
                                        (0308)    RAM_PROLOGUE RAM_USE_CLASS_2
0AA4: 4F       MOV   X,SP               (0309)    mov   X, SP                                      ; X <-  stack frame pointer
0AA5: 5D 2A    MOV   A,REG[0x2A]        (0310)    mov   A, reg[Servo0_COMPARE_MSB_REG]          ; Save the Compare register on the stack
0AA7: 08       PUSH  A                  (0311)    push  A                                          ;
0AA8: 5D 26    MOV   A,REG[0x26]        (0312)    mov   A, reg[Servo0_COMPARE_LSB_REG]          ;
0AAA: 08       PUSH  A                  (0313)    push  A                                          ;  -stack frame now 2 bytes-
0AAB: 41 27 FE AND   REG[0x27],0xFE     
0AAE: 71 10    OR    F,0x10             
                                        (0314)    Servo0_Stop_M                                 ; Disable the PWM function
                                        (0315)    M8C_SetBank1                                     ;
0AB0: 5D 25    MOV   A,REG[0x25]        (0316)    mov   A, reg[Servo0_INPUT_LSB_REG]            ; save the LSB clock input setting
0AB2: 08       PUSH  A                  (0317)    push  A                                          ;   on the stack (now 3 bytes) and ...
                                        (0318)                                                     ;   hold the clock low:
0AB3: 62 25 00 MOV   REG[0x25],0x0      (0319)    mov   reg[Servo0_INPUT_LSB_REG], INPUT_REG_NULL
0AB6: 70 EF    AND   F,0xEF             
                                        (0320)    M8C_SetBank0                                     ; Extract the Count via DR2 register
0AB8: 5D 28    MOV   A,REG[0x28]        (0321)    mov   A, reg[Servo0_COUNTER_MSB_REG]          ; DR2 <- DR0 (in the MSB block)
0ABA: 5D 2A    MOV   A,REG[0x2A]        (0322)    mov   A, reg[Servo0_COMPARE_MSB_REG]          ; Stash the Count MSB on the stack
0ABC: 08       PUSH  A                  (0323)    push  A                                          ;  -stack frame is now 4 bytes
0ABD: 5D 24    MOV   A,REG[0x24]        (0324)    mov   A, reg[Servo0_COUNTER_LSB_REG]          ; DR2 <- DR0 (in the LSB block)
0ABF: 5D 26    MOV   A,REG[0x26]        (0325)    mov   A, reg[Servo0_COMPARE_LSB_REG]          ; Stash the Count LSB on the stack
0AC1: 08       PUSH  A                  (0326)    push  A                                          ;   -stack frame is now 5 bytes-
0AC2: 52 00    MOV   A,[X+0]            (0327)    mov   A, [X+bOrigCompareValue]                   ; Restore the Compare MSB register
0AC4: 60 2A    MOV   REG[0x2A],A        (0328)    mov   reg[Servo0_COMPARE_MSB_REG], A          ;
0AC6: 52 01    MOV   A,[X+1]            (0329)    mov   A, [X+bOrigCompareValue+1]                 ; Restore the Compare LSB register
0AC8: 60 26    MOV   REG[0x26],A        (0330)    mov   reg[Servo0_COMPARE_LSB_REG], A          ;
0ACA: 71 10    OR    F,0x10             
                                        (0331)    M8C_SetBank1                                     ; ---Restore the PWM operation
0ACC: 52 02    MOV   A,[X+2]            (0332)    mov   A, [X+bOrigClockSetting]                   ; Grab the LSB clock setting...
0ACE: 60 25    MOV   REG[0x25],A        (0333)    mov   reg[Servo0_INPUT_LSB_REG], A            ;    and restore it
0AD0: 70 EF    AND   F,0xEF             
0AD2: 43 27 01 OR    REG[0x27],0x1      
                                        (0334)    M8C_SetBank0                                     ;
                                        (0335)    Servo0_Start_M                                ; Now re-enable the PWM function
0AD5: 18       POP   A                  (0336)    pop   A                                          ; Setup the return value
0AD6: 20       POP   X                  (0337)    pop   X                                          ;
0AD7: 38 FD    ADD   SP,0xFD            (0338)    ADD   SP, -(STACK_FRAME_SIZE-2)                  ; Zap remainder of stack frame
0AD9: 70 3F    AND   F,0x3F             
0ADB: 71 C0    OR    F,0xC0             
                                        (0339)    RAM_EPILOGUE RAM_USE_CLASS_2
0ADD: 7F       RET                      (0340)    ret
                                        (0341) 
                                        (0342) .ENDSECTION
                                        (0343) 
                                        (0344) ; End of File Servo0.asm
FILE: lib\pwmbint.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWMBINT.asm
                                        (0004) ;;   Version: 2.60, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM8 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "PWMB.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _PWMB_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _PWMB_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _PWMB_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
                                        (0081)    ;lcall _My_C_Function
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
0ADE: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file PWMBINT.asm
FILE: lib\pwmb.asm                      (0001) ;;*****************************************************************************
0ADF: 43 DF 01 OR    REG[0xDF],0x1      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWMB.asm
                                        (0004) ;;   Version: 2.60, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM8 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "PWMB.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  PWMB_EnableInt
                                        (0030) export _PWMB_EnableInt
                                        (0031) export  PWMB_DisableInt
                                        (0032) export _PWMB_DisableInt
                                        (0033) export  PWMB_Start
                                        (0034) export _PWMB_Start
                                        (0035) export  PWMB_Stop
                                        (0036) export _PWMB_Stop
                                        (0037) export  PWMB_WritePeriod
                                        (0038) export _PWMB_WritePeriod
                                        (0039) export  PWMB_WritePulseWidth
                                        (0040) export _PWMB_WritePulseWidth
                                        (0041) export  PWMB_bReadPulseWidth
                                        (0042) export _PWMB_bReadPulseWidth
                                        (0043) export  PWMB_bReadCounter
                                        (0044) export _PWMB_bReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  bPWMB_ReadPulseWidth    ; deprecated
                                        (0049) export _bPWMB_ReadPulseWidth    ; deprecated
                                        (0050) export  bPWMB_ReadCounter       ; deprecated
                                        (0051) export _bPWMB_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) 
                                        (0054) AREA kipr_2_RAM (RAM,REL)
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Constant Definitions
                                        (0058) ;-----------------------------------------------
                                        (0059) 
                                        (0060) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0061) 
                                        (0062) 
                                        (0063) ;-----------------------------------------------
                                        (0064) ; Variable Allocation
                                        (0065) ;-----------------------------------------------
                                        (0066) 
                                        (0067) 
                                        (0068) AREA UserModules (ROM, REL)
                                        (0069) 
                                        (0070) .SECTION
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;  FUNCTION NAME: PWMB_EnableInt
                                        (0073) ;
                                        (0074) ;  DESCRIPTION:
                                        (0075) ;     Enables this PWM's interrupt by setting the interrupt enable mask bit
                                        (0076) ;     associated with this User Module. This function has no effect until and
                                        (0077) ;     unless the global interrupts are enabled (for example by using the
                                        (0078) ;     macro M8C_EnableGInt).
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;
                                        (0081) ;  ARGUMENTS:    None.
                                        (0082) ;  RETURNS:      Nothing.
                                        (0083) ;  SIDE EFFECTS:
                                        (0084) ;    The A and X registers may be modified by this or future implementations
                                        (0085) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0086) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0087) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0088) ;    functions.
                                        (0089) ;
                                        (0090)  PWMB_EnableInt:
                                        (0091) _PWMB_EnableInt:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0093)    PWMB_EnableInt_M
                                        (0094)    RAM_EPILOGUE RAM_USE_CLASS_1
0AE2: 7F       RET                      (0095)    ret
0AE3: 41 DF FE AND   REG[0xDF],0xFE     
                                        (0096) 
                                        (0097) 
                                        (0098) .ENDSECTION
                                        (0099) 
                                        (0100) .SECTION
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;  FUNCTION NAME: PWMB_DisableInt
                                        (0103) ;
                                        (0104) ;  DESCRIPTION:
                                        (0105) ;     Disables this PWM's interrupt by clearing the interrupt enable
                                        (0106) ;     mask bit associated with this User Module.
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS:    None
                                        (0110) ;  RETURNS:      Nothing
                                        (0111) ;  SIDE EFFECTS:
                                        (0112) ;    The A and X registers may be modified by this or future implementations
                                        (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0116) ;    functions.
                                        (0117) ;
                                        (0118)  PWMB_DisableInt:
                                        (0119) _PWMB_DisableInt:
                                        (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0121)    PWMB_DisableInt_M
                                        (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
0AE6: 7F       RET                      (0123)    ret
0AE7: 43 43 01 OR    REG[0x43],0x1      
                                        (0124) 
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: PWMB_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit in the Control register of this user module.  The
                                        (0134) ;     PWM will begin counting on the next input clock as soon as the
                                        (0135) ;     enable input is asserted high.
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;
                                        (0138) ;  ARGUMENTS:    None
                                        (0139) ;  RETURNS:      Nothing
                                        (0140) ;  SIDE EFFECTS:
                                        (0141) ;    The A and X registers may be modified by this or future implementations
                                        (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0145) ;    functions.
                                        (0146) ;
                                        (0147)  PWMB_Start:
                                        (0148) _PWMB_Start:
                                        (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0150)    PWMB_Start_M
                                        (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
0AEA: 7F       RET                      (0152)    ret
0AEB: 41 43 FE AND   REG[0x43],0xFE     
                                        (0153) 
                                        (0154) 
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: PWMB_Stop
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:
                                        (0162) ;     Disables PWM operation by clearing the start bit in the Control
                                        (0163) ;     register.
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;
                                        (0166) ;  ARGUMENTS:    None
                                        (0167) ;  RETURNS:      Nothing
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  PWMB_Stop:
                                        (0176) _PWMB_Stop:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0178)    PWMB_Stop_M
                                        (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
0AEE: 7F       RET                      (0180)    ret
                                        (0181) 
                                        (0182) 
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185) .SECTION
                                        (0186) ;-----------------------------------------------------------------------------
                                        (0187) ;  FUNCTION NAME: PWMB_WritePeriod
                                        (0188) ;
                                        (0189) ;  DESCRIPTION:
                                        (0190) ;     Write the 8-bit period value into the Period register (DR1).
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: fastcall16 BYTE bPeriodValue (passed in A)
                                        (0194) ;  RETURNS:   Nothing
                                        (0195) ;  SIDE EFFECTS:
                                        (0196) ;    If the PWM user module is stopped, then this value will also be
                                        (0197) ;    latched into the Count register (DR0).
                                        (0198) ;    
                                        (0199) ;    The A and X registers may be modified by this or future implementations
                                        (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0203) ;    functions.
                                        (0204) ;
                                        (0205)  PWMB_WritePeriod:
                                        (0206) _PWMB_WritePeriod:
                                        (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
0AEF: 60 41    MOV   REG[0x41],A        (0208)    mov   reg[PWMB_PERIOD_REG], A
                                        (0209)    RAM_EPILOGUE RAM_USE_CLASS_1
0AF1: 7F       RET                      (0210)    ret
                                        (0211) 
                                        (0212) 
                                        (0213) .ENDSECTION
                                        (0214) 
                                        (0215) .SECTION
                                        (0216) ;-----------------------------------------------------------------------------
                                        (0217) ;  FUNCTION NAME: PWMB_WritePulseWidth
                                        (0218) ;
                                        (0219) ;  DESCRIPTION:
                                        (0220) ;     Writes compare value into the Compare register (DR2).
                                        (0221) ;-----------------------------------------------------------------------------
                                        (0222) ;
                                        (0223) ;  ARGUMENTS:    fastcall16 BYTE bCompareValue (passed in A)
                                        (0224) ;  RETURNS:      Nothing
                                        (0225) ;  SIDE EFFECTS:
                                        (0226) ;    The A and X registers may be modified by this or future implementations
                                        (0227) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0228) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0229) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0230) ;    functions.
                                        (0231) ;
                                        (0232)  PWMB_WritePulseWidth:
                                        (0233) _PWMB_WritePulseWidth:
                                        (0234)    RAM_PROLOGUE RAM_USE_CLASS_1
0AF2: 60 42    MOV   REG[0x42],A        (0235)    mov   reg[PWMB_COMPARE_REG], A
                                        (0236)    RAM_EPILOGUE RAM_USE_CLASS_1
0AF4: 7F       RET                      (0237)    ret
                                        (0238) 
                                        (0239) 
                                        (0240) .ENDSECTION
                                        (0241) 
                                        (0242) .SECTION
                                        (0243) ;-----------------------------------------------------------------------------
                                        (0244) ;  FUNCTION NAME: PWMB_bReadPulseWidth
                                        (0245) ;
                                        (0246) ;  DESCRIPTION:
                                        (0247) ;     Reads the Compare register.
                                        (0248) ;-----------------------------------------------------------------------------
                                        (0249) ;
                                        (0250) ;  ARGUMENTS:    None
                                        (0251) ;  RETURNS:      fastcall16 BYTE bCompareValue (value of DR2 in the A register)
                                        (0252) ;  SIDE EFFECTS:
                                        (0253) ;    The A and X registers may be modified by this or future implementations
                                        (0254) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0255) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0256) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0257) ;    functions.
                                        (0258) ;
                                        (0259)  PWMB_bReadPulseWidth:
                                        (0260) _PWMB_bReadPulseWidth:
                                        (0261)  bPWMB_ReadPulseWidth:                           ; this name deprecated
                                        (0262) _bPWMB_ReadPulseWidth:                           ; this name deprecated
                                        (0263)    RAM_PROLOGUE RAM_USE_CLASS_1
0AF5: 5D 42    MOV   A,REG[0x42]        (0264)    mov   A, reg[PWMB_COMPARE_REG]
                                        (0265)    RAM_EPILOGUE RAM_USE_CLASS_1
0AF7: 7F       RET                      (0266)    ret
                                        (0267) 
                                        (0268) 
                                        (0269) .ENDSECTION
                                        (0270) 
                                        (0271) .SECTION
                                        (0272) ;-----------------------------------------------------------------------------
                                        (0273) ;  FUNCTION NAME: PWMB_bReadCounter
                                        (0274) ;
                                        (0275) ;  DESCRIPTION:
                                        (0276) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0277) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0278) ;     from the Count to the Compare registers by holding the clock low in
                                        (0279) ;     the PSoC block.
                                        (0280) ;-----------------------------------------------------------------------------
                                        (0281) ;
                                        (0282) ;  ARGUMENTS: None
                                        (0283) ;  RETURNS:   fastcall16 BYTE bCount (value of DR0 in the A register)
                                        (0284) ;  SIDE EFFECTS:
                                        (0285) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0286) ;     2) The A and X registers may be modified by this or future implementations
                                        (0287) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0288) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0289) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0290) ;        functions.
                                        (0291) ;
                                        (0292)  PWMB_bReadCounter:
                                        (0293) _PWMB_bReadCounter:
                                        (0294)  bPWMB_ReadCounter:                              ; this name deprecated
                                        (0295) _bPWMB_ReadCounter:                              ; this name deprecated
                                        (0296) 
                                        (0297)    bOrigCompareValue:      EQU   0               ; Frame offset to temp Compare store
                                        (0298)    bOrigClockSetting:      EQU   1               ; Frame offset to temp Input   store
                                        (0299)    wCounter:               EQU   2               ; Frame offset to temp Count   store
                                        (0300)    STACK_FRAME_SIZE:       EQU   3               ; max stack frame size is 3 bytes
                                        (0301) 
                                        (0302)    RAM_PROLOGUE RAM_USE_CLASS_2
0AF8: 4F       MOV   X,SP               (0303)    mov   X, SP                                   ; X <- stack frame pointer
0AF9: 5D 42    MOV   A,REG[0x42]        (0304)    mov   A, reg[PWMB_COMPARE_REG]                ; Save the Compare register on the stack
0AFB: 08       PUSH  A                  (0305)    push  A                                       ;
0AFC: 41 43 FE AND   REG[0x43],0xFE     
0AFF: 71 10    OR    F,0x10             
                                        (0306)    PWMB_Stop_M                                   ; Disable (stop) the PWM
                                        (0307)    M8C_SetBank1                                  ;
0B01: 5D 41    MOV   A,REG[0x41]        (0308)    mov   A, reg[PWMB_INPUT_REG]                  ; save the clock input setting
0B03: 08       PUSH  A                  (0309)    push  A                                       ;   on the stack (now 2 bytes) and ...
                                        (0310)                                                  ;   hold the clock low:
0B04: 62 41 00 MOV   REG[0x41],0x0      (0311)    mov   reg[PWMB_INPUT_REG], INPUT_REG_NULL
0B07: 70 EF    AND   F,0xEF             
                                        (0312)    M8C_SetBank0
                                        (0313)                                                  ; Extract the Count via DR2 register
0B09: 5D 40    MOV   A,REG[0x40]        (0314)    mov   A, reg[PWMB_COUNTER_REG]                ; DR2 <- DR0
0B0B: 5D 42    MOV   A,REG[0x42]        (0315)    mov   A, reg[PWMB_COMPARE_REG]                ; Stash the Count on the stack
0B0D: 08       PUSH  A                  (0316)    push  A                                       ;  -stack frame is now 3 bytes
0B0E: 52 00    MOV   A,[X+0]            (0317)    mov   A, [X+bOrigCompareValue]                ; Restore the Compare register
0B10: 60 42    MOV   REG[0x42],A        (0318)    mov   reg[PWMB_COMPARE_REG], A
0B12: 71 10    OR    F,0x10             
                                        (0319)    M8C_SetBank1                                  ; Restore the PWM operation:
0B14: 52 01    MOV   A,[X+1]            (0320)    mov   A, [X+bOrigClockSetting]                ;   First, the clock setting...
0B16: 60 41    MOV   REG[0x41],A        (0321)    mov   reg[PWMB_INPUT_REG], A                  ;
0B18: 70 EF    AND   F,0xEF             
0B1A: 43 43 01 OR    REG[0x43],0x1      
                                        (0322)    M8C_SetBank0                                  ;
                                        (0323)    PWMB_Start_M                                  ;   then re-enable the PWM.
0B1D: 18       POP   A                  (0324)    pop   A                                       ; Setup the return value
0B1E: 38 FE    ADD   SP,0xFE            (0325)    ADD   SP, -(STACK_FRAME_SIZE-1)               ; Zap remainder of stack frame
0B20: 70 3F    AND   F,0x3F             
0B22: 71 C0    OR    F,0xC0             
                                        (0326)    RAM_EPILOGUE RAM_USE_CLASS_2
0B24: 7F       RET                      (0327)    ret
                                        (0328) 
                                        (0329) .ENDSECTION
                                        (0330) 
                                        (0331) ; End of File PWMB.asm
FILE: lib\pwmaint.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWMAINT.asm
                                        (0004) ;;   Version: 2.60, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM8 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "PWMA.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _PWMA_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _PWMA_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _PWMA_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
                                        (0081)    ;lcall _My_C_Function
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
0B25: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file PWMAINT.asm
FILE: lib\pwma.asm                      (0001) ;;*****************************************************************************
0B26: 43 E1 08 OR    REG[0xE1],0x8      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PWMA.asm
                                        (0004) ;;   Version: 2.60, Updated on 2014/7/14 at 8:14:50
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PWM8 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "PWMA.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  PWMA_EnableInt
                                        (0030) export _PWMA_EnableInt
                                        (0031) export  PWMA_DisableInt
                                        (0032) export _PWMA_DisableInt
                                        (0033) export  PWMA_Start
                                        (0034) export _PWMA_Start
                                        (0035) export  PWMA_Stop
                                        (0036) export _PWMA_Stop
                                        (0037) export  PWMA_WritePeriod
                                        (0038) export _PWMA_WritePeriod
                                        (0039) export  PWMA_WritePulseWidth
                                        (0040) export _PWMA_WritePulseWidth
                                        (0041) export  PWMA_bReadPulseWidth
                                        (0042) export _PWMA_bReadPulseWidth
                                        (0043) export  PWMA_bReadCounter
                                        (0044) export _PWMA_bReadCounter
                                        (0045) 
                                        (0046) ; The following functions are deprecated and subject to omission in future releases
                                        (0047) ;
                                        (0048) export  bPWMA_ReadPulseWidth    ; deprecated
                                        (0049) export _bPWMA_ReadPulseWidth    ; deprecated
                                        (0050) export  bPWMA_ReadCounter       ; deprecated
                                        (0051) export _bPWMA_ReadCounter       ; deprecated
                                        (0052) 
                                        (0053) 
                                        (0054) AREA kipr_2_RAM (RAM,REL)
                                        (0055) 
                                        (0056) ;-----------------------------------------------
                                        (0057) ;  Constant Definitions
                                        (0058) ;-----------------------------------------------
                                        (0059) 
                                        (0060) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                        (0061) 
                                        (0062) 
                                        (0063) ;-----------------------------------------------
                                        (0064) ; Variable Allocation
                                        (0065) ;-----------------------------------------------
                                        (0066) 
                                        (0067) 
                                        (0068) AREA UserModules (ROM, REL)
                                        (0069) 
                                        (0070) .SECTION
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) ;  FUNCTION NAME: PWMA_EnableInt
                                        (0073) ;
                                        (0074) ;  DESCRIPTION:
                                        (0075) ;     Enables this PWM's interrupt by setting the interrupt enable mask bit
                                        (0076) ;     associated with this User Module. This function has no effect until and
                                        (0077) ;     unless the global interrupts are enabled (for example by using the
                                        (0078) ;     macro M8C_EnableGInt).
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ;
                                        (0081) ;  ARGUMENTS:    None.
                                        (0082) ;  RETURNS:      Nothing.
                                        (0083) ;  SIDE EFFECTS:
                                        (0084) ;    The A and X registers may be modified by this or future implementations
                                        (0085) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0086) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0087) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0088) ;    functions.
                                        (0089) ;
                                        (0090)  PWMA_EnableInt:
                                        (0091) _PWMA_EnableInt:
                                        (0092)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0093)    PWMA_EnableInt_M
                                        (0094)    RAM_EPILOGUE RAM_USE_CLASS_1
0B29: 7F       RET                      (0095)    ret
0B2A: 41 E1 F7 AND   REG[0xE1],0xF7     
                                        (0096) 
                                        (0097) 
                                        (0098) .ENDSECTION
                                        (0099) 
                                        (0100) .SECTION
                                        (0101) ;-----------------------------------------------------------------------------
                                        (0102) ;  FUNCTION NAME: PWMA_DisableInt
                                        (0103) ;
                                        (0104) ;  DESCRIPTION:
                                        (0105) ;     Disables this PWM's interrupt by clearing the interrupt enable
                                        (0106) ;     mask bit associated with this User Module.
                                        (0107) ;-----------------------------------------------------------------------------
                                        (0108) ;
                                        (0109) ;  ARGUMENTS:    None
                                        (0110) ;  RETURNS:      Nothing
                                        (0111) ;  SIDE EFFECTS:
                                        (0112) ;    The A and X registers may be modified by this or future implementations
                                        (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0116) ;    functions.
                                        (0117) ;
                                        (0118)  PWMA_DisableInt:
                                        (0119) _PWMA_DisableInt:
                                        (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0121)    PWMA_DisableInt_M
                                        (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
0B2D: 7F       RET                      (0123)    ret
0B2E: 43 2F 01 OR    REG[0x2F],0x1      
                                        (0124) 
                                        (0125) 
                                        (0126) .ENDSECTION
                                        (0127) 
                                        (0128) .SECTION
                                        (0129) ;-----------------------------------------------------------------------------
                                        (0130) ;  FUNCTION NAME: PWMA_Start
                                        (0131) ;
                                        (0132) ;  DESCRIPTION:
                                        (0133) ;     Sets the start bit in the Control register of this user module.  The
                                        (0134) ;     PWM will begin counting on the next input clock as soon as the
                                        (0135) ;     enable input is asserted high.
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;
                                        (0138) ;  ARGUMENTS:    None
                                        (0139) ;  RETURNS:      Nothing
                                        (0140) ;  SIDE EFFECTS:
                                        (0141) ;    The A and X registers may be modified by this or future implementations
                                        (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0145) ;    functions.
                                        (0146) ;
                                        (0147)  PWMA_Start:
                                        (0148) _PWMA_Start:
                                        (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0150)    PWMA_Start_M
                                        (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
0B31: 7F       RET                      (0152)    ret
0B32: 41 2F FE AND   REG[0x2F],0xFE     
                                        (0153) 
                                        (0154) 
                                        (0155) .ENDSECTION
                                        (0156) 
                                        (0157) .SECTION
                                        (0158) ;-----------------------------------------------------------------------------
                                        (0159) ;  FUNCTION NAME: PWMA_Stop
                                        (0160) ;
                                        (0161) ;  DESCRIPTION:
                                        (0162) ;     Disables PWM operation by clearing the start bit in the Control
                                        (0163) ;     register.
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;
                                        (0166) ;  ARGUMENTS:    None
                                        (0167) ;  RETURNS:      Nothing
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  PWMA_Stop:
                                        (0176) _PWMA_Stop:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0178)    PWMA_Stop_M
                                        (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
0B35: 7F       RET                      (0180)    ret
                                        (0181) 
                                        (0182) 
                                        (0183) .ENDSECTION
                                        (0184) 
                                        (0185) .SECTION
                                        (0186) ;-----------------------------------------------------------------------------
                                        (0187) ;  FUNCTION NAME: PWMA_WritePeriod
                                        (0188) ;
                                        (0189) ;  DESCRIPTION:
                                        (0190) ;     Write the 8-bit period value into the Period register (DR1).
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: fastcall16 BYTE bPeriodValue (passed in A)
                                        (0194) ;  RETURNS:   Nothing
                                        (0195) ;  SIDE EFFECTS:
                                        (0196) ;    If the PWM user module is stopped, then this value will also be
                                        (0197) ;    latched into the Count register (DR0).
                                        (0198) ;    
                                        (0199) ;    The A and X registers may be modified by this or future implementations
                                        (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0203) ;    functions.
                                        (0204) ;
                                        (0205)  PWMA_WritePeriod:
                                        (0206) _PWMA_WritePeriod:
                                        (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
0B36: 60 2D    MOV   REG[0x2D],A        (0208)    mov   reg[PWMA_PERIOD_REG], A
                                        (0209)    RAM_EPILOGUE RAM_USE_CLASS_1
0B38: 7F       RET                      (0210)    ret
                                        (0211) 
                                        (0212) 
                                        (0213) .ENDSECTION
                                        (0214) 
                                        (0215) .SECTION
                                        (0216) ;-----------------------------------------------------------------------------
                                        (0217) ;  FUNCTION NAME: PWMA_WritePulseWidth
                                        (0218) ;
                                        (0219) ;  DESCRIPTION:
                                        (0220) ;     Writes compare value into the Compare register (DR2).
                                        (0221) ;-----------------------------------------------------------------------------
                                        (0222) ;
                                        (0223) ;  ARGUMENTS:    fastcall16 BYTE bCompareValue (passed in A)
                                        (0224) ;  RETURNS:      Nothing
                                        (0225) ;  SIDE EFFECTS:
                                        (0226) ;    The A and X registers may be modified by this or future implementations
                                        (0227) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0228) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0229) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0230) ;    functions.
                                        (0231) ;
                                        (0232)  PWMA_WritePulseWidth:
                                        (0233) _PWMA_WritePulseWidth:
                                        (0234)    RAM_PROLOGUE RAM_USE_CLASS_1
0B39: 60 2E    MOV   REG[0x2E],A        (0235)    mov   reg[PWMA_COMPARE_REG], A
                                        (0236)    RAM_EPILOGUE RAM_USE_CLASS_1
0B3B: 7F       RET                      (0237)    ret
                                        (0238) 
                                        (0239) 
                                        (0240) .ENDSECTION
                                        (0241) 
                                        (0242) .SECTION
                                        (0243) ;-----------------------------------------------------------------------------
                                        (0244) ;  FUNCTION NAME: PWMA_bReadPulseWidth
                                        (0245) ;
                                        (0246) ;  DESCRIPTION:
                                        (0247) ;     Reads the Compare register.
                                        (0248) ;-----------------------------------------------------------------------------
                                        (0249) ;
                                        (0250) ;  ARGUMENTS:    None
                                        (0251) ;  RETURNS:      fastcall16 BYTE bCompareValue (value of DR2 in the A register)
                                        (0252) ;  SIDE EFFECTS:
                                        (0253) ;    The A and X registers may be modified by this or future implementations
                                        (0254) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0255) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0256) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0257) ;    functions.
                                        (0258) ;
                                        (0259)  PWMA_bReadPulseWidth:
                                        (0260) _PWMA_bReadPulseWidth:
                                        (0261)  bPWMA_ReadPulseWidth:                           ; this name deprecated
                                        (0262) _bPWMA_ReadPulseWidth:                           ; this name deprecated
                                        (0263)    RAM_PROLOGUE RAM_USE_CLASS_1
0B3C: 5D 2E    MOV   A,REG[0x2E]        (0264)    mov   A, reg[PWMA_COMPARE_REG]
                                        (0265)    RAM_EPILOGUE RAM_USE_CLASS_1
0B3E: 7F       RET                      (0266)    ret
                                        (0267) 
                                        (0268) 
                                        (0269) .ENDSECTION
                                        (0270) 
                                        (0271) .SECTION
                                        (0272) ;-----------------------------------------------------------------------------
                                        (0273) ;  FUNCTION NAME: PWMA_bReadCounter
                                        (0274) ;
                                        (0275) ;  DESCRIPTION:
                                        (0276) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0277) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0278) ;     from the Count to the Compare registers by holding the clock low in
                                        (0279) ;     the PSoC block.
                                        (0280) ;-----------------------------------------------------------------------------
                                        (0281) ;
                                        (0282) ;  ARGUMENTS: None
                                        (0283) ;  RETURNS:   fastcall16 BYTE bCount (value of DR0 in the A register)
                                        (0284) ;  SIDE EFFECTS:
                                        (0285) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0286) ;     2) The A and X registers may be modified by this or future implementations
                                        (0287) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0288) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0289) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0290) ;        functions.
                                        (0291) ;
                                        (0292)  PWMA_bReadCounter:
                                        (0293) _PWMA_bReadCounter:
                                        (0294)  bPWMA_ReadCounter:                              ; this name deprecated
                                        (0295) _bPWMA_ReadCounter:                              ; this name deprecated
                                        (0296) 
                                        (0297)    bOrigCompareValue:      EQU   0               ; Frame offset to temp Compare store
                                        (0298)    bOrigClockSetting:      EQU   1               ; Frame offset to temp Input   store
                                        (0299)    wCounter:               EQU   2               ; Frame offset to temp Count   store
                                        (0300)    STACK_FRAME_SIZE:       EQU   3               ; max stack frame size is 3 bytes
                                        (0301) 
                                        (0302)    RAM_PROLOGUE RAM_USE_CLASS_2
0B3F: 4F       MOV   X,SP               (0303)    mov   X, SP                                   ; X <- stack frame pointer
0B40: 5D 2E    MOV   A,REG[0x2E]        (0304)    mov   A, reg[PWMA_COMPARE_REG]                ; Save the Compare register on the stack
0B42: 08       PUSH  A                  (0305)    push  A                                       ;
0B43: 41 2F FE AND   REG[0x2F],0xFE     
0B46: 71 10    OR    F,0x10             
                                        (0306)    PWMA_Stop_M                                   ; Disable (stop) the PWM
                                        (0307)    M8C_SetBank1                                  ;
0B48: 5D 2D    MOV   A,REG[0x2D]        (0308)    mov   A, reg[PWMA_INPUT_REG]                  ; save the clock input setting
0B4A: 08       PUSH  A                  (0309)    push  A                                       ;   on the stack (now 2 bytes) and ...
                                        (0310)                                                  ;   hold the clock low:
0B4B: 62 2D 00 MOV   REG[0x2D],0x0      (0311)    mov   reg[PWMA_INPUT_REG], INPUT_REG_NULL
0B4E: 70 EF    AND   F,0xEF             
                                        (0312)    M8C_SetBank0
                                        (0313)                                                  ; Extract the Count via DR2 register
0B50: 5D 2C    MOV   A,REG[0x2C]        (0314)    mov   A, reg[PWMA_COUNTER_REG]                ; DR2 <- DR0
0B52: 5D 2E    MOV   A,REG[0x2E]        (0315)    mov   A, reg[PWMA_COMPARE_REG]                ; Stash the Count on the stack
0B54: 08       PUSH  A                  (0316)    push  A                                       ;  -stack frame is now 3 bytes
0B55: 52 00    MOV   A,[X+0]            (0317)    mov   A, [X+bOrigCompareValue]                ; Restore the Compare register
0B57: 60 2E    MOV   REG[0x2E],A        (0318)    mov   reg[PWMA_COMPARE_REG], A
0B59: 71 10    OR    F,0x10             
                                        (0319)    M8C_SetBank1                                  ; Restore the PWM operation:
0B5B: 52 01    MOV   A,[X+1]            (0320)    mov   A, [X+bOrigClockSetting]                ;   First, the clock setting...
0B5D: 60 2D    MOV   REG[0x2D],A        (0321)    mov   reg[PWMA_INPUT_REG], A                  ;
0B5F: 70 EF    AND   F,0xEF             
0B61: 43 2F 01 OR    REG[0x2F],0x1      
                                        (0322)    M8C_SetBank0                                  ;
                                        (0323)    PWMA_Start_M                                  ;   then re-enable the PWM.
0B64: 18       POP   A                  (0324)    pop   A                                       ; Setup the return value
0B65: 38 FE    ADD   SP,0xFE            (0325)    ADD   SP, -(STACK_FRAME_SIZE-1)               ; Zap remainder of stack frame
0B67: 70 3F    AND   F,0x3F             
0B69: 71 C0    OR    F,0xC0             
                                        (0326)    RAM_EPILOGUE RAM_USE_CLASS_2
0B6B: 7F       RET                      (0327)    ret
                                        (0328) 
                                        (0329) .ENDSECTION
                                        (0330) 
                                        (0331) ; End of File PWMA.asm
FILE: lib\enc1b_pedge.asm               (0001) ;;*****************************************************************************
0B6C: 43 E1 20 OR    REG[0xE1],0x20     (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: ENC1B_PEDGE.asm
                                        (0004) ;;  Version: 1.3, Updated on 2014/7/14 at 8:13:28
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: DigitalBuffers User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "ENC1B_PEDGE.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  ENC1B_PEDGE_EnableInt
                                        (0030) export _ENC1B_PEDGE_EnableInt
                                        (0031) export  ENC1B_PEDGE_DisableInt
                                        (0032) export _ENC1B_PEDGE_DisableInt
                                        (0033) export  ENC1B_PEDGE_Start
                                        (0034) export _ENC1B_PEDGE_Start
                                        (0035) export  ENC1B_PEDGE_Stop
                                        (0036) export _ENC1B_PEDGE_Stop
                                        (0037) 
                                        (0038) AREA bss (RAM,REL)
                                        (0039) 
                                        (0040) ;-----------------------------------------------
                                        (0041) ;  Constant Definitions
                                        (0042) ;-----------------------------------------------
                                        (0043) 
                                        (0044) 
                                        (0045) ;-----------------------------------------------
                                        (0046) ; Variable Allocation
                                        (0047) ;-----------------------------------------------
                                        (0048) 
                                        (0049) 
                                        (0050) AREA UserModules (ROM, REL)
                                        (0051) 
                                        (0052) .SECTION
                                        (0053) ;-----------------------------------------------------------------------------
                                        (0054) ;  FUNCTION NAME: ENC1B_PEDGE_EnableInt
                                        (0055) ;
                                        (0056) ;  DESCRIPTION:
                                        (0057) ;     Enables the DigBuf's interrupt by setting the interrupt enable mask bit
                                        (0058) ;     associated with this User Module. This function has no effect until and
                                        (0059) ;     unless the global interrupts are enabled (for example by using the
                                        (0060) ;     macro M8C_EnableGInt).
                                        (0061) ;-----------------------------------------------------------------------------
                                        (0062) ;
                                        (0063) ;  ARGUMENTS:    None.
                                        (0064) ;  RETURNS:      Nothing.
                                        (0065) ;  SIDE EFFECTS:
                                        (0066) ;    The A and X registers may be modified by this or future implementations
                                        (0067) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0068) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0069) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0070) ;    functions.
                                        (0071) ;
                                        (0072)  ENC1B_PEDGE_EnableInt:
                                        (0073) _ENC1B_PEDGE_EnableInt:
                                        (0074)    RAM_PROLOGUE RAM_USE_CLASS_1   
                                        (0075)    ENC1B_PEDGE_EnableInt_M
                                        (0076)    RAM_EPILOGUE RAM_USE_CLASS_1
0B6F: 7F       RET                      (0077)    ret
0B70: 41 E1 DF AND   REG[0xE1],0xDF     
                                        (0078) 
                                        (0079) .ENDSECTION
                                        (0080) 
                                        (0081) .SECTION
                                        (0082) ;-----------------------------------------------------------------------------
                                        (0083) ;  FUNCTION NAME: ENC1B_PEDGE_DisableInt
                                        (0084) ;
                                        (0085) ;  DESCRIPTION:
                                        (0086) ;     Disables the DigBuf's interrupt by clearing the interrupt enable mask bit
                                        (0087) ;     associated with this User Module. 
                                        (0088) ;-----------------------------------------------------------------------------
                                        (0089) ;
                                        (0090) ;  ARGUMENTS:    None.
                                        (0091) ;  RETURNS:      Nothing.
                                        (0092) ;  SIDE EFFECTS:
                                        (0093) ;    The A and X registers may be modified by this or future implementations
                                        (0094) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0095) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0096) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0097) ;    functions.
                                        (0098) ;
                                        (0099)  ENC1B_PEDGE_DisableInt:
                                        (0100) _ENC1B_PEDGE_DisableInt:
                                        (0101)    RAM_PROLOGUE RAM_USE_CLASS_1   
                                        (0102)    ENC1B_PEDGE_DisableInt_M
                                        (0103)    RAM_EPILOGUE RAM_USE_CLASS_1
0B73: 7F       RET                      (0104)    ret
0B74: 43 37 01 OR    REG[0x37],0x1      
                                        (0105) 
                                        (0106) .ENDSECTION
                                        (0107) 
                                        (0108) .SECTION
                                        (0109) ;-----------------------------------------------------------------------------
                                        (0110) ;  FUNCTION NAME: ENC1B_PEDGE_Start
                                        (0111) ;
                                        (0112) ;  DESCRIPTION:
                                        (0113) ;     Starts the Digital Buffers within the block.
                                        (0114) ;-----------------------------------------------------------------------------
                                        (0115) ;
                                        (0116) ;  ARGUMENTS:    None
                                        (0117) ;  RETURNS:      Nothing
                                        (0118) ;  SIDE EFFECTS:
                                        (0119) ;    The A and X registers may be modified by this or future implementations
                                        (0120) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0121) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0122) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0123) ;    functions.
                                        (0124) ;
                                        (0125)  ENC1B_PEDGE_Start:
                                        (0126) _ENC1B_PEDGE_Start:
                                        (0127)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0128)    ENC1B_PEDGE_Start_M
                                        (0129)    RAM_EPILOGUE RAM_USE_CLASS_1
0B77: 7F       RET                      (0130)    ret
0B78: 41 37 FE AND   REG[0x37],0xFE     
                                        (0131) 
                                        (0132) .ENDSECTION
                                        (0133) 
                                        (0134) .SECTION
                                        (0135) ;-----------------------------------------------------------------------------
                                        (0136) ;  FUNCTION NAME: ENC1B_PEDGE_Stop
                                        (0137) ;
                                        (0138) ;  DESCRIPTION:
                                        (0139) ;     Stops the Digital Buffers within the block. The outputs are driven low.
                                        (0140) ;-----------------------------------------------------------------------------
                                        (0141) ;
                                        (0142) ;  ARGUMENTS:    None
                                        (0143) ;  RETURNS:      Nothing
                                        (0144) ;  SIDE EFFECTS:
                                        (0145) ;    The A and X registers may be modified by this or future implementations
                                        (0146) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0147) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0148) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0149) ;    functions.
                                        (0150) ;
                                        (0151)  ENC1B_PEDGE_Stop:
                                        (0152) _ENC1B_PEDGE_Stop:
                                        (0153)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0154)    ENC1B_PEDGE_Stop_M
                                        (0155)    RAM_EPILOGUE RAM_USE_CLASS_1
0B7B: 7F       RET                      (0156)    ret
                                        (0157) 
                                        (0158) .ENDSECTION
                                        (0159) 
                                        (0160) 
                                        (0161) ; End of File ENC1B_PEDGE.asm
                                        (0162) 
                                        (0163) 
FILE: lib\enc1b_nedgeint.asm            (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: ENC1B_NEDGEINT.asm
                                        (0004) ;;   Version: Version: 1.60, Updated on 2014/7/14 at 8:13:31
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Counter8 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "ENC1B_NEDGE.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _ENC1B_NEDGE_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _ENC1B_NEDGE_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _ENC1B_NEDGE_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    ;PRESERVE_CPU_CONTEXT
                                        (0081)    ;lcall _My_C_Function
                                        (0082)    ;RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
0B7C: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file ENC1B_NEDGEINT.asm
FILE: lib\enc1b_nedge.asm               (0001) ;;*****************************************************************************
0B7D: 43 DF 02 OR    REG[0xDF],0x2      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: ENC1B_NEDGE.asm
                                        (0004) ;;   Version: 1.60, Updated on 2014/7/14 at 8:13:31
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: DigInv User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "ENC1B_NEDGE.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) 
                                        (0027) ;-----------------------------------------------
                                        (0028) ;  Global Symbols
                                        (0029) ;-----------------------------------------------
                                        (0030) export   ENC1B_NEDGE_EnableInt
                                        (0031) export  _ENC1B_NEDGE_EnableInt
                                        (0032) export   ENC1B_NEDGE_DisableInt
                                        (0033) export  _ENC1B_NEDGE_DisableInt
                                        (0034) export   ENC1B_NEDGE_Start
                                        (0035) export  _ENC1B_NEDGE_Start
                                        (0036) export   ENC1B_NEDGE_Stop
                                        (0037) export  _ENC1B_NEDGE_Stop
                                        (0038) 
                                        (0039) ;-----------------------------------------------
                                        (0040) ;  EQUATES
                                        (0041) ;-----------------------------------------------
                                        (0042) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                        (0043) 
                                        (0044) area UserModules (ROM, REL)
                                        (0045) 
                                        (0046) .SECTION
                                        (0047) ;-----------------------------------------------------------------------------
                                        (0048) ;  FUNCTION NAME: ENC1B_NEDGE_EnableInt
                                        (0049) ;
                                        (0050) ;  DESCRIPTION:
                                        (0051) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                        (0052) ;     bit associated with this User Module. Remember to call the global interrupt
                                        (0053) ;     enable function by using the macro: M8C_EnableGInt.
                                        (0054) ;
                                        (0055) ;-----------------------------------------------------------------------------
                                        (0056) ;
                                        (0057) ;  ARGUMENTS: none
                                        (0058) ;
                                        (0059) ;  RETURNS: none
                                        (0060) ;
                                        (0061) ;  SIDE EFFECTS:
                                        (0062) ;    The A and X registers may be modified by this or future implementations
                                        (0063) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0064) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0065) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0066) ;    functions.
                                        (0067) ;
                                        (0068)  ENC1B_NEDGE_EnableInt:
                                        (0069) _ENC1B_NEDGE_EnableInt:
                                        (0070)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0071)    M8C_EnableIntMask ENC1B_NEDGE_INT_REG, ENC1B_NEDGE_bINT_MASK
                                        (0072)    RAM_EPILOGUE RAM_USE_CLASS_1
0B80: 7F       RET                      (0073)    ret
0B81: 41 DF FD AND   REG[0xDF],0xFD     
                                        (0074) .ENDSECTION
                                        (0075) 
                                        (0076) .SECTION
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) ;  FUNCTION NAME: ENC1B_NEDGE_DisableInt
                                        (0079) ;
                                        (0080) ;  DESCRIPTION:
                                        (0081) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                        (0082) ;     associated with this User Module.
                                        (0083) ;
                                        (0084) ;-----------------------------------------------------------------------------
                                        (0085) ;
                                        (0086) ;  ARGUMENTS:  none
                                        (0087) ;
                                        (0088) ;  RETURNS:  none
                                        (0089) ;
                                        (0090) ;  SIDE EFFECTS:
                                        (0091) ;    The A and X registers may be modified by this or future implementations
                                        (0092) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0093) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0094) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0095) ;    functions.
                                        (0096) ;
                                        (0097)  ENC1B_NEDGE_DisableInt:
                                        (0098) _ENC1B_NEDGE_DisableInt:
                                        (0099)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0100)    M8C_DisableIntMask ENC1B_NEDGE_INT_REG, ENC1B_NEDGE_bINT_MASK
                                        (0101)    RAM_EPILOGUE RAM_USE_CLASS_1
0B84: 7F       RET                      (0102)    ret
                                        (0103) .ENDSECTION
                                        (0104) 
                                        (0105) .SECTION
                                        (0106) ;-----------------------------------------------------------------------------
                                        (0107) ;  FUNCTION NAME: ENC1B_NEDGE_Start
                                        (0108) ;
                                        (0109) ;  DESCRIPTION:
                                        (0110) ;     Sets the start bit in the Control register of this user module.
                                        (0111) ;
                                        (0112) ;-----------------------------------------------------------------------------
                                        (0113) ;
                                        (0114) ;  ARGUMENTS: none
                                        (0115) ;
                                        (0116) ;  RETURNS: none
                                        (0117) ;
                                        (0118) ;  SIDE EFFECTS:
                                        (0119) ;    The A and X registers may be modified by this or future implementations
                                        (0120) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0121) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0122) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0123) ;    functions.
                                        (0124) ;
                                        (0125) ;  THEORY of OPERATION or PROCEDURE:
                                        (0126) ;
                                        (0127) ;     1) Save the Interrupt register
                                        (0128) ;     2) Save the Output register
                                        (0129) ;     3) Save the input register
                                        (0130) ;     4) Switch the output to Disabled - LOW
                                        (0131) ;     5) Disable Interrupt
                                        (0132) ;     6) Start the DigInv
                                        (0133) ;     7) Re-instate the input source
                                        (0134) ;     8) Re-instate the output
                                        (0135) ;     9) Re-instate the Interrupt register
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137)  ENC1B_NEDGE_Start:
                                        (0138) _ENC1B_NEDGE_Start:
                                        (0139)    RAM_PROLOGUE RAM_USE_CLASS_1
0B85: 08       PUSH  A                  (0140)    push  A
                                        (0141) 
                                        (0142)    ; The DigInv must see a positive clock edge in order to "start" itself
                                        (0143)    ; in the correct state.  Once it sees a clock edge, it will follow its
                                        (0144)    ; input source.  To do this, we disable outputs, switch the input source
                                        (0145)    ; to the 48MHz clock, start the DigInv, re-instate the user's input source
                                        (0146)    ; and then re-instate the output.
                                        (0147) 
                                        (0148)    ; disable the interrupt
0B86: 5D DF    MOV   A,REG[0xDF]        (0149)    mov   A, REG[ENC1B_NEDGE_INT_REG]
0B88: 08       PUSH  A                  (0150)    push  A
0B89: 41 DF FD AND   REG[0xDF],0xFD     
0B8C: 71 10    OR    F,0x10             
                                        (0151) 
                                        (0152)    M8C_DisableIntMask ENC1B_NEDGE_INT_REG, ENC1B_NEDGE_bINT_MASK
                                        (0153) 
                                        (0154)    M8C_SetBank1
                                        (0155)    ; set the output to disable - will remain low!
0B8E: 5D 46    MOV   A,REG[0x46]        (0156)    mov   A, REG[ENC1B_NEDGE_OUTPUT_REG]
0B90: 08       PUSH  A                  (0157)    push  A
                                        (0158) 
0B91: 62 46 00 MOV   REG[0x46],0x0      (0159)    mov   REG[ENC1B_NEDGE_OUTPUT_REG], 0
                                        (0160) 
                                        (0161)    ; set the input to the 48MHz clock
0B94: 5D 45    MOV   A,REG[0x45]        (0162)    mov   A, REG[ENC1B_NEDGE_INPUT_REG]
0B96: 08       PUSH  A                  (0163)    push  A
                                        (0164) 
0B97: 62 45 04 MOV   REG[0x45],0x4      (0165)    mov   REG[ENC1B_NEDGE_INPUT_REG], 04
0B9A: 70 EF    AND   F,0xEF             
                                        (0166) 
                                        (0167)    M8C_SetBank0
                                        (0168)    ; start the inverter
0B9C: 43 47 01 OR    REG[0x47],0x1      (0169)    or    REG[ENC1B_NEDGE_CONTROL_REG], bfCONTROL_REG_START_BIT
0B9F: 71 10    OR    F,0x10             
                                        (0170) 
                                        (0171)    ; Re-instate the input
                                        (0172)    M8C_SetBank1
0BA1: 18       POP   A                  (0173)    pop   A
0BA2: 60 45    MOV   REG[0x45],A        (0174)    mov   REG[ENC1B_NEDGE_INPUT_REG], A
                                        (0175) 
                                        (0176)    ; Re-instate the output
0BA4: 18       POP   A                  (0177)    pop   A
0BA5: 60 46    MOV   REG[0x46],A        (0178)    mov   REG[ENC1B_NEDGE_OUTPUT_REG], A
0BA7: 70 EF    AND   F,0xEF             
0BA9: 62 DB FD MOV   REG[0xDB],0xFD     
                                        (0179)    M8C_SetBank0
                                        (0180) 
                                        (0181)    ;clear interrupt
                                        (0182)    M8C_ClearIntFlag INT_CLR1, ENC1B_NEDGE_bINT_MASK
                                        (0183) 
                                        (0184)    ; Re-instate the interrupt state
0BAC: 18       POP   A                  (0185)    pop   A
0BAD: 60 DF    MOV   REG[0xDF],A        (0186)    mov   REG[ENC1B_NEDGE_INT_REG], A
                                        (0187) 
                                        (0188)    ;Done!
0BAF: 18       POP   A                  (0189)    pop   A
                                        (0190)    RAM_EPILOGUE RAM_USE_CLASS_1
0BB0: 7F       RET                      (0191)    ret
                                        (0192) 
                                        (0193) .ENDSECTION
                                        (0194) 
                                        (0195) .SECTION
                                        (0196) ;-----------------------------------------------------------------------------
                                        (0197) ;  FUNCTION NAME: ENC1B_NEDGE_Stop
                                        (0198) ;
                                        (0199) ;  DESCRIPTION:
                                        (0200) ;     Halts operation of the Digital Inverter.  Output is set LOW.
                                        (0201) ;
                                        (0202) ;-----------------------------------------------------------------------------
                                        (0203) ;
                                        (0204) ;  ARGUMENTS: none
                                        (0205) ;
                                        (0206) ;  RETURNS: none
                                        (0207) ;
                                        (0208) ;  SIDE EFFECTS:
                                        (0209) ;    The A and X registers may be modified by this or future implementations
                                        (0210) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0211) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0212) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0213) ;    functions.
                                        (0214) ;
                                        (0215)  ENC1B_NEDGE_Stop:
                                        (0216) _ENC1B_NEDGE_Stop:
                                        (0217) 
                                        (0218)    RAM_PROLOGUE RAM_USE_CLASS_1
0BB1: 41 47 FE AND   REG[0x47],0xFE     (0219)    and   REG[ENC1B_NEDGE_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                        (0220)    RAM_EPILOGUE RAM_USE_CLASS_1
0BB4: 7F       RET                      (0221)    ret
                                        (0222) 
                                        (0223) .ENDSECTION
                                        (0224) 
                                        (0225) ; End of File ENC1B_NEDGE.asm
                                        (0226) 
                                        (0227) 
                                        (0228) 
FILE: lib\enc1a_pedge.asm               (0001) ;;*****************************************************************************
0BB5: 43 E1 01 OR    REG[0xE1],0x1      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: ENC1A_PEDGE.asm
                                        (0004) ;;  Version: 1.3, Updated on 2014/7/14 at 8:13:28
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: DigitalBuffers User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "ENC1A_PEDGE.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  ENC1A_PEDGE_EnableInt
                                        (0030) export _ENC1A_PEDGE_EnableInt
                                        (0031) export  ENC1A_PEDGE_DisableInt
                                        (0032) export _ENC1A_PEDGE_DisableInt
                                        (0033) export  ENC1A_PEDGE_Start
                                        (0034) export _ENC1A_PEDGE_Start
                                        (0035) export  ENC1A_PEDGE_Stop
                                        (0036) export _ENC1A_PEDGE_Stop
                                        (0037) 
                                        (0038) AREA bss (RAM,REL)
                                        (0039) 
                                        (0040) ;-----------------------------------------------
                                        (0041) ;  Constant Definitions
                                        (0042) ;-----------------------------------------------
                                        (0043) 
                                        (0044) 
                                        (0045) ;-----------------------------------------------
                                        (0046) ; Variable Allocation
                                        (0047) ;-----------------------------------------------
                                        (0048) 
                                        (0049) 
                                        (0050) AREA UserModules (ROM, REL)
                                        (0051) 
                                        (0052) .SECTION
                                        (0053) ;-----------------------------------------------------------------------------
                                        (0054) ;  FUNCTION NAME: ENC1A_PEDGE_EnableInt
                                        (0055) ;
                                        (0056) ;  DESCRIPTION:
                                        (0057) ;     Enables the DigBuf's interrupt by setting the interrupt enable mask bit
                                        (0058) ;     associated with this User Module. This function has no effect until and
                                        (0059) ;     unless the global interrupts are enabled (for example by using the
                                        (0060) ;     macro M8C_EnableGInt).
                                        (0061) ;-----------------------------------------------------------------------------
                                        (0062) ;
                                        (0063) ;  ARGUMENTS:    None.
                                        (0064) ;  RETURNS:      Nothing.
                                        (0065) ;  SIDE EFFECTS:
                                        (0066) ;    The A and X registers may be modified by this or future implementations
                                        (0067) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0068) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0069) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0070) ;    functions.
                                        (0071) ;
                                        (0072)  ENC1A_PEDGE_EnableInt:
                                        (0073) _ENC1A_PEDGE_EnableInt:
                                        (0074)    RAM_PROLOGUE RAM_USE_CLASS_1   
                                        (0075)    ENC1A_PEDGE_EnableInt_M
                                        (0076)    RAM_EPILOGUE RAM_USE_CLASS_1
0BB8: 7F       RET                      (0077)    ret
0BB9: 41 E1 FE AND   REG[0xE1],0xFE     
                                        (0078) 
                                        (0079) .ENDSECTION
                                        (0080) 
                                        (0081) .SECTION
                                        (0082) ;-----------------------------------------------------------------------------
                                        (0083) ;  FUNCTION NAME: ENC1A_PEDGE_DisableInt
                                        (0084) ;
                                        (0085) ;  DESCRIPTION:
                                        (0086) ;     Disables the DigBuf's interrupt by clearing the interrupt enable mask bit
                                        (0087) ;     associated with this User Module. 
                                        (0088) ;-----------------------------------------------------------------------------
                                        (0089) ;
                                        (0090) ;  ARGUMENTS:    None.
                                        (0091) ;  RETURNS:      Nothing.
                                        (0092) ;  SIDE EFFECTS:
                                        (0093) ;    The A and X registers may be modified by this or future implementations
                                        (0094) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0095) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0096) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0097) ;    functions.
                                        (0098) ;
                                        (0099)  ENC1A_PEDGE_DisableInt:
                                        (0100) _ENC1A_PEDGE_DisableInt:
                                        (0101)    RAM_PROLOGUE RAM_USE_CLASS_1   
                                        (0102)    ENC1A_PEDGE_DisableInt_M
                                        (0103)    RAM_EPILOGUE RAM_USE_CLASS_1
0BBC: 7F       RET                      (0104)    ret
0BBD: 43 23 01 OR    REG[0x23],0x1      
                                        (0105) 
                                        (0106) .ENDSECTION
                                        (0107) 
                                        (0108) .SECTION
                                        (0109) ;-----------------------------------------------------------------------------
                                        (0110) ;  FUNCTION NAME: ENC1A_PEDGE_Start
                                        (0111) ;
                                        (0112) ;  DESCRIPTION:
                                        (0113) ;     Starts the Digital Buffers within the block.
                                        (0114) ;-----------------------------------------------------------------------------
                                        (0115) ;
                                        (0116) ;  ARGUMENTS:    None
                                        (0117) ;  RETURNS:      Nothing
                                        (0118) ;  SIDE EFFECTS:
                                        (0119) ;    The A and X registers may be modified by this or future implementations
                                        (0120) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0121) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0122) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0123) ;    functions.
                                        (0124) ;
                                        (0125)  ENC1A_PEDGE_Start:
                                        (0126) _ENC1A_PEDGE_Start:
                                        (0127)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0128)    ENC1A_PEDGE_Start_M
                                        (0129)    RAM_EPILOGUE RAM_USE_CLASS_1
0BC0: 7F       RET                      (0130)    ret
0BC1: 41 23 FE AND   REG[0x23],0xFE     
                                        (0131) 
                                        (0132) .ENDSECTION
                                        (0133) 
                                        (0134) .SECTION
                                        (0135) ;-----------------------------------------------------------------------------
                                        (0136) ;  FUNCTION NAME: ENC1A_PEDGE_Stop
                                        (0137) ;
                                        (0138) ;  DESCRIPTION:
                                        (0139) ;     Stops the Digital Buffers within the block. The outputs are driven low.
                                        (0140) ;-----------------------------------------------------------------------------
                                        (0141) ;
                                        (0142) ;  ARGUMENTS:    None
                                        (0143) ;  RETURNS:      Nothing
                                        (0144) ;  SIDE EFFECTS:
                                        (0145) ;    The A and X registers may be modified by this or future implementations
                                        (0146) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0147) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0148) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0149) ;    functions.
                                        (0150) ;
                                        (0151)  ENC1A_PEDGE_Stop:
                                        (0152) _ENC1A_PEDGE_Stop:
                                        (0153)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0154)    ENC1A_PEDGE_Stop_M
                                        (0155)    RAM_EPILOGUE RAM_USE_CLASS_1
0BC4: 7F       RET                      (0156)    ret
                                        (0157) 
                                        (0158) .ENDSECTION
                                        (0159) 
                                        (0160) 
                                        (0161) ; End of File ENC1A_PEDGE.asm
                                        (0162) 
                                        (0163) 
FILE: lib\enc1a_nedge.asm               (0001) ;;*****************************************************************************
0BC5: 43 E1 10 OR    REG[0xE1],0x10     (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: ENC1A_NEDGE.asm
                                        (0004) ;;   Version: 1.60, Updated on 2014/7/14 at 8:13:31
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: DigInv User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2014. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "ENC1A_NEDGE.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) 
                                        (0027) ;-----------------------------------------------
                                        (0028) ;  Global Symbols
                                        (0029) ;-----------------------------------------------
                                        (0030) export   ENC1A_NEDGE_EnableInt
                                        (0031) export  _ENC1A_NEDGE_EnableInt
                                        (0032) export   ENC1A_NEDGE_DisableInt
                                        (0033) export  _ENC1A_NEDGE_DisableInt
                                        (0034) export   ENC1A_NEDGE_Start
                                        (0035) export  _ENC1A_NEDGE_Start
                                        (0036) export   ENC1A_NEDGE_Stop
                                        (0037) export  _ENC1A_NEDGE_Stop
                                        (0038) 
                                        (0039) ;-----------------------------------------------
                                        (0040) ;  EQUATES
                                        (0041) ;-----------------------------------------------
                                        (0042) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                        (0043) 
                                        (0044) area UserModules (ROM, REL)
                                        (0045) 
                                        (0046) .SECTION
                                        (0047) ;-----------------------------------------------------------------------------
                                        (0048) ;  FUNCTION NAME: ENC1A_NEDGE_EnableInt
                                        (0049) ;
                                        (0050) ;  DESCRIPTION:
                                        (0051) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                        (0052) ;     bit associated with this User Module. Remember to call the global interrupt
                                        (0053) ;     enable function by using the macro: M8C_EnableGInt.
                                        (0054) ;
                                        (0055) ;-----------------------------------------------------------------------------
                                        (0056) ;
                                        (0057) ;  ARGUMENTS: none
                                        (0058) ;
                                        (0059) ;  RETURNS: none
                                        (0060) ;
                                        (0061) ;  SIDE EFFECTS:
                                        (0062) ;    The A and X registers may be modified by this or future implementations
                                        (0063) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0064) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0065) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0066) ;    functions.
                                        (0067) ;
                                        (0068)  ENC1A_NEDGE_EnableInt:
                                        (0069) _ENC1A_NEDGE_EnableInt:
                                        (0070)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0071)    M8C_EnableIntMask ENC1A_NEDGE_INT_REG, ENC1A_NEDGE_bINT_MASK
                                        (0072)    RAM_EPILOGUE RAM_USE_CLASS_1
0BC8: 7F       RET                      (0073)    ret
0BC9: 41 E1 EF AND   REG[0xE1],0xEF     
                                        (0074) .ENDSECTION
                                        (0075) 
                                        (0076) .SECTION
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) ;  FUNCTION NAME: ENC1A_NEDGE_DisableInt
                                        (0079) ;
                                        (0080) ;  DESCRIPTION:
                                        (0081) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                        (0082) ;     associated with this User Module.
                                        (0083) ;
                                        (0084) ;-----------------------------------------------------------------------------
                                        (0085) ;
                                        (0086) ;  ARGUMENTS:  none
                                        (0087) ;
                                        (0088) ;  RETURNS:  none
                                        (0089) ;
                                        (0090) ;  SIDE EFFECTS:
                                        (0091) ;    The A and X registers may be modified by this or future implementations
                                        (0092) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0093) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0094) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0095) ;    functions.
                                        (0096) ;
                                        (0097)  ENC1A_NEDGE_DisableInt:
                                        (0098) _ENC1A_NEDGE_DisableInt:
                                        (0099)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0100)    M8C_DisableIntMask ENC1A_NEDGE_INT_REG, ENC1A_NEDGE_bINT_MASK
                                        (0101)    RAM_EPILOGUE RAM_USE_CLASS_1
0BCC: 7F       RET                      (0102)    ret
                                        (0103) .ENDSECTION
                                        (0104) 
                                        (0105) .SECTION
                                        (0106) ;-----------------------------------------------------------------------------
                                        (0107) ;  FUNCTION NAME: ENC1A_NEDGE_Start
                                        (0108) ;
                                        (0109) ;  DESCRIPTION:
                                        (0110) ;     Sets the start bit in the Control register of this user module.
                                        (0111) ;
                                        (0112) ;-----------------------------------------------------------------------------
                                        (0113) ;
                                        (0114) ;  ARGUMENTS: none
                                        (0115) ;
                                        (0116) ;  RETURNS: none
                                        (0117) ;
                                        (0118) ;  SIDE EFFECTS:
                                        (0119) ;    The A and X registers may be modified by this or future implementations
                                        (0120) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0121) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0122) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0123) ;    functions.
                                        (0124) ;
                                        (0125) ;  THEORY of OPERATION or PROCEDURE:
                                        (0126) ;
                                        (0127) ;     1) Save the Interrupt register
                                        (0128) ;     2) Save the Output register
                                        (0129) ;     3) Save the input register
                                        (0130) ;     4) Switch the output to Disabled - LOW
                                        (0131) ;     5) Disable Interrupt
                                        (0132) ;     6) Start the DigInv
                                        (0133) ;     7) Re-instate the input source
                                        (0134) ;     8) Re-instate the output
                                        (0135) ;     9) Re-instate the Interrupt register
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137)  ENC1A_NEDGE_Start:
                                        (0138) _ENC1A_NEDGE_Start:
                                        (0139)    RAM_PROLOGUE RAM_USE_CLASS_1
0BCD: 08       PUSH  A                  (0140)    push  A
                                        (0141) 
                                        (0142)    ; The DigInv must see a positive clock edge in order to "start" itself
                                        (0143)    ; in the correct state.  Once it sees a clock edge, it will follow its
                                        (0144)    ; input source.  To do this, we disable outputs, switch the input source
                                        (0145)    ; to the 48MHz clock, start the DigInv, re-instate the user's input source
                                        (0146)    ; and then re-instate the output.
                                        (0147) 
                                        (0148)    ; disable the interrupt
0BCE: 5D E1    MOV   A,REG[0xE1]        (0149)    mov   A, REG[ENC1A_NEDGE_INT_REG]
0BD0: 08       PUSH  A                  (0150)    push  A
0BD1: 41 E1 EF AND   REG[0xE1],0xEF     
0BD4: 71 10    OR    F,0x10             
                                        (0151) 
                                        (0152)    M8C_DisableIntMask ENC1A_NEDGE_INT_REG, ENC1A_NEDGE_bINT_MASK
                                        (0153) 
                                        (0154)    M8C_SetBank1
                                        (0155)    ; set the output to disable - will remain low!
0BD6: 5D 32    MOV   A,REG[0x32]        (0156)    mov   A, REG[ENC1A_NEDGE_OUTPUT_REG]
0BD8: 08       PUSH  A                  (0157)    push  A
                                        (0158) 
0BD9: 62 32 00 MOV   REG[0x32],0x0      (0159)    mov   REG[ENC1A_NEDGE_OUTPUT_REG], 0
                                        (0160) 
                                        (0161)    ; set the input to the 48MHz clock
0BDC: 5D 31    MOV   A,REG[0x31]        (0162)    mov   A, REG[ENC1A_NEDGE_INPUT_REG]
0BDE: 08       PUSH  A                  (0163)    push  A
                                        (0164) 
0BDF: 62 31 04 MOV   REG[0x31],0x4      (0165)    mov   REG[ENC1A_NEDGE_INPUT_REG], 04
0BE2: 70 EF    AND   F,0xEF             
                                        (0166) 
                                        (0167)    M8C_SetBank0
                                        (0168)    ; start the inverter
0BE4: 43 33 01 OR    REG[0x33],0x1      (0169)    or    REG[ENC1A_NEDGE_CONTROL_REG], bfCONTROL_REG_START_BIT
0BE7: 71 10    OR    F,0x10             
                                        (0170) 
                                        (0171)    ; Re-instate the input
                                        (0172)    M8C_SetBank1
0BE9: 18       POP   A                  (0173)    pop   A
0BEA: 60 31    MOV   REG[0x31],A        (0174)    mov   REG[ENC1A_NEDGE_INPUT_REG], A
                                        (0175) 
                                        (0176)    ; Re-instate the output
0BEC: 18       POP   A                  (0177)    pop   A
0BED: 60 32    MOV   REG[0x32],A        (0178)    mov   REG[ENC1A_NEDGE_OUTPUT_REG], A
0BEF: 70 EF    AND   F,0xEF             
0BF1: 62 DB EF MOV   REG[0xDB],0xEF     
                                        (0179)    M8C_SetBank0
                                        (0180) 
                                        (0181)    ;clear interrupt
                                        (0182)    M8C_ClearIntFlag INT_CLR1, ENC1A_NEDGE_bINT_MASK
                                        (0183) 
                                        (0184)    ; Re-instate the interrupt state
0BF4: 18       POP   A                  (0185)    pop   A
0BF5: 60 E1    MOV   REG[0xE1],A        (0186)    mov   REG[ENC1A_NEDGE_INT_REG], A
                                        (0187) 
                                        (0188)    ;Done!
0BF7: 18       POP   A                  (0189)    pop   A
                                        (0190)    RAM_EPILOGUE RAM_USE_CLASS_1
0BF8: 7F       RET                      (0191)    ret
                                        (0192) 
                                        (0193) .ENDSECTION
                                        (0194) 
                                        (0195) .SECTION
                                        (0196) ;-----------------------------------------------------------------------------
                                        (0197) ;  FUNCTION NAME: ENC1A_NEDGE_Stop
                                        (0198) ;
                                        (0199) ;  DESCRIPTION:
                                        (0200) ;     Halts operation of the Digital Inverter.  Output is set LOW.
                                        (0201) ;
                                        (0202) ;-----------------------------------------------------------------------------
                                        (0203) ;
                                        (0204) ;  ARGUMENTS: none
                                        (0205) ;
                                        (0206) ;  RETURNS: none
                                        (0207) ;
                                        (0208) ;  SIDE EFFECTS:
                                        (0209) ;    The A and X registers may be modified by this or future implementations
                                        (0210) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0211) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0212) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0213) ;    functions.
                                        (0214) ;
                                        (0215)  ENC1A_NEDGE_Stop:
                                        (0216) _ENC1A_NEDGE_Stop:
                                        (0217) 
                                        (0218)    RAM_PROLOGUE RAM_USE_CLASS_1
0BF9: 41 33 FE AND   REG[0x33],0xFE     (0219)    and   REG[ENC1A_NEDGE_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                        (0220)    RAM_EPILOGUE RAM_USE_CLASS_1
0BFC: 7F       RET                      (0221)    ret
                                        (0222) 
                                        (0223) .ENDSECTION
                                        (0224) 
                                        (0225) ; End of File ENC1A_NEDGE.asm
                                        (0226) 
                                        (0227) 
                                        (0228) 
FILE: C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
(0001) /**
(0002) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0003) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Table of commands^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0004) 
(0005) MAV 	 		'a' //Move at velocity
(0006) MOV 	 		'b' //move at duty cycle
(0007) GETV 	 		'c' //get velocity
(0008) SRV0_POS 	 	'd' //set servo positions for servo 0 (starts PWM)
(0009) SRV1_POS 	 	'e' //set servo positions for servo 1 (starts PWM)
(0010) SRV0_STP 		'f' //Turns a servo 0 off (stops PWM)
(0011) SRV1_STP 		'g' //Turns a servo 1 off (stops PWM)
(0012) GETC1	 		'h' //get encoder1 count
(0013) GETC2	 		'i' //get encoder2 count
(0014) RSTC1	 		'j' //reset encoder1 count
(0015) RSTC2	 		'k' //reset encoder2 count
(0016) STOP			'l' //stop motors
(0017) FORWARD			'm' //sets drive mode to forward
(0018) BACKWARD		'n' //sets drive mode to backward
(0019) TURNL			'o' //sets drive mode to left turn
(0020) TURNR			'p' //sets drive mode to right turn
(0021) 
(0022) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0023) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Serial Limitations^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0024) 
(0025) Baude rate			115200
(0026) RX Buffer size		16 bytes
(0027) 
(0028) UART RX 			P2[7]
(0029) UART TX				P0[1]
(0030) 
(0031) * Theoretically 115200 bytes can be sent in one second, at minimum, and 115216 at maximum before buffer overflow.
(0032) 
(0033) * All UART commands have either one or zero parameters. All commands must be terminated with an ACII BEL (0x07).
(0034)   Command parameters may be space delimited from the command or can be sent as just a single string. 
(0035) 
(0036) Examples:
(0037) 
(0038) "a25" - move at velcoity 25 RPM.
(0039) "a 25" - move at velocity 25 RPM
(0040) 
(0041) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0042) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Servo Information^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0043) 
(0044) Servo0		P0[3] (MISC0)
(0045) Servo1		P0[7] (MISC2)
(0046) 
(0047) 16 bit resoltion for each. Every tick = 1 us.
(0048) 
(0049) Servo accepts PWM range from ~700 us to ~2200 us for a 180* servo.
(0050) 
(0051) RPi will convert servo angle to pulse width and send to PSoC. Then the servo angle will be set by writing the
(0052) Pulse width to the PWM register.
(0053) 
(0054) **NOTE**
(0055) Higer resolution can be achieved by using a faster clock and allowing for more ticks but 1 Mhz clock 1 us tick
(0056) makes calculations a little easier.
(0057) 
(0058) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0059) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Drive Modes^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0060) 
(0061) The motor driver must be configured for each of our drive modes. The drive modes are defined as follows:
(0062) 
(0063) INPUT		1A		1B		2A		2B
(0064) =======================================
(0065) Forward		1		0		1		0
(0066) Backward	0		1		0		1
(0067) Left		1		0		0		1
(0068) Right		0		1		1		0
(0069) 
(0070) In general for one motor
(0071) 
(0072) INPUT		A		B
(0073) ======================
(0074) Drift		1		1 	(causes robot to coast)
(0075) CCW			0		1
(0076) CW			1		0
(0077) Stop		0		0
(0078) 
(0079) If STDBY is asserted (ie. pulled LOW) then all modes are treated as STOP.
(0080) 
(0081) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0082) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Debug Mode^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(0083) 
(0084) A debug mode is provided for getting serial print statements to indicate useful data when passing commands
(0085) to the PSoC. To enable this mode assert MISC7 and MISC8 as high at power on. (ie, connect MISC7 and MISC8
(0086) to VCC before powering on).
(0087) 
(0088) After the init() function is called their states will be read and a flag will be set according to those states.
(0089) If debug mode is not desired merely leave those pins floating.
(0090) 
(0091) MISC7		P1[2]
(0092) MISC8		P1[3]
(0093) 
(0094) */
(0095) 
(0096) #include <stdlib.h>
(0097) #include <m8c.h>        // part specific constants and macros
(0098) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0099) 
(0100) #pragma interrupt_handler encoder1_ISR
(0101) #pragma interrupt_handler encoder2_ISR
(0102) 
(0103) #define 	stateA1 		0x20
(0104) #define 	stateB1 		0x08
(0105) #define 	stateA2 		0x10
(0106) #define 	stateB2 		0x04
(0107) 
(0108) const BYTE	debug_mask	=	MISC7_MASK | MISC8_MASK;
(0109) const char 	TERM		=	0x07;
(0110) 
(0111) const double tick_time = 0.0000000208333333;
(0112) const double encoder_res = 0.0357142857142857;
(0113) 
(0114) BOOL command_flag 		=	FALSE;
(0115) BOOL debug				=	FALSE;
(0116) 
(0117) int i = 0; //loop var
(0118) 
(0119) BYTE curPrt1;
(0120) BYTE prevPrt1;
(0121) BYTE curPrt2;
(0122) BYTE prevPrt2;
(0123) 
(0124) signed long int count1 = 0;
(0125) signed long int count2 = 0;
(0126) 
(0127) void init(void);
(0128) void action(char command, char* param);
(0129) double getVelocity(void);
(0130) 
(0131) void main(void)
(0132) {
__UserModules_end|__text_start|_main|_main:
  param                --> X+2
  command              --> X+1
  data                 --> X+0
    0BFD: 10       PUSH  X
    0BFE: 4F       MOV   X,SP
    0BFF: 38 04    ADD   SP,0x4
(0133) 	char command;
(0134) 	char* param;
(0135) 	char data;
(0136) 	
(0137) 	init();
    0C01: 90 D7    CALL  _init
    0C03: 80 CF    JMP   0x0CD3
(0138) 	
(0139) 	while(1)
(0140) 	{
(0141) 		//read the state of encoders. this will be needed if we interrupt.
(0142) 		prevPrt1 = (ENC1A_Data_ADDR & (ENC1A_MASK | ENC1B_MASK));
    0C05: 5D 08    MOV   A,REG[0x8]
    0C07: 21 50    AND   A,0x50
    0C09: 62 D0 00 MOV   REG[0xD0],0x0
    0C0C: 53 30    MOV   [prevPrt1],A
(0143) 		prevPrt2 = (ENC2A_Data_ADDR & (ENC2A_MASK | ENC2B_MASK));
    0C0E: 5D 08    MOV   A,REG[0x8]
    0C10: 21 28    AND   A,0x28
    0C12: 62 D0 00 MOV   REG[0xD0],0x0
    0C15: 53 2E    MOV   [prevPrt2],A
(0144) 		
(0145) 		data = UART_cReadChar(); //check for data
    0C17: 10       PUSH  X
    0C18: 7C 08 DE LCALL _UART_cReadChar
    0C1B: 20       POP   X
    0C1C: 54 00    MOV   [X+0],A
(0146) 		
(0147) 		if (!command_flag && data) //no command has been read and data is valid (not null)
    0C1E: 62 D0 00 MOV   REG[0xD0],0x0
    0C21: 3C 2B 00 CMP   [command_flag],0x0
    0C24: B0 22    JNZ   0x0C47
    0C26: 3D 00 00 CMP   [X+0],0x0
    0C29: A0 1D    JZ    0x0C47
(0148) 		{
(0149) 			if (debug)
    0C2B: 62 D0 00 MOV   REG[0xD0],0x0
    0C2E: 3C 31 00 CMP   [debug],0x0
    0C31: A0 08    JZ    0x0C3A
(0150) 				UART_PutChar(data);
    0C33: 10       PUSH  X
    0C34: 52 00    MOV   A,[X+0]
    0C36: 7C 08 CE LCALL _UART_PutChar
    0C39: 20       POP   X
(0151) 			
(0152) 			command_flag = TRUE;
    0C3A: 62 D0 00 MOV   REG[0xD0],0x0
    0C3D: 55 2B 01 MOV   [command_flag],0x1
(0153) 			command = data;
    0C40: 52 00    MOV   A,[X+0]
    0C42: 54 01    MOV   [X+1],A
(0154) 			data = '\0';
    0C44: 56 00 00 MOV   [X+0],0x0
(0155) 		}
(0156) 		if (data && command_flag)//command byte read and data is valid (not null)
    0C47: 3D 00 00 CMP   [X+0],0x0
    0C4A: A0 88    JZ    0x0CD3
    0C4C: 62 D0 00 MOV   REG[0xD0],0x0
    0C4F: 3C 2B 00 CMP   [command_flag],0x0
    0C52: A0 80    JZ    0x0CD3
(0157) 		{
(0158) 			if (data == TERM) //command terminator read
    0C54: 62 D0 00 MOV   REG[0xD0],0x0
    0C57: 50 01    MOV   A,0x1
    0C59: 10       PUSH  X
    0C5A: 57 A1    MOV   X,0xA1
    0C5C: 28       ROMX  
    0C5D: 20       POP   X
    0C5E: 53 20    MOV   [__r0],A
    0C60: 52 00    MOV   A,[X+0]
    0C62: 3A 20    CMP   A,[__r0]
    0C64: B0 3B    JNZ   0x0CA0
(0159) 			{
(0160) 				command_flag = FALSE;
    0C66: 62 D0 00 MOV   REG[0xD0],0x0
    0C69: 55 2B 00 MOV   [command_flag],0x0
(0161) 				param[i] = '\0'; //null terminate parameter string
    0C6C: 62 D0 00 MOV   REG[0xD0],0x0
    0C6F: 51 2A    MOV   A,[i+1]
    0C71: 03 03    ADD   A,[X+3]
    0C73: 62 D0 00 MOV   REG[0xD0],0x0
    0C76: 53 1F    MOV   [__r1],A
    0C78: 62 D0 00 MOV   REG[0xD0],0x0
    0C7B: 51 29    MOV   A,[i]
    0C7D: 0B 02    ADC   A,[X+2]
    0C7F: 62 D0 00 MOV   REG[0xD0],0x0
    0C82: 60 D5    MOV   REG[0xD5],A
    0C84: 50 00    MOV   A,0x0
    0C86: 3F 1F    MVI   [__r1],A
(0162) 				action(command, param);
    0C88: 52 02    MOV   A,[X+2]
    0C8A: 08       PUSH  A
    0C8B: 52 03    MOV   A,[X+3]
    0C8D: 08       PUSH  A
    0C8E: 52 01    MOV   A,[X+1]
    0C90: 08       PUSH  A
    0C91: 93 FC    CALL  _action
    0C93: 38 FD    ADD   SP,0xFD
(0163) 				i = 0; //reset counter
    0C95: 62 D0 00 MOV   REG[0xD0],0x0
    0C98: 55 2A 00 MOV   [i+1],0x0
    0C9B: 55 29 00 MOV   [i],0x0
(0164) 			}
    0C9E: 80 34    JMP   0x0CD3
(0165) 			else //read parameter byte 
(0166) 			{
(0167) 				if (debug)
    0CA0: 62 D0 00 MOV   REG[0xD0],0x0
    0CA3: 3C 31 00 CMP   [debug],0x0
    0CA6: A0 08    JZ    0x0CAF
(0168) 					UART_PutChar(data);
    0CA8: 10       PUSH  X
    0CA9: 52 00    MOV   A,[X+0]
    0CAB: 7C 08 CE LCALL _UART_PutChar
    0CAE: 20       POP   X
(0169) 				
(0170) 				param[i] = data;
    0CAF: 62 D0 00 MOV   REG[0xD0],0x0
    0CB2: 51 2A    MOV   A,[i+1]
    0CB4: 03 03    ADD   A,[X+3]
    0CB6: 62 D0 00 MOV   REG[0xD0],0x0
    0CB9: 53 1F    MOV   [__r1],A
    0CBB: 62 D0 00 MOV   REG[0xD0],0x0
    0CBE: 51 29    MOV   A,[i]
    0CC0: 0B 02    ADC   A,[X+2]
    0CC2: 62 D0 00 MOV   REG[0xD0],0x0
    0CC5: 60 D5    MOV   REG[0xD5],A
    0CC7: 52 00    MOV   A,[X+0]
    0CC9: 3F 1F    MVI   [__r1],A
(0171) 				i++;
    0CCB: 62 D0 00 MOV   REG[0xD0],0x0
    0CCE: 76 2A    INC   [i+1]
    0CD0: 0E 29 00 ADC   [i],0x0
(0172) 			}
(0173) 		}
(0174) 	}
    0CD3: 8F 31    JMP   0x0C05
    0CD5: 38 FC    ADD   SP,0xFC
    0CD7: 20       POP   X
    0CD8: 8F FF    JMP   0x0CD8
(0175) }
(0176) 
(0177) void init(void)
(0178) {
_init:
  debug_conf           --> X+0
    0CDA: 10       PUSH  X
    0CDB: 4F       MOV   X,SP
    0CDC: 38 01    ADD   SP,0x1
(0179) 	BYTE debug_conf;
(0180) 	
(0181) 	//enable the positive edge and falling edge paramers
(0182) 	ENC1A_PEDGE_Start();
    0CDE: 10       PUSH  X
    0CDF: 7C 0B BD LCALL _ENC1A_PEDGE_Start
(0183) 	ENC1B_PEDGE_Start();
    0CE2: 7C 0B 74 LCALL _ENC1B_PEDGE_Start
(0184) 	ENC1A_NEDGE_Start();
    0CE5: 7C 0B CD LCALL _ENC1A_NEDGE_Start
(0185) 	ENC1B_NEDGE_Start();
    0CE8: 7C 0B 85 LCALL _ENC1B_NEDGE_Start
(0186) 	
(0187) 	//enable the falling edge and positive edge interrupts for Encoder 1
(0188) 	ENC1A_PEDGE_EnableInt();
    0CEB: 7C 0B B5 LCALL _ENC1A_PEDGE_EnableInt
(0189) 	ENC1B_PEDGE_EnableInt();
    0CEE: 7C 0B 6C LCALL _ENC1B_PEDGE_EnableInt
(0190) 	ENC1A_NEDGE_EnableInt();
    0CF1: 7C 0B C5 LCALL _ENC1A_NEDGE_EnableInt
(0191) 	ENC1B_NEDGE_EnableInt();
    0CF4: 7C 0B 7D LCALL _ENC1B_NEDGE_EnableInt
(0192) 	
(0193) 	//Start motor speed PWMs
(0194) 	PWMA_Start();
    0CF7: 7C 0B 2E LCALL _PWMA_Start
(0195) 	PWMB_Start();
    0CFA: 7C 0A E7 LCALL _PWMB_Start
(0196) 	
(0197) 	//Start servos
(0198) 	Servo0_Start();
    0CFD: 7C 0A 8A LCALL _Servo0_Start
(0199) 	Servo1_Start();
    0D00: 7C 0A 2D LCALL _Servo1_Start
(0200) 	
(0201) 	//start the UART
(0202) 	UART_Start(UART_PARITY_NONE);
    0D03: 50 00    MOV   A,0x0
    0D05: 7C 08 5A LCALL _UART_Start
(0203) 	
(0204) 	//start the Velocity Timer
(0205) 	VelTimer_Start();
    0D08: 7C 07 14 LCALL _VelTimer_Start
    0D0B: 20       POP   X
(0206) 	
(0207) 	//enable appropriate interrupts
(0208) 	M8C_EnableIntMask(INT_MSK0, INT_MSK0_GPIO);
    0D0C: 43 E0 20 OR    REG[0xE0],0x20
(0209) 	M8C_EnableIntMask(INT_MSK1, INT_MSK1_DBB00);
    0D0F: 43 E1 01 OR    REG[0xE1],0x1
(0210) 	M8C_EnableIntMask(INT_MSK1, INT_MSK1_DBB11);
    0D12: 43 E1 20 OR    REG[0xE1],0x20
(0211) 	M8C_EnableGInt;
    0D15: 71 01    OR    F,0x1
(0212) 	
(0213) 	UART_PutCRLF();
    0D17: 10       PUSH  X
    0D18: 7C 09 83 LCALL _UART_PutCRLF
(0214) 	UART_CPutString("KIPR bots roll out!");
    0D1B: 50 03    MOV   A,0x3
    0D1D: 08       PUSH  A
    0D1E: 50 39    MOV   A,0x39
    0D20: 5C       MOV   X,A
    0D21: 18       POP   A
    0D22: 7C 09 71 LCALL _UART_CPutString
(0215) 	UART_PutCRLF();	
    0D25: 7C 09 83 LCALL _UART_PutCRLF
    0D28: 20       POP   X
(0216) 		
(0217) 	//clear drive mode settings for MISC7
(0218) 	MISC7_DriveMode_0_ADDR &= ~MISC7_MASK;
    0D29: 71 10    OR    F,0x10
    0D2B: 41 04 FB AND   REG[0x4],0xFB
(0219) 	MISC7_DriveMode_1_ADDR &= ~MISC7_MASK;
    0D2E: 41 05 FB AND   REG[0x5],0xFB
(0220) 	MISC7_DriveMode_2_ADDR &= ~MISC7_MASK;
    0D31: 70 CF    AND   F,0xCF
    0D33: 41 07 FB AND   REG[0x7],0xFB
(0221) 	
(0222) 	//clear drive mode settings for MISC8
(0223) 	MISC8_DriveMode_0_ADDR &= ~MISC8_MASK;
    0D36: 71 10    OR    F,0x10
    0D38: 41 04 F7 AND   REG[0x4],0xF7
(0224) 	MISC8_DriveMode_1_ADDR &= ~MISC8_MASK;
    0D3B: 41 05 F7 AND   REG[0x5],0xF7
(0225) 	MISC8_DriveMode_2_ADDR &= ~MISC8_MASK;
    0D3E: 70 CF    AND   F,0xCF
    0D40: 41 07 F7 AND   REG[0x7],0xF7
(0226) 	
(0227) 	//now that their settings are cleared set their mode to
(0228) 	//HIGH-Z to use them as debug point inputs.
(0229) 	MISC7_DriveMode_1_ADDR |= MISC7_MASK;
    0D43: 71 10    OR    F,0x10
    0D45: 43 05 04 OR    REG[0x5],0x4
(0230) 	
(0231) 	MISC8_DriveMode_1_ADDR |= MISC8_MASK;
    0D48: 43 05 08 OR    REG[0x5],0x8
(0232) 	
(0233) 	//read the debug inputs, if they are high then they are
(0234) 	//being purposefully asserted to enter debug mode.
(0235) 	debug_conf = (MISC7_Data_ADDR & MISC7_MASK) | (MISC8_Data_ADDR & MISC8_MASK);
    0D4B: 70 CF    AND   F,0xCF
    0D4D: 5D 04    MOV   A,REG[0x4]
    0D4F: 62 D0 00 MOV   REG[0xD0],0x0
    0D52: 53 20    MOV   [__r0],A
    0D54: 26 20 08 AND   [__r0],0x8
    0D57: 5D 04    MOV   A,REG[0x4]
    0D59: 53 1E    MOV   [__r2],A
    0D5B: 26 1E 04 AND   [__r2],0x4
    0D5E: 51 1E    MOV   A,[__r2]
    0D60: 2A 20    OR    A,[__r0]
    0D62: 54 00    MOV   [X+0],A
(0236) 	
(0237) 	if (debug_conf == debug_mask)
    0D64: 50 01    MOV   A,0x1
    0D66: 10       PUSH  X
    0D67: 57 A0    MOV   X,0xA0
    0D69: 28       ROMX  
    0D6A: 20       POP   X
    0D6B: 53 20    MOV   [__r0],A
    0D6D: 52 00    MOV   A,[X+0]
    0D6F: 3A 20    CMP   A,[__r0]
    0D71: B0 07    JNZ   0x0D79
(0238) 		debug = TRUE;
    0D73: 62 D0 00 MOV   REG[0xD0],0x0
    0D76: 55 31 01 MOV   [debug],0x1
(0239) 	
(0240) 	//afterwards reset MISC pins to their intended state
(0241) 	MISC7_DriveMode_0_ADDR &= ~MISC7_MASK;
    0D79: 71 10    OR    F,0x10
    0D7B: 41 04 FB AND   REG[0x4],0xFB
(0242) 	MISC7_DriveMode_1_ADDR &= ~MISC7_MASK;
    0D7E: 41 05 FB AND   REG[0x5],0xFB
(0243) 	MISC7_DriveMode_2_ADDR &= ~MISC7_MASK;
    0D81: 70 CF    AND   F,0xCF
    0D83: 41 07 FB AND   REG[0x7],0xFB
(0244) 	
(0245) 	MISC8_DriveMode_0_ADDR &= ~MISC8_MASK;
    0D86: 71 10    OR    F,0x10
    0D88: 41 04 F7 AND   REG[0x4],0xF7
(0246) 	MISC8_DriveMode_1_ADDR &= ~MISC8_MASK;
    0D8B: 41 05 F7 AND   REG[0x5],0xF7
(0247) 	MISC8_DriveMode_2_ADDR &= ~MISC8_MASK;
    0D8E: 70 CF    AND   F,0xCF
    0D90: 41 07 F7 AND   REG[0x7],0xF7
(0248) 	
(0249) 	//set MISC7 and MISC8 to HIGH-Z Analog
(0250) 	MISC7_DriveMode_2_ADDR |= MISC7_MASK;
    0D93: 43 07 04 OR    REG[0x7],0x4
(0251) 	MISC7_DriveMode_1_ADDR |= MISC7_MASK;
    0D96: 71 10    OR    F,0x10
    0D98: 43 05 04 OR    REG[0x5],0x4
(0252) 	
(0253) 	MISC8_DriveMode_2_ADDR |= MISC8_MASK;
    0D9B: 70 CF    AND   F,0xCF
    0D9D: 43 07 08 OR    REG[0x7],0x8
(0254) 	MISC8_DriveMode_1_ADDR |= MISC8_MASK;
    0DA0: 71 10    OR    F,0x10
    0DA2: 43 05 08 OR    REG[0x5],0x8
    0DA5: 70 CF    AND   F,0xCF
    0DA7: 38 FF    ADD   SP,0xFF
    0DA9: 20       POP   X
    0DAA: 7F       RET   
(0255) }
(0256) 
(0257) /* Calculates the velocity in RPMs and returns the value */
(0258) double getVelocity(void)
(0259) {
_getVelocity:
  initTicks            --> X+18
  endTicks             --> X+16
  vel                  --> X+12
  ticksDone            --> X+8
  initCount            --> X+4
  diff                 --> X+0
    0DAB: 10       PUSH  X
    0DAC: 4F       MOV   X,SP
    0DAD: 38 16    ADD   SP,0x16
(0260) 	double vel = 0;
    0DAF: 56 0C 00 MOV   [X+12],0x0
    0DB2: 56 0D 00 MOV   [X+13],0x0
    0DB5: 56 0E 00 MOV   [X+14],0x0
    0DB8: 56 0F 00 MOV   [X+15],0x0
(0261) 	DWORD* endTicks; //ending value of counter
(0262) 	DWORD* initTicks; //initial counter reg value
(0263) 	DWORD ticksDone = 14; //number of ticks til done looping
    0DBB: 56 08 00 MOV   [X+8],0x0
    0DBE: 56 09 00 MOV   [X+9],0x0
    0DC1: 56 0A 00 MOV   [X+10],0x0
    0DC4: 56 0B 0E MOV   [X+11],0xE
(0264) 	DWORD diff = 0; //difference between current count reg and 
    0DC7: 56 00 00 MOV   [X+0],0x0
    0DCA: 56 01 00 MOV   [X+1],0x0
    0DCD: 56 02 00 MOV   [X+2],0x0
    0DD0: 56 03 00 MOV   [X+3],0x0
(0265) 	signed long initCount = 0;
    0DD3: 56 04 00 MOV   [X+4],0x0
    0DD6: 56 05 00 MOV   [X+5],0x0
    0DD9: 56 06 00 MOV   [X+6],0x0
    0DDC: 56 07 00 MOV   [X+7],0x0
(0266) 	
(0267) 	VelTimer_ReadTimer(initTicks); //read the counter
    0DDF: 10       PUSH  X
    0DE0: 52 12    MOV   A,[X+18]
    0DE2: 08       PUSH  A
    0DE3: 52 13    MOV   A,[X+19]
    0DE5: 5C       MOV   X,A
    0DE6: 18       POP   A
    0DE7: 7C 07 AA LCALL _VelTimer_CaptureCounter|_VelTimer_ReadTimer|VelTimer_ReadTimer
    0DEA: 20       POP   X
(0268) 	initCount = count1;
    0DEB: 62 D0 00 MOV   REG[0xD0],0x0
    0DEE: 51 21    MOV   A,[count1]
    0DF0: 54 04    MOV   [X+4],A
    0DF2: 51 22    MOV   A,[count1+1]
    0DF4: 54 05    MOV   [X+5],A
    0DF6: 51 23    MOV   A,[count1+2]
    0DF8: 54 06    MOV   [X+6],A
    0DFA: 51 24    MOV   A,[count1+3]
    0DFC: 54 07    MOV   [X+7],A
(0269) 	
(0270) 	//keep reading the value until the difference between first and current is large enough
(0271) 	do 
(0272) 	{
(0273) 		diff = abs(abs(count1) - abs(initCount));
    0DFE: 62 D0 00 MOV   REG[0xD0],0x0
    0E01: 51 24    MOV   A,[count1+3]
    0E03: 62 D0 00 MOV   REG[0xD0],0x0
    0E06: 53 1F    MOV   [__r1],A
    0E08: 62 D0 00 MOV   REG[0xD0],0x0
    0E0B: 51 23    MOV   A,[count1+2]
    0E0D: 62 D0 00 MOV   REG[0xD0],0x0
    0E10: 08       PUSH  A
    0E11: 51 1F    MOV   A,[__r1]
    0E13: 08       PUSH  A
    0E14: 7C 1E 2D LCALL _abs
    0E17: 38 FE    ADD   SP,0xFE
    0E19: 62 D0 00 MOV   REG[0xD0],0x0
    0E1C: 51 1F    MOV   A,[__r1]
    0E1E: 54 15    MOV   [X+21],A
    0E20: 51 20    MOV   A,[__r0]
    0E22: 54 14    MOV   [X+20],A
    0E24: 52 07    MOV   A,[X+7]
    0E26: 53 1D    MOV   [__r3],A
    0E28: 52 06    MOV   A,[X+6]
    0E2A: 08       PUSH  A
    0E2B: 51 1D    MOV   A,[__r3]
    0E2D: 08       PUSH  A
    0E2E: 7C 1E 2D LCALL _abs
    0E31: 62 D0 00 MOV   REG[0xD0],0x0
    0E34: 52 15    MOV   A,[X+21]
    0E36: 12 1F    SUB   A,[__r1]
    0E38: 53 1F    MOV   [__r1],A
    0E3A: 52 14    MOV   A,[X+20]
    0E3C: 1A 20    SBB   A,[__r0]
    0E3E: 08       PUSH  A
    0E3F: 51 1F    MOV   A,[__r1]
    0E41: 08       PUSH  A
    0E42: 7C 1E 2D LCALL _abs
    0E45: 38 FC    ADD   SP,0xFC
    0E47: 62 D0 00 MOV   REG[0xD0],0x0
    0E4A: 51 1F    MOV   A,[__r1]
    0E4C: 54 03    MOV   [X+3],A
    0E4E: 51 20    MOV   A,[__r0]
    0E50: 54 02    MOV   [X+2],A
    0E52: 48 02 80 TST   [X+2],0x80
    0E55: A0 09    JZ    0x0E5F
    0E57: 56 01 FF MOV   [X+1],0xFF
    0E5A: 56 00 FF MOV   [X+0],0xFF
    0E5D: 80 07    JMP   0x0E65
    0E5F: 56 01 00 MOV   [X+1],0x0
    0E62: 56 00 00 MOV   [X+0],0x0
(0274) 	}
(0275) 	while(diff > ticksDone);
    0E65: 52 0B    MOV   A,[X+11]
    0E67: 13 03    SUB   A,[X+3]
    0E69: 52 0A    MOV   A,[X+10]
    0E6B: 1B 02    SBB   A,[X+2]
    0E6D: 52 09    MOV   A,[X+9]
    0E6F: 1B 01    SBB   A,[X+1]
    0E71: 52 08    MOV   A,[X+8]
    0E73: 1B 00    SBB   A,[X+0]
    0E75: CF 88    JC    0x0DFE
(0276) 	
(0277) 	VelTimer_ReadTimer(endTicks);
    0E77: 10       PUSH  X
    0E78: 52 10    MOV   A,[X+16]
    0E7A: 08       PUSH  A
    0E7B: 52 11    MOV   A,[X+17]
    0E7D: 5C       MOV   X,A
    0E7E: 18       POP   A
    0E7F: 7C 07 AA LCALL _VelTimer_CaptureCounter|_VelTimer_ReadTimer|VelTimer_ReadTimer
    0E82: 20       POP   X
(0278) 	
(0279) 	vel = encoder_res*diff/(abs(*initTicks - *endTicks)*tick_time);
    0E83: 62 D0 00 MOV   REG[0xD0],0x0
FILE: C:\Users\Hobo\DOCUME~1\GitHub\KIPR-O~1\Robot2\PSOCCO~1\KIPR_2\KIPR_2\KIPR_2\main.c
(0281) 	return vel;	
    107B: 52 0C    MOV   A,[X+12]
    107D: 53 20    MOV   [__r0],A
    107F: 52 0D    MOV   A,[X+13]
    1081: 53 1F    MOV   [__r1],A
    1083: 52 0E    MOV   A,[X+14]
    1085: 53 1E    MOV   [__r2],A
    1087: 52 0F    MOV   A,[X+15]
    1089: 53 1D    MOV   [__r3],A
    108B: 38 EA    ADD   SP,0xEA
    108D: 20       POP   X
    108E: 7F       RET   
(0282) }
(0283) 
(0284) /* Action lookup. Takes the appropriate action for the given command and param.
(0285)  * command: the command read from the UART.
(0286)  * param: the data (if any) associated with the command.
(0287)  */
(0288) void action(char command, char* param)
(0289) {	
_action:
  param                --> X-6
  command              --> X-4
    108F: 10       PUSH  X
    1090: 4F       MOV   X,SP
    1091: 38 02    ADD   SP,0x2
(0290) 	if(debug)
    1093: 62 D0 00 MOV   REG[0xD0],0x0
    1096: 3C 31 00 CMP   [debug],0x0
    1099: A0 33    JZ    0x10CD
(0291) 	{
(0292) 		UART_PutCRLF();
    109B: 10       PUSH  X
    109C: 7C 09 83 LCALL _UART_PutCRLF
(0293) 		UART_CPutString("Command: ");
    109F: 50 03    MOV   A,0x3
    10A1: 08       PUSH  A
    10A2: 50 2F    MOV   A,0x2F
    10A4: 5C       MOV   X,A
    10A5: 18       POP   A
    10A6: 7C 09 71 LCALL _UART_CPutString
    10A9: 20       POP   X
(0294) 		UART_PutChar(command);
    10AA: 10       PUSH  X
    10AB: 52 FC    MOV   A,[X-4]
    10AD: 7C 08 CE LCALL _UART_PutChar
(0295) 		UART_PutCRLF();
    10B0: 7C 09 83 LCALL _UART_PutCRLF
(0296) 		UART_CPutString("Param: ");
    10B3: 50 03    MOV   A,0x3
    10B5: 08       PUSH  A
    10B6: 50 27    MOV   A,0x27
    10B8: 5C       MOV   X,A
    10B9: 18       POP   A
    10BA: 7C 09 71 LCALL _UART_CPutString
    10BD: 20       POP   X
(0297) 		UART_PutString(param);
    10BE: 10       PUSH  X
    10BF: 52 FA    MOV   A,[X-6]
    10C1: 08       PUSH  A
    10C2: 52 FB    MOV   A,[X-5]
    10C4: 5C       MOV   X,A
    10C5: 18       POP   A
    10C6: 7C 09 0B LCALL _UART_PutString
(0298) 		UART_PutCRLF();
    10C9: 7C 09 83 LCALL _UART_PutCRLF
    10CC: 20       POP   X
(0299) 	}
(0300) 	
(0301) 	switch (command)
    10CD: 52 FC    MOV   A,[X-4]
    10CF: 54 01    MOV   [X+1],A
    10D1: 56 00 00 MOV   [X+0],0x0
    10D4: 52 01    MOV   A,[X+1]
    10D6: 11 61    SUB   A,0x61
    10D8: 52 00    MOV   A,[X+0]
    10DA: 31 80    XOR   A,0x80
    10DC: 19 80    SBB   A,0x80
    10DE: C4 1E    JC    0x14FD
    10E0: 50 70    MOV   A,0x70
    10E2: 13 01    SUB   A,[X+1]
    10E4: 52 00    MOV   A,[X+0]
    10E6: 31 80    XOR   A,0x80
    10E8: 62 D0 00 MOV   REG[0xD0],0x0
    10EB: 53 14    MOV   [__rX],A
    10ED: 50 80    MOV   A,0x80
    10EF: 1A 14    SBB   A,[__rX]
    10F1: C4 0B    JC    0x14FD
    10F3: 62 D0 00 MOV   REG[0xD0],0x0
    10F6: 52 01    MOV   A,[X+1]
    10F8: 11 61    SUB   A,0x61
    10FA: 53 1F    MOV   [__r1],A
    10FC: 52 00    MOV   A,[X+0]
    10FE: 19 00    SBB   A,0x0
    1100: 53 20    MOV   [__r0],A
    1102: 65 1F    ASL   [__r1]
    1104: 6B 20    RLC   [__r0]
    1106: 06 1F 84 ADD   [__r1],0x84
    1109: 0E 20 05 ADC   [__r0],0x5
    110C: 51 20    MOV   A,[__r0]
    110E: 10       PUSH  X
    110F: 58 1F    MOV   X,[__r1]
    1111: 08       PUSH  A
    1112: 28       ROMX  
    1113: 53 20    MOV   [__r0],A
    1115: 18       POP   A
    1116: 75       INC   X
    1117: 09 00    ADC   A,0x0
    1119: 28       ROMX  
    111A: 53 1F    MOV   [__r1],A
    111C: 20       POP   X
    111D: 51 20    MOV   A,[__r0]
    111F: 08       PUSH  A
    1120: 51 1F    MOV   A,[__r1]
    1122: 08       PUSH  A
    1123: 7F       RET   
(0302) 	{
(0303) 		case 'a': //MAV
(0304) 			if (debug)
    1124: 62 D0 00 MOV   REG[0xD0],0x0
    1127: 3C 31 00 CMP   [debug],0x0
    112A: A3 F8    JZ    0x1523
(0305) 			{
(0306) 				UART_PutCRLF();
    112C: 10       PUSH  X
    112D: 7C 09 83 LCALL _UART_PutCRLF
(0307) 				UART_CPutString("Setting velocity to: ");
    1130: 50 03    MOV   A,0x3
    1132: 08       PUSH  A
    1133: 50 11    MOV   A,0x11
    1135: 5C       MOV   X,A
    1136: 18       POP   A
    1137: 7C 09 71 LCALL _UART_CPutString
    113A: 20       POP   X
(0308) 				UART_PutSHexInt(atoi(param));
    113B: 52 FA    MOV   A,[X-6]
    113D: 08       PUSH  A
    113E: 52 FB    MOV   A,[X-5]
    1140: 08       PUSH  A
    1141: 7C 1A D1 LCALL _atoi
    1144: 38 FE    ADD   SP,0xFE
    1146: 10       PUSH  X
    1147: 62 D0 00 MOV   REG[0xD0],0x0
    114A: 51 20    MOV   A,[__r0]
    114C: 08       PUSH  A
    114D: 51 1F    MOV   A,[__r1]
    114F: 20       POP   X
    1150: 7C 08 C7 LCALL _UART_PutSHexInt
(0309) 				UART_PutCRLF();
    1153: 7C 09 83 LCALL _UART_PutCRLF
    1156: 20       POP   X
(0310) 			}
(0311) 			
(0312) 			break;
    1157: 83 CB    JMP   0x1523
(0313) 		case 'b': //MOV
(0314) 			if (debug)
    1159: 62 D0 00 MOV   REG[0xD0],0x0
    115C: 3C 31 00 CMP   [debug],0x0
    115F: A0 2C    JZ    0x118C
(0315) 			{
(0316) 				UART_PutCRLF();
    1161: 10       PUSH  X
    1162: 7C 09 83 LCALL _UART_PutCRLF
(0317) 				UART_CPutString("Setting PWM duty cycle to: ");
    1165: 50 02    MOV   A,0x2
    1167: 08       PUSH  A
    1168: 50 F5    MOV   A,0xF5
    116A: 5C       MOV   X,A
    116B: 18       POP   A
    116C: 7C 09 71 LCALL _UART_CPutString
    116F: 20       POP   X
(0318) 				UART_PutSHexInt(atoi(param));
    1170: 52 FA    MOV   A,[X-6]
    1172: 08       PUSH  A
    1173: 52 FB    MOV   A,[X-5]
    1175: 08       PUSH  A
    1176: 7C 1A D1 LCALL _atoi
    1179: 38 FE    ADD   SP,0xFE
    117B: 10       PUSH  X
    117C: 62 D0 00 MOV   REG[0xD0],0x0
    117F: 51 20    MOV   A,[__r0]
    1181: 08       PUSH  A
    1182: 51 1F    MOV   A,[__r1]
    1184: 20       POP   X
    1185: 7C 08 C7 LCALL _UART_PutSHexInt
(0319) 				UART_PutCRLF();
    1188: 7C 09 83 LCALL _UART_PutCRLF
    118B: 20       POP   X
(0320) 			}
(0321) 			
(0322) 			PWMA_WritePulseWidth(atoi(param));
    118C: 52 FA    MOV   A,[X-6]
    118E: 08       PUSH  A
    118F: 52 FB    MOV   A,[X-5]
    1191: 08       PUSH  A
    1192: 7C 1A D1 LCALL _atoi
    1195: 38 FE    ADD   SP,0xFE
    1197: 62 D0 00 MOV   REG[0xD0],0x0
    119A: 51 1F    MOV   A,[__r1]
    119C: 10       PUSH  X
    119D: 7C 0B 39 LCALL _PWMA_WritePulseWidth
    11A0: 20       POP   X
(0323) 			PWMB_WritePulseWidth(atoi(param));
    11A1: 52 FA    MOV   A,[X-6]
    11A3: 08       PUSH  A
    11A4: 52 FB    MOV   A,[X-5]
    11A6: 08       PUSH  A
    11A7: 7C 1A D1 LCALL _atoi
    11AA: 38 FE    ADD   SP,0xFE
    11AC: 62 D0 00 MOV   REG[0xD0],0x0
    11AF: 51 1F    MOV   A,[__r1]
    11B1: 10       PUSH  X
    11B2: 7C 0A F2 LCALL _PWMB_WritePulseWidth
    11B5: 20       POP   X
(0324) 			break;
    11B6: 83 6C    JMP   0x1523
(0325) 		case 'c': //GETV
(0326) 			*param = 0;
    11B8: 62 D0 00 MOV   REG[0xD0],0x0
    11BB: 52 FB    MOV   A,[X-5]
    11BD: 53 1F    MOV   [__r1],A
    11BF: 52 FA    MOV   A,[X-6]
    11C1: 60 D5    MOV   REG[0xD5],A
    11C3: 50 00    MOV   A,0x0
    11C5: 3F 1F    MVI   [__r1],A
(0327) 			if (debug)
    11C7: 62 D0 00 MOV   REG[0xD0],0x0
    11CA: 3C 31 00 CMP   [debug],0x0
    11CD: A0 49    JZ    0x1217
(0328) 			{
(0329) 				UART_PutCRLF();
    11CF: 10       PUSH  X
    11D0: 7C 09 83 LCALL _UART_PutCRLF
    11D3: 20       POP   X
(0330) 				UART_PutString(itoa(param, getVelocity(), 10));
    11D4: 9B D5    CALL  _getVelocity
    11D6: 50 00    MOV   A,0x0
    11D8: 08       PUSH  A
    11D9: 50 0A    MOV   A,0xA
    11DB: 08       PUSH  A
    11DC: 62 D0 00 MOV   REG[0xD0],0x0
    11DF: 51 20    MOV   A,[__r0]
    11E1: 08       PUSH  A
    11E2: 51 1F    MOV   A,[__r1]
    11E4: 08       PUSH  A
    11E5: 51 1E    MOV   A,[__r2]
    11E7: 08       PUSH  A
    11E8: 51 1D    MOV   A,[__r3]
    11EA: 08       PUSH  A
    11EB: 7C 15 DA LCALL 0x15DA
    11EE: 18       POP   A
    11EF: 53 1F    MOV   [__r1],A
    11F1: 18       POP   A
    11F2: 38 FE    ADD   SP,0xFE
    11F4: 08       PUSH  A
    11F5: 51 1F    MOV   A,[__r1]
    11F7: 08       PUSH  A
    11F8: 52 FA    MOV   A,[X-6]
    11FA: 08       PUSH  A
    11FB: 52 FB    MOV   A,[X-5]
    11FD: 08       PUSH  A
    11FE: 7C 1C 12 LCALL _itoa
    1201: 38 FA    ADD   SP,0xFA
    1203: 10       PUSH  X
    1204: 62 D0 00 MOV   REG[0xD0],0x0
    1207: 51 20    MOV   A,[__r0]
    1209: 08       PUSH  A
    120A: 51 1F    MOV   A,[__r1]
    120C: 5C       MOV   X,A
    120D: 18       POP   A
    120E: 7C 09 0B LCALL _UART_PutString
(0331) 				UART_PutCRLF();
    1211: 7C 09 83 LCALL _UART_PutCRLF
    1214: 20       POP   X
(0332) 			}
    1215: 83 0D    JMP   0x1523
(0333) 			else 
(0334) 			{
(0335) 				UART_PutString(itoa(param, getVelocity(), 10));
    1217: 9B 92    CALL  _getVelocity
    1219: 50 00    MOV   A,0x0
    121B: 08       PUSH  A
    121C: 50 0A    MOV   A,0xA
    121E: 08       PUSH  A
    121F: 62 D0 00 MOV   REG[0xD0],0x0
    1222: 51 20    MOV   A,[__r0]
    1224: 08       PUSH  A
    1225: 51 1F    MOV   A,[__r1]
    1227: 08       PUSH  A
    1228: 51 1E    MOV   A,[__r2]
    122A: 08       PUSH  A
    122B: 51 1D    MOV   A,[__r3]
    122D: 08       PUSH  A
    122E: 7C 15 DA LCALL 0x15DA
    1231: 18       POP   A
    1232: 53 1F    MOV   [__r1],A
    1234: 18       POP   A
    1235: 38 FE    ADD   SP,0xFE
    1237: 08       PUSH  A
    1238: 51 1F    MOV   A,[__r1]
    123A: 08       PUSH  A
    123B: 52 FA    MOV   A,[X-6]
    123D: 08       PUSH  A
    123E: 52 FB    MOV   A,[X-5]
    1240: 08       PUSH  A
    1241: 7C 1C 12 LCALL _itoa
    1244: 38 FA    ADD   SP,0xFA
    1246: 10       PUSH  X
    1247: 62 D0 00 MOV   REG[0xD0],0x0
    124A: 51 20    MOV   A,[__r0]
    124C: 08       PUSH  A
    124D: 51 1F    MOV   A,[__r1]
    124F: 5C       MOV   X,A
    1250: 18       POP   A
    1251: 7C 09 0B LCALL _UART_PutString
    1254: 20       POP   X
(0336) 			}
(0337) 			break;
    1255: 82 CD    JMP   0x1523
(0338) 		case 'd': //SRV0_POS
(0339) 			if (debug)
    1257: 62 D0 00 MOV   REG[0xD0],0x0
    125A: 3C 31 00 CMP   [debug],0x0
    125D: A0 2C    JZ    0x128A
(0340) 			{
(0341) 				UART_PutCRLF();
    125F: 10       PUSH  X
    1260: 7C 09 83 LCALL _UART_PutCRLF
(0342) 				UART_CPutString("Setting servo 0 pulse width to: ");
    1263: 50 02    MOV   A,0x2
    1265: 08       PUSH  A
    1266: 50 D4    MOV   A,0xD4
    1268: 5C       MOV   X,A
    1269: 18       POP   A
    126A: 7C 09 71 LCALL _UART_CPutString
    126D: 20       POP   X
(0343) 				UART_PutSHexInt(atoi(param));
    126E: 52 FA    MOV   A,[X-6]
    1270: 08       PUSH  A
    1271: 52 FB    MOV   A,[X-5]
    1273: 08       PUSH  A
    1274: 7C 1A D1 LCALL _atoi
    1277: 38 FE    ADD   SP,0xFE
    1279: 10       PUSH  X
    127A: 62 D0 00 MOV   REG[0xD0],0x0
    127D: 51 20    MOV   A,[__r0]
    127F: 08       PUSH  A
    1280: 51 1F    MOV   A,[__r1]
    1282: 20       POP   X
    1283: 7C 08 C7 LCALL _UART_PutSHexInt
(0344) 				UART_PutCRLF();
    1286: 7C 09 83 LCALL _UART_PutCRLF
    1289: 20       POP   X
(0345) 			}
(0346) 			
(0347) 			if ((Servo0_CONTROL_LSB_REG & Servo0_CONTROL_REG_START_BIT) == 0x00) //servo has not been started
    128A: 5D 27    MOV   A,REG[0x27]
    128C: 62 D0 00 MOV   REG[0xD0],0x0
    128F: 53 20    MOV   [__r0],A
    1291: 47 20 01 TST   [__r0],0x1
    1294: B0 06    JNZ   0x129B
(0348) 				Servo0_Start();
    1296: 10       PUSH  X
    1297: 7C 0A 8A LCALL _Servo0_Start
    129A: 20       POP   X
(0349) 			
(0350) 			Servo0_WritePulseWidth(atoi(param));
    129B: 52 FA    MOV   A,[X-6]
    129D: 08       PUSH  A
    129E: 52 FB    MOV   A,[X-5]
    12A0: 08       PUSH  A
    12A1: 7C 1A D1 LCALL _atoi
    12A4: 38 FE    ADD   SP,0xFE
    12A6: 10       PUSH  X
    12A7: 62 D0 00 MOV   REG[0xD0],0x0
    12AA: 51 20    MOV   A,[__r0]
    12AC: 08       PUSH  A
    12AD: 51 1F    MOV   A,[__r1]
    12AF: 20       POP   X
    12B0: 7C 0A 98 LCALL _Servo0_WritePulseWidth
    12B3: 20       POP   X
(0351) 			break;
    12B4: 82 6E    JMP   0x1523
(0352) 		case 'e': //SRV1_POS
(0353) 			if (debug)
    12B6: 62 D0 00 MOV   REG[0xD0],0x0
    12B9: 3C 31 00 CMP   [debug],0x0
    12BC: A0 2C    JZ    0x12E9
(0354) 			{
(0355) 				UART_PutCRLF();
    12BE: 10       PUSH  X
    12BF: 7C 09 83 LCALL _UART_PutCRLF
(0356) 				UART_CPutString("Setting servo 1 pulse width to: ");
    12C2: 50 02    MOV   A,0x2
    12C4: 08       PUSH  A
    12C5: 50 B3    MOV   A,0xB3
    12C7: 5C       MOV   X,A
    12C8: 18       POP   A
    12C9: 7C 09 71 LCALL _UART_CPutString
    12CC: 20       POP   X
(0357) 				UART_PutSHexInt(atoi(param));
    12CD: 52 FA    MOV   A,[X-6]
    12CF: 08       PUSH  A
    12D0: 52 FB    MOV   A,[X-5]
    12D2: 08       PUSH  A
    12D3: 7C 1A D1 LCALL _atoi
    12D6: 38 FE    ADD   SP,0xFE
    12D8: 10       PUSH  X
    12D9: 62 D0 00 MOV   REG[0xD0],0x0
    12DC: 51 20    MOV   A,[__r0]
    12DE: 08       PUSH  A
    12DF: 51 1F    MOV   A,[__r1]
    12E1: 20       POP   X
    12E2: 7C 08 C7 LCALL _UART_PutSHexInt
(0358) 				UART_PutCRLF();
    12E5: 7C 09 83 LCALL _UART_PutCRLF
    12E8: 20       POP   X
(0359) 			}
(0360) 			
(0361) 			if ((Servo1_CONTROL_LSB_REG & Servo1_CONTROL_REG_START_BIT) == 0x00) //servo has not been started
    12E9: 5D 4B    MOV   A,REG[0x4B]
    12EB: 62 D0 00 MOV   REG[0xD0],0x0
    12EE: 53 20    MOV   [__r0],A
    12F0: 47 20 01 TST   [__r0],0x1
    12F3: B0 06    JNZ   0x12FA
(0362) 				Servo1_Start();
    12F5: 10       PUSH  X
    12F6: 7C 0A 2D LCALL _Servo1_Start
    12F9: 20       POP   X
(0363) 			
(0364) 			Servo1_WritePulseWidth(atoi(param));
    12FA: 52 FA    MOV   A,[X-6]
    12FC: 08       PUSH  A
    12FD: 52 FB    MOV   A,[X-5]
    12FF: 08       PUSH  A
    1300: 7C 1A D1 LCALL _atoi
    1303: 38 FE    ADD   SP,0xFE
    1305: 10       PUSH  X
    1306: 62 D0 00 MOV   REG[0xD0],0x0
    1309: 51 20    MOV   A,[__r0]
    130B: 08       PUSH  A
    130C: 51 1F    MOV   A,[__r1]
    130E: 20       POP   X
    130F: 7C 0A 3B LCALL _Servo1_WritePulseWidth
    1312: 20       POP   X
(0365) 			break;
    1313: 82 0F    JMP   0x1523
(0366) 		case 'f': //SRV0_STP
(0367) 			if (debug)
    1315: 62 D0 00 MOV   REG[0xD0],0x0
    1318: 3C 31 00 CMP   [debug],0x0
    131B: A0 13    JZ    0x132F
(0368) 			{
(0369) 				UART_PutCRLF();
    131D: 10       PUSH  X
    131E: 7C 09 83 LCALL _UART_PutCRLF
(0370) 				UART_CPutString("Stopping PWM for servo 0.");
    1321: 50 02    MOV   A,0x2
    1323: 08       PUSH  A
    1324: 50 99    MOV   A,0x99
    1326: 5C       MOV   X,A
    1327: 18       POP   A
    1328: 7C 09 71 LCALL _UART_CPutString
(0371) 				UART_PutCRLF();
    132B: 7C 09 83 LCALL _UART_PutCRLF
    132E: 20       POP   X
(0372) 			}
(0373) 			
(0374) 			Servo0_Stop();;
    132F: 10       PUSH  X
    1330: 7C 0A 8E LCALL _Servo0_Stop
    1333: 20       POP   X
(0375) 			break;
    1334: 81 EE    JMP   0x1523
(0376) 		case 'g': //SRV1_STP
(0377) 			if (debug)
    1336: 62 D0 00 MOV   REG[0xD0],0x0
    1339: 3C 31 00 CMP   [debug],0x0
    133C: A0 13    JZ    0x1350
(0378) 			{
(0379) 				UART_PutCRLF();
    133E: 10       PUSH  X
    133F: 7C 09 83 LCALL _UART_PutCRLF
(0380) 				UART_CPutString("Stopping PWM for servo 1.");
    1342: 50 02    MOV   A,0x2
    1344: 08       PUSH  A
    1345: 50 7F    MOV   A,0x7F
    1347: 5C       MOV   X,A
    1348: 18       POP   A
    1349: 7C 09 71 LCALL _UART_CPutString
(0381) 				UART_PutCRLF();
    134C: 7C 09 83 LCALL _UART_PutCRLF
    134F: 20       POP   X
(0382) 			}
(0383) 			
(0384) 			Servo1_Stop();
    1350: 10       PUSH  X
    1351: 7C 0A 31 LCALL _Servo1_Stop
    1354: 20       POP   X
(0385) 			break;
    1355: 81 CD    JMP   0x1523
(0386) 		case 'h': //GETC1
(0387) 			if (debug)
    1357: 62 D0 00 MOV   REG[0xD0],0x0
    135A: 3C 31 00 CMP   [debug],0x0
    135D: A0 10    JZ    0x136E
(0388) 			{
(0389) 				UART_PutCRLF();
    135F: 10       PUSH  X
    1360: 7C 09 83 LCALL _UART_PutCRLF
(0390) 				UART_CPutString("Encoder 1 count: ");
    1363: 50 02    MOV   A,0x2
    1365: 08       PUSH  A
    1366: 50 6D    MOV   A,0x6D
    1368: 5C       MOV   X,A
    1369: 18       POP   A
    136A: 7C 09 71 LCALL _UART_CPutString
    136D: 20       POP   X
(0391) 			}
(0392) 			
(0393) 			UART_PutSHexInt(count1);
    136E: 62 D0 00 MOV   REG[0xD0],0x0
    1371: 51 24    MOV   A,[count1+3]
    1373: 62 D0 00 MOV   REG[0xD0],0x0
    1376: 53 1F    MOV   [__r1],A
    1378: 62 D0 00 MOV   REG[0xD0],0x0
    137B: 51 23    MOV   A,[count1+2]
    137D: 62 D0 00 MOV   REG[0xD0],0x0
    1380: 10       PUSH  X
    1381: 08       PUSH  A
    1382: 51 1F    MOV   A,[__r1]
    1384: 20       POP   X
    1385: 7C 08 C7 LCALL _UART_PutSHexInt
    1388: 20       POP   X
(0394) 			
(0395) 			if (debug)
    1389: 62 D0 00 MOV   REG[0xD0],0x0
    138C: 3C 31 00 CMP   [debug],0x0
    138F: A1 93    JZ    0x1523
(0396) 				UART_PutCRLF();
    1391: 10       PUSH  X
    1392: 7C 09 83 LCALL _UART_PutCRLF
    1395: 20       POP   X
(0397) 			break;
    1396: 81 8C    JMP   0x1523
(0398) 		case 'i': //GETC2
(0399) 			if (debug)
    1398: 62 D0 00 MOV   REG[0xD0],0x0
    139B: 3C 31 00 CMP   [debug],0x0
    139E: A0 10    JZ    0x13AF
(0400) 			{
(0401) 				UART_PutCRLF();
    13A0: 10       PUSH  X
    13A1: 7C 09 83 LCALL _UART_PutCRLF
(0402) 				UART_CPutString("Encoder 2 count: ");
    13A4: 50 02    MOV   A,0x2
    13A6: 08       PUSH  A
    13A7: 50 5B    MOV   A,0x5B
    13A9: 5C       MOV   X,A
    13AA: 18       POP   A
    13AB: 7C 09 71 LCALL _UART_CPutString
    13AE: 20       POP   X
(0403) 			}
(0404) 			UART_PutSHexInt(count2);
    13AF: 62 D0 00 MOV   REG[0xD0],0x0
    13B2: 51 28    MOV   A,[count2+3]
    13B4: 62 D0 00 MOV   REG[0xD0],0x0
    13B7: 53 1F    MOV   [__r1],A
    13B9: 62 D0 00 MOV   REG[0xD0],0x0
    13BC: 51 27    MOV   A,[count2+2]
    13BE: 62 D0 00 MOV   REG[0xD0],0x0
    13C1: 10       PUSH  X
    13C2: 08       PUSH  A
    13C3: 51 1F    MOV   A,[__r1]
    13C5: 20       POP   X
    13C6: 7C 08 C7 LCALL _UART_PutSHexInt
    13C9: 20       POP   X
(0405) 			
(0406) 			if(debug)
    13CA: 62 D0 00 MOV   REG[0xD0],0x0
    13CD: 3C 31 00 CMP   [debug],0x0
    13D0: A1 52    JZ    0x1523
(0407) 				UART_PutCRLF();
    13D2: 10       PUSH  X
    13D3: 7C 09 83 LCALL _UART_PutCRLF
    13D6: 20       POP   X
(0408) 			break;
    13D7: 81 4B    JMP   0x1523
(0409) 		case 'j': //RSTC1
(0410) 			if(debug)
    13D9: 62 D0 00 MOV   REG[0xD0],0x0
    13DC: 3C 31 00 CMP   [debug],0x0
    13DF: A0 13    JZ    0x13F3
(0411) 			{
(0412) 				UART_PutCRLF();
    13E1: 10       PUSH  X
    13E2: 7C 09 83 LCALL _UART_PutCRLF
(0413) 				UART_CPutString("Resetting count1");
    13E5: 50 02    MOV   A,0x2
    13E7: 08       PUSH  A
    13E8: 50 4A    MOV   A,0x4A
    13EA: 5C       MOV   X,A
    13EB: 18       POP   A
    13EC: 7C 09 71 LCALL _UART_CPutString
(0414) 				UART_PutCRLF();
    13EF: 7C 09 83 LCALL _UART_PutCRLF
    13F2: 20       POP   X
(0415) 			}
(0416) 			
(0417) 			count1 = 0;
    13F3: 62 D0 00 MOV   REG[0xD0],0x0
    13F6: 55 21 00 MOV   [count1],0x0
    13F9: 55 22 00 MOV   [count1+1],0x0
    13FC: 55 23 00 MOV   [count1+2],0x0
    13FF: 55 24 00 MOV   [count1+3],0x0
(0418) 			break;
    1402: 81 20    JMP   0x1523
(0419) 		case 'k': //RSTC2
(0420) 			if(debug)
    1404: 62 D0 00 MOV   REG[0xD0],0x0
    1407: 3C 31 00 CMP   [debug],0x0
    140A: A0 13    JZ    0x141E
(0421) 			{
(0422) 				UART_PutCRLF();
    140C: 10       PUSH  X
    140D: 7C 09 83 LCALL _UART_PutCRLF
(0423) 				UART_CPutString("Resetting count2");
    1410: 50 02    MOV   A,0x2
    1412: 08       PUSH  A
    1413: 50 39    MOV   A,0x39
    1415: 5C       MOV   X,A
    1416: 18       POP   A
    1417: 7C 09 71 LCALL _UART_CPutString
(0424) 				UART_PutCRLF();
    141A: 7C 09 83 LCALL _UART_PutCRLF
    141D: 20       POP   X
(0425) 			}
(0426) 			
(0427) 			count2 = 0;
    141E: 62 D0 00 MOV   REG[0xD0],0x0
    1421: 55 25 00 MOV   [count2],0x0
    1424: 55 26 00 MOV   [count2+1],0x0
    1427: 55 27 00 MOV   [count2+2],0x0
    142A: 55 28 00 MOV   [count2+3],0x0
(0428) 			break;
    142D: 80 F5    JMP   0x1523
(0429) 		case 'l': //STOP
(0430) 			if(debug)
    142F: 62 D0 00 MOV   REG[0xD0],0x0
    1432: 3C 31 00 CMP   [debug],0x0
    1435: A0 13    JZ    0x1449
(0431) 			{
(0432) 				UART_PutCRLF();
    1437: 10       PUSH  X
    1438: 7C 09 83 LCALL _UART_PutCRLF
(0433) 				UART_CPutString("Stopping motors");
    143B: 50 02    MOV   A,0x2
    143D: 08       PUSH  A
    143E: 50 29    MOV   A,0x29
    1440: 5C       MOV   X,A
    1441: 18       POP   A
    1442: 7C 09 71 LCALL _UART_CPutString
(0434) 				UART_PutCRLF();
    1445: 7C 09 83 LCALL _UART_PutCRLF
    1448: 20       POP   X
(0435) 			}
(0436) 			
(0437) 			PWMA_WritePulseWidth(0);
    1449: 10       PUSH  X
    144A: 50 00    MOV   A,0x0
    144C: 7C 0B 39 LCALL _PWMA_WritePulseWidth
(0438) 			PWMB_WritePulseWidth(0);
    144F: 50 00    MOV   A,0x0
    1451: 7C 0A F2 LCALL _PWMB_WritePulseWidth
(0439) 			PWMA_Stop();
    1454: 7C 0B 32 LCALL _PWMA_Stop
(0440) 			PWMB_Stop();
    1457: 7C 0A EB LCALL _PWMB_Stop
    145A: 20       POP   X
(0441) 			break;
    145B: 80 C7    JMP   0x1523
(0442) 		case 'm': //FORWARD
(0443) 			if (debug)
    145D: 62 D0 00 MOV   REG[0xD0],0x0
    1460: 3C 31 00 CMP   [debug],0x0
    1463: A0 13    JZ    0x1477
(0444) 			{
(0445) 				UART_PutCRLF();
    1465: 10       PUSH  X
    1466: 7C 09 83 LCALL _UART_PutCRLF
(0446) 				UART_CPutString("Setting drive mode to forward.");
    1469: 50 02    MOV   A,0x2
    146B: 08       PUSH  A
    146C: 50 0A    MOV   A,0xA
    146E: 5C       MOV   X,A
    146F: 18       POP   A
    1470: 7C 09 71 LCALL _UART_CPutString
(0447) 				UART_PutCRLF();
    1473: 7C 09 83 LCALL _UART_PutCRLF
    1476: 20       POP   X
(0448) 			}
(0449) 			
(0450) 			AIN1_Data_ADDR |= AIN1_MASK;
    1477: 43 04 10 OR    REG[0x4],0x10
(0451) 			AIN2_Data_ADDR |= AIN2_MASK;
    147A: 43 04 40 OR    REG[0x4],0x40
(0452) 			BIN1_Data_ADDR &= ~BIN1_MASK;
    147D: 41 08 FD AND   REG[0x8],0xFD
(0453) 			BIN2_Data_ADDR &= ~BIN2_MASK;
    1480: 41 04 7F AND   REG[0x4],0x7F
(0454) 			break;
    1483: 80 9F    JMP   0x1523
(0455) 		case 'n': //BACKWARD
(0456) 			if (debug)
    1485: 62 D0 00 MOV   REG[0xD0],0x0
    1488: 3C 31 00 CMP   [debug],0x0
    148B: A0 13    JZ    0x149F
(0457) 			{
(0458) 				UART_PutCRLF();
    148D: 10       PUSH  X
    148E: 7C 09 83 LCALL _UART_PutCRLF
(0459) 				UART_CPutString("Setting drive mode to backward.");
    1491: 50 01    MOV   A,0x1
    1493: 08       PUSH  A
    1494: 50 EA    MOV   A,0xEA
    1496: 5C       MOV   X,A
    1497: 18       POP   A
    1498: 7C 09 71 LCALL _UART_CPutString
(0460) 				UART_PutCRLF();
    149B: 7C 09 83 LCALL _UART_PutCRLF
    149E: 20       POP   X
(0461) 			}
(0462) 			
(0463) 			AIN1_Data_ADDR &= ~AIN1_MASK;
    149F: 41 04 EF AND   REG[0x4],0xEF
(0464) 			AIN2_Data_ADDR &= ~AIN2_MASK;
    14A2: 41 04 BF AND   REG[0x4],0xBF
(0465) 			BIN1_Data_ADDR |= BIN1_MASK;
    14A5: 43 08 02 OR    REG[0x8],0x2
(0466) 			BIN2_Data_ADDR |= BIN2_MASK;
    14A8: 43 04 80 OR    REG[0x4],0x80
(0467) 			break;
    14AB: 80 77    JMP   0x1523
(0468) 		case 'o': //TURNL
(0469) 			if (debug)
    14AD: 62 D0 00 MOV   REG[0xD0],0x0
    14B0: 3C 31 00 CMP   [debug],0x0
    14B3: A0 13    JZ    0x14C7
(0470) 			{
(0471) 				UART_PutCRLF();
    14B5: 10       PUSH  X
    14B6: 7C 09 83 LCALL _UART_PutCRLF
(0472) 				UART_CPutString("Setting drive mode to left.");
    14B9: 50 01    MOV   A,0x1
    14BB: 08       PUSH  A
    14BC: 50 CE    MOV   A,0xCE
    14BE: 5C       MOV   X,A
    14BF: 18       POP   A
    14C0: 7C 09 71 LCALL _UART_CPutString
(0473) 				UART_PutCRLF();
    14C3: 7C 09 83 LCALL _UART_PutCRLF
    14C6: 20       POP   X
(0474) 			}
(0475) 			
(0476) 			AIN1_Data_ADDR |= AIN1_MASK;
    14C7: 43 04 10 OR    REG[0x4],0x10
(0477) 			AIN2_Data_ADDR &= ~AIN2_MASK;
    14CA: 41 04 BF AND   REG[0x4],0xBF
(0478) 			BIN1_Data_ADDR &= ~BIN1_MASK;
    14CD: 41 08 FD AND   REG[0x8],0xFD
(0479) 			BIN2_Data_ADDR |= BIN2_MASK;
    14D0: 43 04 80 OR    REG[0x4],0x80
(0480) 			break;
    14D3: 80 4F    JMP   0x1523
(0481) 		case 'p': //TURNR
(0482) 			if (debug)
    14D5: 62 D0 00 MOV   REG[0xD0],0x0
    14D8: 3C 31 00 CMP   [debug],0x0
    14DB: A0 13    JZ    0x14EF
(0483) 			{
(0484) 				UART_PutCRLF();
    14DD: 10       PUSH  X
    14DE: 7C 09 83 LCALL _UART_PutCRLF
(0485) 				UART_CPutString("Setting drive mode to right.");
    14E1: 50 01    MOV   A,0x1
    14E3: 08       PUSH  A
    14E4: 50 B1    MOV   A,0xB1
    14E6: 5C       MOV   X,A
    14E7: 18       POP   A
    14E8: 7C 09 71 LCALL _UART_CPutString
(0486) 				UART_PutCRLF();
    14EB: 7C 09 83 LCALL _UART_PutCRLF
    14EE: 20       POP   X
(0487) 			}
(0488) 			
(0489) 			AIN1_Data_ADDR &= ~AIN1_MASK;
    14EF: 41 04 EF AND   REG[0x4],0xEF
(0490) 			AIN2_Data_ADDR |= AIN2_MASK;
    14F2: 43 04 40 OR    REG[0x4],0x40
(0491) 			BIN1_Data_ADDR |= BIN1_MASK;
    14F5: 43 08 02 OR    REG[0x8],0x2
(0492) 			BIN2_Data_ADDR &= ~BIN2_MASK;
    14F8: 41 04 7F AND   REG[0x4],0x7F
(0493) 			break;
    14FB: 80 27    JMP   0x1523
(0494) 		default : //ERROR
(0495) 			if (debug)
    14FD: 62 D0 00 MOV   REG[0xD0],0x0
    1500: 3C 31 00 CMP   [debug],0x0
    1503: A0 06    JZ    0x150A
(0496) 				UART_PutCRLF();
    1505: 10       PUSH  X
    1506: 7C 09 83 LCALL _UART_PutCRLF
    1509: 20       POP   X
(0497) 			
(0498) 			UART_CPutString("fu1337"); //error code
    150A: 10       PUSH  X
    150B: 50 01    MOV   A,0x1
    150D: 08       PUSH  A
    150E: 50 AA    MOV   A,0xAA
    1510: 5C       MOV   X,A
    1511: 18       POP   A
    1512: 7C 09 71 LCALL _UART_CPutString
    1515: 20       POP   X
(0499) 			
(0500) 			if (debug)
    1516: 62 D0 00 MOV   REG[0xD0],0x0
    1519: 3C 31 00 CMP   [debug],0x0
    151C: A0 06    JZ    0x1523
(0501) 				UART_PutCRLF();
    151E: 10       PUSH  X
    151F: 7C 09 83 LCALL _UART_PutCRLF
    1522: 20       POP   X
(0502) 			break;
    1523: 38 FE    ADD   SP,0xFE
    1525: 20       POP   X
    1526: 7F       RET   
(0503) 	}
(0504) }
(0505) 
(0506) //Encoder 1 interrupts are generated by the falling edge and positive edge paramers.
(0507) void encoder1_ISR(void)
(0508) {
_encoder1_ISR:
    1527: 71 C0    OR    F,0xC0
    1529: 08       PUSH  A
    152A: 5D D0    MOV   A,REG[0xD0]
    152C: 08       PUSH  A
(0509) 	//grab the new state of the encoder register.
(0510) 	curPrt1 = (ENC1A_Data_ADDR & (ENC1A_MASK | ENC1B_MASK));
    152D: 5D 08    MOV   A,REG[0x8]
    152F: 21 50    AND   A,0x50
    1531: 62 D0 00 MOV   REG[0xD0],0x0
    1534: 53 2C    MOV   [curPrt1],A
(0511) 		
(0512) 	//check which state transitioned.
(0513) 	if ((prevPrt1 == 0x00) && (curPrt1 == stateA1)) //A low to high
    1536: 62 D0 00 MOV   REG[0xD0],0x0
    1539: 3C 30 00 CMP   [prevPrt1],0x0
    153C: B0 1A    JNZ   0x1557
    153E: 62 D0 00 MOV   REG[0xD0],0x0
    1541: 3C 2C 20 CMP   [curPrt1],0x20
    1544: B0 12    JNZ   0x1557
(0514) 	{
(0515) 		count1++;
    1546: 62 D0 00 MOV   REG[0xD0],0x0
    1549: 06 24 01 ADD   [count1+3],0x1
    154C: 0E 23 00 ADC   [count1+2],0x0
    154F: 0E 22 00 ADC   [count1+1],0x0
    1552: 0E 21 00 ADC   [count1],0x0
(0516) 	}
    1555: 80 20    JMP   0x1576
(0517) 	else if ((prevPrt1 == 0x00) && (curPrt1 == stateB1)) //B low to high
    1557: 62 D0 00 MOV   REG[0xD0],0x0
    155A: 3C 30 00 CMP   [prevPrt1],0x0
    155D: B0 18    JNZ   0x1576
    155F: 62 D0 00 MOV   REG[0xD0],0x0
    1562: 3C 2C 08 CMP   [curPrt1],0x8
    1565: B0 10    JNZ   0x1576
(0518) 	{
(0519) 		count1--;
    1567: 62 D0 00 MOV   REG[0xD0],0x0
    156A: 16 24 01 SUB   [count1+3],0x1
    156D: 1E 23 00 SBB   [count1+2],0x0
    1570: 1E 22 00 SBB   [count1+1],0x0
    1573: 1E 21 00 SBB   [count1],0x0
(0520) 	}
    1576: 18       POP   A
    1577: 60 D0    MOV   REG[0xD0],A
    1579: 18       POP   A
    157A: 7E       RETI  
(0521) }
(0522) 
(0523) //Encoder 2 interrupts are generated directly by the GPIO interrupt. Logically equivalent
(0524) //to the encoder1_ISR
(0525) void encoder2_ISR(void)
(0526) {
_encoder2_ISR:
    157B: 71 C0    OR    F,0xC0
    157D: 08       PUSH  A
    157E: 5D D0    MOV   A,REG[0xD0]
    1580: 08       PUSH  A
(0527) 	curPrt2 = (ENC2A_Data_ADDR & (ENC2A_MASK | ENC2B_MASK));	
    1581: 5D 08    MOV   A,REG[0x8]
    1583: 21 28    AND   A,0x28
    1585: 62 D0 00 MOV   REG[0xD0],0x0
    1588: 53 2F    MOV   [curPrt2],A
(0528) 		
(0529) 	if ((prevPrt2 == 0x00) && (curPrt2 == stateA2))	
    158A: 62 D0 00 MOV   REG[0xD0],0x0
    158D: 3C 2E 00 CMP   [prevPrt2],0x0
    1590: B0 1A    JNZ   0x15AB
    1592: 62 D0 00 MOV   REG[0xD0],0x0
    1595: 3C 2F 10 CMP   [curPrt2],0x10
    1598: B0 12    JNZ   0x15AB
(0530) 	{
(0531) 		count2++;
    159A: 62 D0 00 MOV   REG[0xD0],0x0
    159D: 06 28 01 ADD   [count2+3],0x1
    15A0: 0E 27 00 ADC   [count2+2],0x0
    15A3: 0E 26 00 ADC   [count2+1],0x0
    15A6: 0E 25 00 ADC   [count2],0x0
(0532) 	}
    15A9: 80 20    JMP   0x15CA
(0533) 	else if ((prevPrt2 == 0x00) && (curPrt2 == stateB2))
    15AB: 62 D0 00 MOV   REG[0xD0],0x0
    15AE: 3C 2E 00 CMP   [prevPrt2],0x0
    15B1: B0 18    JNZ   0x15CA
    15B3: 62 D0 00 MOV   REG[0xD0],0x0
    15B6: 3C 2F 04 CMP   [curPrt2],0x4
    15B9: B0 10    JNZ   0x15CA
(0534) 	{
(0535) 		count2--;
    15BB: 62 D0 00 MOV   REG[0xD0],0x0
    15BE: 16 28 01 SUB   [count2+3],0x1
    15C1: 1E 27 00 SBB   [count2+2],0x0
    15C4: 1E 26 00 SBB   [count2+1],0x0
    15C7: 1E 25 00 SBB   [count2],0x0
(0536) 	}
    15CA: 18       POP   A
    15CB: 60 D0    MOV   REG[0xD0],A
    15CD: 18       POP   A
    15CE: 7E       RETI  
